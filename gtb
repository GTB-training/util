#!/usr/bin/env bash

VERSION=1.92.0

GTB_DEBUG=${GTB_DEBUG:-false}

GTB_ROOT="${GTB_ROOT:-$HOME/code/gtb}"
GTB_TERM="${GTB_TERM:?GTB_TERM should be set! (gtb-101, gtb-201, etc.)}"
GTB_CONFIG_REPO=config
GTB_CONFIG_DIR="$GTB_ROOT/$GTB_CONFIG_REPO"
GTB_TRAINERS_FILE="${GTB_TRAINERS_FILE:-$GTB_CONFIG_DIR/trainers.txt}"
GTB_STUDENTS_FILE_DEFAULT="${GTB_CONFIG_DIR}/students.txt"
GTB_STUDENTS_FILE_TERM="${GTB_CONFIG_DIR}/students-${GTB_TERM}.txt"

if [[ -f $GTB_STUDENTS_FILE ]]; then
    GTB_STUDENTS_FILE=$GTB_STUDENTS_FILE
elif [[ -f $GTB_STUDENTS_FILE_TERM ]]; then
    GTB_STUDENTS_FILE=$GTB_STUDENTS_FILE_TERM
elif [[ -f $GTB_STUDENTS_FILE_DEFAULT ]]; then
    GTB_STUDENTS_FILE=$GTB_STUDENTS_FILE_DEFAULT
fi

GTB_MAX_RETRY_TIMES_REPO_PICK="${GTB_MAX_RETRY_TIMES_REPO_PICK:-3}"
GTB_DASHBOARD_ADDRESS="${GTB_DASHBOARD_ADDRESS:?Please set env GTB_DASHBOARD_ADDRESS correctly! (P.S. Ask ZHANG Zhe)}"
GTB_SONAR_ADDRESS="${GTB_SONAR_ADDRESS:?Please set env GTB_SONAR_ADDRESS correctly! (P.S. Ask ZHANG Zhe)}"
GTB_SONAR_TOKEN="${GTB_SONAR_TOKEN:?Please set env GTB_SONAR_TOKEN correctly! (P.S. Ask ZHANG Zhe)}"
GTB_RANDOM_LIST_FILE="/tmp/gtb_random_list.txt"
GTB_EXCLUDE_DIRS=( --exclude-dir '.git' --exclude-dir 'build' --exclude-dir 'gradle' --exclude-dir 'node_modules' --exclude-dir 'dist' --exclude-dir '.cache' )
GTB_REPOS_DIR="repos"
GTB_TERMS_DIR="terms"
SUBCMD_PREFIX='_gtb'
GTB_DEFAULT_REPO_ROOT="${GTB_DEFAULT_REPO_ROOT:-$GTB_ROOT/$GTB_REPOS_DIR/default}"
GTB_PER_PAGE=100

GTB_ORG=tws-graduate-program

GTB_TRELLO_API='https://api.trello.com/1'
GTB_TRELLO_API_KEY="${GTB_TRELLO_API_KEY:?Trello API Key should be set! 'https://trello.com/app-key'}"
GTB_TRELLO_TOKEN="${GTB_TRELLO_TOKEN:?Trello token should be set! 'https://trello.com/app-key'}"
GTB_TRELLO_AUTH="key=$GTB_TRELLO_API_KEY&token=$GTB_TRELLO_TOKEN"

GTB_FIELDS="1-"
GTB_YES="false"
GTB_RAW="false"
GTB_ALL_BRANCHES="false"
GTB_NOTIFY="false"
GTB_LINE_NUMBERS="true"
GTB_SORT_ORDER=""
GTB_TABLE_FORMAT_SEPARATOR=' '

SYMBOL_OK='✅'
SYMBOL_ERROR='❌'

cuts() {
    cat | cut -d' ' "$@"
}

green() {
    echo -n "$(tput setaf 28)$(tput bold)$*$(tput sgr 0)"
}

blue() {
    echo -n "$(tput setaf 32)$(tput bold)$*$(tput sgr 0)"
}

yellow() {
    echo -n "$(tput setaf 220)$(tput bold)$*$(tput sgr 0)"
}

red() {
    echo -n "$(tput setaf 161)$(tput bold)$*$(tput sgr 0)"
}

info() {
    echo "$(tput setaf 4)$(tput bold)$*$(tput sgr 0)"
}

warn() {
    echo "$(tput setaf 3)$(tput bold)$*$(tput sgr 0)"
}

error() {
    echo "$(tput setaf 1)$(tput bold)$*$(tput sgr 0)" >&2
}

debug() {
    echo "$(tput setaf 5)$(tput bold)$*$(tput sgr 0)"
}

run() {
    [[ "$GTB_DEBUG" == "true" ]] && echo "$(tput setaf 22)$*$(tput sgr 0)" 1>&2
    eval $*
}

header() {
    tput bold
    tput setaf 19
    tput setab 251
    printf "%-$(tput cols)s" "$*" 1>&2
    tput sgr0
    printf "\n" 1>&2
}

logt() {
    local fg_color=$1
    local bg_color=$2
    shift 2
    echo "$(tput setab $bg_color)$(tput setaf $fg_color)$*$(tput sgr 0)"
}

logtf() {
    local fg_color=$1
    shift
    echo "$(tput setaf $fg_color)$*$(tput sgr 0)"
}

logtb() {
    local bg_color=$1
    shift
    echo "$(tput setab $bg_color)$*$(tput sgr 0)"
}

logtn() {
    local fg_color=$1
    local bg_color=$2
    shift 2
    echo -n "$(tput setab $bg_color)$(tput setaf $fg_color)$*$(tput sgr 0)"
}

fail() {
    error $*
    exit 1
}

strip_colors() {
    while read -r line
    do
        echo "$line" | \
            sed $'s,\x1b\\[[0-9;]*[a-zA-Z],,g'
    done
}

_gtb_open() {
    [[ $# -lt 1 ]] && fail "Arguments required for open command!"
    run "open ${*}"
}

_gtb_mute_stdout() {
    [[ "$GTB_DEBUG" == "true" ]] && echo '' || echo '1>/dev/null'
}

_gtb_mute_stderr() {
    [[ "$GTB_DEBUG" == "true" ]] && echo '' || echo '2>/dev/null'
}

_gtb_urlencode() {
    node --eval "console.log(encodeURIComponent(process.argv[1]))" "$*"
}

_gtb_tee1() {
    cat | tee /dev/tty
}

_gtb_tabularize() {
    if [[ -z "$*" ]]; then
        cat | column -s'|' -t
    else
        cat | column -s'|' -t | sed $'1s:^:\\\n'"==> $1"$'\\\n:'
    fi
}

_gtb_table_format() {
    while (( "$#" )); do
        case "$1" in
            --raw)
                GTB_RAW="true"
                shift
                ;;
            -N|--no-line-numbers)
                GTB_LINE_NUMBERS="false"
                shift
                ;;
            -s)
                if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
                    GTB_TABLE_FORMAT_SEPARATOR="$2"
                    shift 2
                else
                    fail "Error: separator specified by '$1' is missing"
                fi
                ;;
            *)
                shift
                ;;
        esac
    done

    if [[ "$GTB_RAW" == "true" ]]
    then
        cat
        return
    fi

    if [[ "$GTB_LINE_NUMBERS" != "true" ]]
    then
        cat | column -s"$GTB_TABLE_FORMAT_SEPARATOR" -t
        return
    fi

    cat | _gtb_nl | column -s"$GTB_TABLE_FORMAT_SEPARATOR" -t
}

_gtb_tr_symbols() {
    cat | sed -E \
        -e "s/(^| )(OK)( |$)/\1$SYMBOL_OK\3/" \
        -e "s/(^| )(ER)( |$)/\1$SYMBOL_ERROR\3/"
}

_gtb_highlight() {
    local result="$(cat)"

    if [[ "$GTB_RAW" == "true" ]]
    then
        echo "$result"
        return
    fi

    while [[ $# -ge 2 ]]
    do
        result=$(echo "$result" | sed -E "s/(^| )($1)( |$)/\1$($2 $1)\3/")
        shift 2
    done

    echo "$result"
}

_gtb_auto_notify() {
    if ! which slack >/dev/null
    then
        cat
        return
    fi

    if [[ "$GTB_NOTIFY" != "true" ]]
    then
        cat
        return
    fi

    local result="$(cat)"
    local result_to_notify=$(echo "$result" | tail -n10)
    if [[ "$GTB_DEBUG" == "true" ]]
    then
        slack chat send --channel '#gtb' --text "$result_to_notify"
    else
        slack chat send --channel '#gtb' --text "$result_to_notify" 1>/dev/null
    fi
    echo "$result"
}

_gtb_auto_schedule() {
    [[ -z "$GTB_SCHEDULE" ]] && return

    local START_AT=$(echo $GTB_SCHEDULE | sed -E 's/[^0-9]//g' | cut -c1-12)
    START_AT=$(echo $(($START_AT * 1000000)) | cut -c1-12)

    # date -v4m -v16d -v9H -v0M -v0S '+%Y-%m-%dT%H:%M:%S%z' | sed -E 's/(..)$/:\1/'
    # 2021-04-16T09:00:00+08:00
    local time_to_start=$(date \
        -v$(echo $START_AT | cut -c1-4)y \
        -v$(echo $START_AT | cut -c5-6)m \
        -v$(echo $START_AT | cut -c7-8)d \
        -v$(echo $START_AT | cut -c9-10)H \
        -v$(echo $START_AT | cut -c11-12)M \
        -v0S \
        '+%Y-%m-%d %A %H:%M:%S')
    local timestamp_to_start=$(date \
        -j -f '%Y-%m-%d %A %H:%M:%S' "$time_to_start" '+%s')

    local secs=$(( $timestamp_to_start - $(date +%s) ))
    if [[ "$secs" -le 0 ]]
    then
        warn 'warn: scheduled time is before the current time.'
    fi

    echo "this command is scheduled running at '$(red $time_to_start)'"

    if [[ "false" == "$GTB_YES" ]]
    then
        read -p "do you want to start countdown? (y|n) " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]
        then
            fail 'error: user canceled the schedule, abort running'
        fi
    fi

    secs=$(( $timestamp_to_start - $(date +%s) ))
    while [[ "$secs" -gt 0 ]]
    do
        echo -ne "$((secs/86400))d $((secs%86400/3600))h $((secs%3600/60))m $((secs%60))s left to continue...\n"
        sleep 1
        secs=$(( $timestamp_to_start - $(date +%s) ))
        tput cuu1
        tput el
    done

    echo
}

_current_datetime() {
    date "+%Y%m%d-%H%M%S"
}

_gtb_time_format_for_display() {
    local TIMESTAMP=${1:?timestamp is required!}
    date -jf '%s' "$TIMESTAMP" '+%Y-%m-%d %A %H:%M:%S'
}

_gtb_time_format_for_api() {
    local TIMESTAMP=${1:?timestamp is required!}
    date -jf '%s' "$TIMESTAMP" '+%Y-%m-%dT%H:%M:%S%z' | sed -E 's/(..)$/:\1/'
}

_gtb_time_format_convert_time_zone() {
    local DATETIME=${1:?Datetime is required!}

    date -jf '%Y-%m-%dT%H:%M:%S%z' \
        "$(echo $DATETIME | sed -E 's/(.*)Z$/\1+0000/g')" \
        '+%Y-%m-%d %H:%M:%S %a' \
        | tr ' ' '_'
}

_gtb_print_in_columns() {
    cat | pr -${1:-3} -t -w $(tput cols)
}

_gtb_pv() {
    cat | pv -tbelSs $1 -i 0.3 -N "total is: $1 current is"
}

_gtb_unformat() {
    cat | tr '\t' ' ' | tr -s ' ' | sed 's/^ //'
}

_gtb_cuts() {
    cat | cut -d ' ' -f "${*}"
}

_gtb_count() {
    local input="$(cat)"
    local lines_count=$(_gtb_count_lines "$input")
    {
        echo "$input" | sort | uniq -c | sed -E 's/^ +//g'
        echo -e "$lines_count TOTAL"
    } | column -t
}

_gtb_date() {
    local DATETIME="${1:? Datetime string is required!}"
    shift

    if [[ "$DATETIME" == "now" ]]
    then
        DATETIME="$(date '+%Y-%m-%d_%H:%M:%S_%a')"
    fi

    DATETIME=$(echo $DATETIME | sed -E 's/[^0-9]//g' | cut -c1-12)
    DATETIME=$(echo $(($DATETIME * 1000000)) | cut -c1-12)

    # date -v4m -v16d -v9H -v0M -v0S '+%Y-%m-%dT%H:%M:%S%z' | sed -E 's/(..)$/:\1/'
    # 2021-04-16T09:00:00+08:00
    local TS=$(date \
        -v$(echo $DATETIME | cut -c1-4)y \
        -v$(echo $DATETIME | cut -c5-6)m \
        -v$(echo $DATETIME | cut -c7-8)d \
        -v$(echo $DATETIME | cut -c9-10)H \
        -v$(echo $DATETIME | cut -c11-12)M \
        -v0S \
        '+%s')

    for OFFSET in "$@"
    do
        OFFSET=$(echo $OFFSET | tr 'Dhms' 'dHMS')
        TS=$(date -v${OFFSET} -jf '%s' "$TS" '+%s')
    done

    date -jf '%s' "$TS" '+%Y-%m-%d_%H:%M:%S_%a'
}

_gtb_quotes_line() {
    local QUOTE="${1:-\"}"
    cat | sed -E "s/^/$QUOTE/;s/$/$QUOTE/"
}

_gtb_join_lines() {
    local SEPARATOR="${1:-,}"
    cat | paste -s -d"$SEPARATOR" - | tr -d '\n'
}

_gtb_nl() {
    cat | nl | _gtb_unformat
}

_gtb_default_repo_dir() {
    local REPO_NAME=${1:?Repo name is required!}
    echo "$GTB_DEFAULT_REPO_ROOT/$REPO_NAME"
}

_gtb_run_subcommand() {
    COMMAND=${1:?Command is required! (e.g. repo, student.)}
    shift
    SUBCOMMAND=${1:?Subcommand is required! (e.g. list, add, remove.)}
    shift

    local subcommand_function="_gtb_${COMMAND}_${SUBCOMMAND}"

    if [[ "$(type -t $subcommand_function)" != 'function' ]]; then
        fail "error: Unknown subcommand: $SUBCOMMAND"
    fi

    $subcommand_function "$@"
}

_gtb_filter_students() {
    grep "\<$GTB_TERM\>" $GTB_STUDENTS_FILE | while read -r FULLNAME OWNER TERM_NAME USERNAME TRELLO_EMAIL NICKNAME CHINESE_NAME TAGS
    do
        if [[ -z "$*" ]] \
            || echo "$*" | grep --silent "\<${FULLNAME}\>" \
            || echo "$*" | grep --silent "\<${USERNAME}\>"  \
            || echo "$*" | grep --silent "\<${TRELLO_EMAIL}\>" \
            || echo "$*" | grep --silent "\<${NICKNAME}\>" \
            || echo "$*" | grep --silent "\<${OWNER}\>"
        then
            printf "%s\n" "$FULLNAME $OWNER $TERM_NAME $USERNAME $TRELLO_EMAIL $NICKNAME $CHINESE_NAME $TAGS"
            continue
        fi

        for FILTER in "$@"
        do
            if echo "$TAGS" | grep --silent "\<${FILTER}\>"
            then
                printf "%s\n" "$FULLNAME $OWNER $TERM_NAME $USERNAME $TRELLO_EMAIL $NICKNAME $CHINESE_NAME $TAGS"
                continue
            fi
        done

        for FILTER in "$@"
        do
            if [[ "$CHINESE_NAME" == "${FILTER}" ]]
            then
                printf "%s\n" "$FULLNAME $OWNER $TERM_NAME $USERNAME $TRELLO_EMAIL $NICKNAME $CHINESE_NAME $TAGS"
                continue
            fi
        done
    done
}

gh_check_user() {
    local USERNAME=${1:?username is required!}
    local result=$(run "gh api '/users/$USERNAME' $(_gtb_mute_stderr)" \
        | jq -r 'if .login then "OK" else "ER" end')
    if [[ -z "$result" ]]
    then
        result='ER'
    fi
    echo "$result $*"
}

gh_user_id() {
    local USERNAME=${1:?username is required!}
    run "gh api /users/${USERNAME} 2>/dev/null" | jsonpp | \
        grep '"\(id\)"' | \
        tr -d ' ,' | \
        cut -d':' -f2
}

gh_invite_user_to_org() {
    local ORG=${1:?org is required!}
    local USERNAME=${2:?username is required!}
    local ROLE=${3:-direct_member}
    local result=$(gh_create_invitation $ORG $(gh_user_id $USERNAME) $ROLE \
        | jq -r 'if .created_at or .errors[0].message == "Invitee is already a part of this org" then "OK" else "ER" end')
    if [[ -z "$result" ]]
    then
        result='ER'
    fi
    echo "$result $*"
}

gh_remove_user_from_org() {
    local ORG=${1:?org is required!}
    local USERNAME=${2:?username is required!}
    run "gh api -X DELETE /orgs/${ORG}/members/$USERNAME 1>/dev/null 2>&1"
}

gh_invite_user_to_team() {
    local ORG=${1:?org is required!}
    local TEAM=${2:?team is required!}
    local USERNAME=${3:?username is required!}
    local result=$(run "gh api -X PUT '/orgs/${ORG}/teams/${TEAM}/memberships/${USERNAME}' $(_gtb_mute_stderr)" \
        | jq -r 'if .role then "OK" else "ER" end')
    if [[ -z "$result" ]]
    then
        result='ER'
    fi
    echo "$result $*"
}

gh_find_org() {
    local ORG=${1:?org is required!}

    if run "gh api /orgs/$ORG $(_gtb_mute_stderr)" | jsonpp | grep --silent "\"login\": \"$ORG\""
    then
        echo "✅" $ORG
    else
        echo "❌" $ORG
    fi
}

gh_membership() {
    local ORG=${1:?org is required!}
    local USERNAME=${2:?username is required!}
    run "gh api '/orgs/${ORG}/memberships/${USERNAME}' $(_gtb_mute_stderr)" \
        | jq -jr --arg ORG $ORG --arg USERNAME $USERNAME \
        'if .role then
            .user.login, " ", .organization.login, " ", .role, " ", .state, "\n"
        else
            $USERNAME, " ", $ORG, " ", "not_a_member", " ", "404", "\n"
        end'
}

gh_set_org_membership() {
    local ORG=${1:?org is required!}
    local USERNAME=${2:?username is required!}
    local ROLE=${3:?role is required!(admin|member)}

    run "gh api -X PUT '/orgs/${ORG}/memberships/${USERNAME}' -F role='$ROLE' $(_gtb_mute_stderr)" \
        | jq -jr '.role // "not_found", " ", .state // "404", "\n"' \
        | sed "s/^/$USERNAME $ORG /"
}

gh_create_invitation() {
    local ORG=${1:?Org is required!}
    local INVITEE_ID=${2:?Invitee ID is required!}
    local ROLE=${3:-direct_member}
    run "gh api /orgs/${ORG}/invitations -F role=$ROLE -F invitee_id=$INVITEE_ID $(_gtb_mute_stderr)"
}

gh_list_org_teams() {
    local ORG=${1:-$GTB_ORG}
    local ENDPOINT="/orgs/$ORG/teams"

    gh api $ENDPOINT 2>/dev/null | jsonpp | \
        grep '    "name":' | \
        tr -d '" ,' | \
        cut -d':' -f2 | \
        sort
}

gh_list_org_team_members() {
    local ORG=${1:?Organization is required!}
    local TEAM=${2:?Team is required!}
    local ENDPOINT="/orgs/${ORG}/teams/${TEAM}/members?per_page=100"

    run "gh api $ENDPOINT 2>/dev/null" | jsonpp | \
        grep '    "login":' | \
        tr -d '" ,' | \
        cut -d':' -f2 | \
        sort
}

gh_list_org_members() {
    local ORG=${1:?Organization is required!}
    local ENDPOINT="/orgs/${ORG}/members?per_page=$GTB_PER_PAGE&page="

    for page in $(seq 1 10)
    do
        local res=$(run "gh api '${ENDPOINT}${page}' 2>/dev/null" | jsonpp | grep '    "login":')
        local lines_count=$(_gtb_count_lines "$res")
        if [[ $lines_count -gt 0 ]]
        then
            echo "$res"
        fi
        if [[ $lines_count -lt $GTB_PER_PAGE ]]
        then
            break
        fi
    done \
        | tr -d '" ,' \
        | cut -d':' -f2 \
        | sort
}

gh_list_org_repos() {
    local ORG=${1:-$GTB_ORG}
    local TEAM=${2}

    local ENDPOINT="/orgs/$ORG/repos?per_page=100&page="
    if [[ -n "$TEAM" ]]
    then
        ENDPOINT="/orgs/$ORG/teams/$TEAM/repos?per_page=100&page="
    fi

    for page in $(seq 1 10)
    do
        local res=$(run "gh api '${ENDPOINT}${page}' 2>/dev/null" \
            | jq -jr '.[] | .owner.login, " ", .name, " ", .private, " ", .created_at, "\n"')

        local lines_count=$(_gtb_count_lines "$res")
        if [[ $lines_count -gt 0 ]]
        then
            echo "$res"
        fi

        if [[ $lines_count -lt $GTB_PER_PAGE ]]
        then
            break
        fi
    done \
        | sed 's/ true / private /;s/ false / public /'
}

gh_show_org_repo_commit() {
    local ORG=${1:?Org is required!}
    local REPO_NAME=${2:?Repo name is required!}
    local COMMIT_REF=${3:?Commit ref is required!}

    local ENDPOINT="/repos/$ORG/$REPO_NAME/commits/$COMMIT_REF"
    local OUTPUT="$ORG $REPO_NAME"

    run "gh api $ENDPOINT 1>/dev/null $(_gtb_mute_stderr)"

    local result=$?
    if [[ $result -eq 0 ]]; then
        echo "✅" $ORG
    else
        echo "❌" $ORG
    fi

    return $result
}

gh_show_org_repo() {
    local ORG=${1:?Org is required!}
    local REPO_NAME=${2:?Repo name is required!}

    local ENDPOINT="/repos/$ORG/$REPO_NAME"
    local OUTPUT="$ORG $REPO_NAME"

    run "gh api $ENDPOINT 1>/dev/null"

    local result=$?
    if [[ $result -eq 0 ]]; then
        echo "✅" $ORG
    else
        echo "❌" $ORG
    fi

    return $result
}

gh_secret_list() {
    local ORG=${1:?Org is required!}
    local REPO_NAME=${2:?Repo name is required!}

    run "gh secret list -R $ORG/$REPO_NAME"
}

gh_list_repo_workflow_runs() {
    local ORG=${1:?Org is required!}
    local REPO_NAME=${2:?Repo name is required!}
    local WORKFLOW_FILENAME=${3:?Workflow filename is required!}

    run "gh api /repos/$ORG/$REPO_NAME/actions/workflows/$WORKFLOW_FILENAME/runs?per_page=10" \
        | jq -jr --arg ORG $ORG '.workflow_runs[] | $ORG, "|", .run_number, "|", .name, "|", .status, "|", .conclusion, "|", .created_at, "|", .updated_at, "\n"'
}

gh_run_repo_workflow() {
    local ORG=${1:?Org is required!}
    local REPO_NAME=${2:?Repo name is required!}
    local WORKFLOW_FILENAME=${3:?Workflow filename is required!}

    local ENDPOINT="/repos/$ORG/$REPO_NAME/actions/workflows/$WORKFLOW_FILENAME/dispatches"
    local ACTIONS_URL="$(_gtb_actions_url $ORG $REPO_NAME)"

    local result=$(run "gh api -X POST $ENDPOINT -F ref=master 2>&1 1>/dev/null")

    if [[ -z "$result" ]]
    then
        echo "$SYMBOL_OK $ORG $ACTIONS_URL"
    else
        echo "$SYMBOL_ERROR $ORG $ACTIONS_URL"
    fi
}

gh_workflow_list() {
    local ORG=${1:?Org is required!}
    local REPO_NAME=${2:?Repo name is required!}

    run "gh api /repos/$ORG/$REPO_NAME/actions/workflows" \
        | jq -r '.workflows[] | select(.state=="active") | .path' \
        | sed 's#.*/##' \
        | sort \
        | paste -s -d' ' - \
        | awk '{print NF, $0}' \
        | sed "s/^/$REPO_NAME $ORG /"
}

gh_remove_repo_secret() {
    local ORG=${1:?Org is required!}
    local REPO_NAME=${2:?Repo name is required!}
    local NAME=${3:?Secret name is required!}

    local response=$(gh secret -R $ORG/$REPO_NAME remove $NAME 2>&1)

    if echo $response | grep --silent "Removed secret ${NAME} from"; then
        echo "✓ Removed secret $NAME from $ORG/$REPO_NAME"
        return 0
    fi

    if echo $response | grep --silent "failed to delete secret ${NAME}: HTTP 404"; then
        echo "✓ Removed secret $NAME from $ORG/$REPO_NAME"
        return 0
    fi

    error $response
    return 1
}

gh_set_repo_secret() {
    local ORG=${1:?Org is required!}
    local REPO_NAME=${2:?Repo name is required!}
    local NAME=${3:?Secret name is required!}
    local VALUE=${4:?Secret value is required!}

    echo $ORG $REPO_NAME $NAME $VALUE \
        | env_parallel --jobs 1 --retries 3 --colsep ' ' "run \"gh secret -R {1}/{2} set {3} -b{4}\" >&2"
}

gh_init_repo_secrets() {
    local ORG=${1:?Org is required!}
    local REPO_NAME=${2:?Repo name is required!}
    local TERM_NAME=${3:?Term name is required!}
    local FULLNAME=${4:?Fullname is required!}

    declare -A secrets=(
        ['DASHBOARD_ADDRESS']="$GTB_DASHBOARD_ADDRESS"
        ['SONAR_ADDRESS']="$GTB_SONAR_ADDRESS"
        ['SONAR_TOKEN']="$GTB_SONAR_TOKEN"
        ['STUDENT_TERM']="$TERM_NAME"
        ['STUDENT_NAME']="$FULLNAME"
    )

    env_parallel \
        --linebuffer \
        --jobs $JOBS \
        --colsep ' ' \
        --link \
        --bar \
        gh_set_repo_secret $ORG $REPO_NAME "{1}" "{2}" ::: "${!secrets[@]}" ::: "${secrets[@]}"
}

gh_create_org_repo() {
    local ORG=${1:?Org is required!}
    local REPO_NAME=${2:?Repo name is required!}

    local response=$(run "gh api -X POST /orgs/$ORG/repos -F private=true -F name=$REPO_NAME" | jsonpp)

    if echo $response | grep --silent "\"full_name\": \"$ORG/$REPO_NAME\""; then
        return 0
    fi

    if echo $response | grep --silent '"message": "name already exists on this account"'; then
        return 0
    fi

    error $response
    return 1
}

gh_list_org_invitations() {
    local ORG=${1:?Org is required!}

    run "gh api /orgs/$ORG/invitations $(_gtb_mute_stderr)" \
        | jq -jr 'if type == "array" then .[] | .login, " __ORG__  ", .id, " ", .role, " ", .created_at, "\n" else "\n" end' \
        | grep -v '^$' \
        | sed "s/__ORG__/$ORG/"
}

gh_cancel_org_invitations() {
    local ORG=${1:?Org is required!}

    while read -r LOGIN ORG ID REST
    do
        run "gh api -X DELETE /orgs/$ORG/invitations/$ID 2>/dev/null"
        [[ $? -eq 0 ]] && status='✅' || status="❌"
        echo $status $ORG $ID $LOGIN
    done < <(gh_list_org_invitations $ORG)
}

gh_delete_repo() {
    local ORG=${1:?ORG is required!}
    local REPO_NAME=${2:?Repo name is required!}

    local response=$(run "gh api -X DELETE /repos/$ORG/$REPO_NAME 2>/dev/null")

    if [[ "$response" == "" ]]; then
        echo $ORG $REPO_NAME
        return 0
    fi

    if echo $response | grep --silent '"message":"Not Found"'; then
        echo $ORG $REPO_NAME
        return 0
    fi

    error $response
    return 1
}

gh_clone_repo() {
    local ORG=${1:?ORG is required!}
    local REPO_NAME=${2:?Repo name is required!}
    local DIR=${3:?Director is required!}

    run "git clone git@github.com:$ORG/$REPO_NAME $DIR"
}

_gtb_trello_find_board_id() {
    local BOARD_NAME=${1:?Board name is required!}

    run "http GET '$GTB_TRELLO_API/members/${GTB_TRELLO_USERNAME}/boards?${GTB_TRELLO_AUTH}'" \
        | jq -r ".[] | select(.name == \"$BOARD_NAME\") | .id"
}

_gtb_trello_find_list_id() {
    local BOARD_NAME=${1:?Board name is required!}
    local LIST_NAME=${2:?List name is required!}

    local BOARD_ID=$(_gtb_trello_find_board_id "$BOARD_NAME")
    assert_not_empty "Cannot find board with name '$GTB_TRELLO_BOARD_NAME'!" "$BOARD_ID"

    run "http GET '$GTB_TRELLO_API/boards/${BOARD_ID}/lists?$GTB_TRELLO_AUTH'" \
        | jq -r ".[] | select(.name == \"$LIST_NAME\") | .id"
}

_gtb_trello_remove_member_from_board() {
    GTB_TRELLO_BOARD_NAME="${GTB_TRELLO_BOARD_NAME:?Trello board name is required! Specify by --board <NAME>.}"

    local ORG=${1:?Student org is required!}
    local TRELLO_EMAIL=${2:?Trell member email is required!}

    local BOARD_ID=$(_gtb_trello_find_board_id "$GTB_TRELLO_BOARD_NAME")
    assert_not_empty "Cannot find board with name '$GTB_TRELLO_BOARD_NAME'!" "$BOARD_ID"

    local trello_username=$(run "http --print b GET '$GTB_TRELLO_API/search/members?${GTB_TRELLO_AUTH}&idBoard=${BOARD_ID}&query=${TRELLO_EMAIL}' | jq -r '.[0].username'")
    local trello_id_member=$(run "http --print b GET '$GTB_TRELLO_API/boards/${BOARD_ID}/members?${GTB_TRELLO_AUTH}' | jq -r '.[] | select(.username == \"$trello_username\") | .id'")
    local board_json=$(run "http --print b DELETE '$GTB_TRELLO_API/boards/${BOARD_ID}/members/${trello_id_member}?$GTB_TRELLO_AUTH'")

    if echo $board_json | grep --silent "$trello_username"; then
        echo "❌ $ORG $trello_username $TRELLO_EMAIL"
        return 1
    fi

    echo "✅ $ORG $trello_username $TRELLO_EMAIL"
    return 0
}

_gtb_trello_invite_member_to_board() {
    GTB_TRELLO_BOARD_NAME="${GTB_TRELLO_BOARD_NAME:?Trello board name is required! Specify by --board <NAME>.}"
    GTB_TRELLO_MEMBER_TYPE="${GTB_TRELLO_MEMBER_TYPE:?Trello member type is required! Specify by --type <admin|normal|observer>.}"

    local ORG=${1:?Student org is required!}
    local TRELLO_EMAIL=${2:?Trell member email is required!}

    local BOARD_ID=$(_gtb_trello_find_board_id "$GTB_TRELLO_BOARD_NAME")
    assert_not_empty "Cannot find board with name '$GTB_TRELLO_BOARD_NAME'!" "$BOARD_ID"

    local response=$(run "http PUT '$GTB_TRELLO_API/boards/${BOARD_ID}/members?email=${TRELLO_EMAIL}&type=${GTB_TRELLO_MEMBER_TYPE}&$GTB_TRELLO_AUTH'" 2>&1)

    if echo $response | grep --silent '^{"id":'; then
        echo "OK $ORG $TRELLO_EMAIL"
        return 0
    fi

    echo "ER $ORG $TRELLO_EMAIL"
    error $response
    return 1
}

build_repo() {
    local repo_name=$1
    local fullname=$2
    local term_name=$3
    local HOMEWORK_ROOT="$GTB_ROOT/$GTB_TERMS_DIR/$term_name/$repo_name"
    local STUDENT_HOMEWORK_PATH="$HOMEWORK_ROOT/$fullname"

    if [[ ! -d $STUDENT_HOMEWORK_PATH ]]
    then
        error "Skip building repo \`$STUDENT_HOMEWORK_PATH\` due to folder is not exist!"
        return
    fi

    run "cd $STUDENT_HOMEWORK_PATH"

    if [[ -f "package.json" ]]; then
        run "yarn"
    elif [[ -f "build.gradle" ]]; then
        run "./gradlew build </dev/null"
    else
        error "Failed to build project due to unknown build tool!"
    fi
}

clone_repo() {
    local repo_name=$1
    local username=$2
    local fullname=$3
    local term_name=$4
    local HOMEWORK_ROOT="$GTB_ROOT/$GTB_TERMS_DIR/$term_name/$repo_name"
    local STUDENT_HOMEWORK_PATH="$HOMEWORK_ROOT/$fullname"
    local STUDENT_HOMEWORK_URL="git@github.com:${username}/${repo_name}.git"

    [[ -d $HOMEWORK_ROOT ]] || run "mkdir -p $HOMEWORK_ROOT"

    run "git clone $STUDENT_HOMEWORK_URL $STUDENT_HOMEWORK_PATH"

    if (($?))
    then
        error "Failed to clone repo ${repo_name}.git for student $fullname!"
    fi
}

update_repo() {
    local student_homework_path=$1

    run "cd $student_homework_path"
    run "git checkout master"
    run "git pull --rebase"

    if (($?))
    then
        error "Failed to update repo ${student_homework_path}!"
    fi
}

clone_or_update_repo() {
    local repo_name=$1
    local fullname=$3
    local term_name=$4
    local HOMEWORK_ROOT="$GTB_ROOT/$GTB_TERMS_DIR/$term_name/$repo_name"
    local STUDENT_HOMEWORK_PATH="$HOMEWORK_ROOT/$fullname"

    if [[ -d $STUDENT_HOMEWORK_PATH ]] && [[ "$AUTO_UPDATE" == "true" ]]
    then
        update_repo $STUDENT_HOMEWORK_PATH
    elif [[ -d $STUDENT_HOMEWORK_PATH ]] && [[ "$AUTO_UPDATE" != "true" ]]
    then
        info "Repo ${repo_name} for student $fullname has already been downloaded."
    else
        clone_repo $@
    fi
}

join_repos() {
    readonly INVITATIONS_FILE="/tmp/gtb_invatations_${REPO_NAME}.txt"

    gh api '/user/repository_invitations?per_page=100' | jsonpp | \
        grep --color=never '^    "id":\|^      "name":\|^        "login":' | \
        paste -d' ' - - - | \
        tr -d ', :' | tr -s '"' | tr '"' ' ' | \
        grep --color=never "${REPO_NAME}" > $INVITATIONS_FILE

    readonly login_list_size=$(cat $INVITATIONS_FILE | wc -l | tr -d ' ')

    if [[ 0 -eq $login_list_size ]]
    then
        info "Found $login_list_size invitations for repo ${REPO_NAME}."
        return
    fi

    info "Found $login_list_size invitations for repo ${REPO_NAME} from following users:"
    cat $INVITATIONS_FILE | cut -d' ' -f7 | \
        xargs -I % grep '\<%\>' $GTB_STUDENTS_FILE | \
        cut -d' ' -f1-2 | sort | cat -n

    if [[ "$AUTO_ACCEPT" == "false" ]]
    then
        return
    fi

    while read -r cid id cname name clogin login
    do
        info "about to accept invitation from user ${login}..."
        run "gh api -X PATCH --silent /user/repository_invitations/${id}"

        [[ $? -eq 0 ]] && info "DONE" || error "FAILED"
    done < $INVITATIONS_FILE
}

build_repos() {
    if [[ "$AUTO_BUILD" != "true" ]]
    then
        return
    fi

    while read -r FULLNAME USERNAME TERM_NAME TAGS
    do
        if echo "$TERM_NAME" | grep --silent "$GTB_TERM"
        then
            if [[ -z "$*" ]] || echo "$@" | grep --silent "\<${FULLNAME}\>" || echo "$TAGS" | grep --silent "\<$1\>"
            then
                build_repo $REPO_NAME $FULLNAME $TERM_NAME
            fi
        fi
    done < $GTB_STUDENTS_FILE
}

clone_or_update_repos() {
    while read -r FULLNAME USERNAME TERM_NAME TAGS
    do
        if echo "$TERM_NAME" | grep --silent "$GTB_TERM"
        then
            if [[ -z "$*" ]] || echo "$@" | grep --silent "\<${FULLNAME}\>" || echo "$TAGS" | grep --silent "\<$1\>"
            then
                clone_or_update_repo $REPO_NAME $USERNAME $FULLNAME $TERM_NAME
            fi
        fi
    done < $GTB_STUDENTS_FILE
}

assert_not_empty() {
    if [[ -z "$2" ]]
    then
        fail "$1"
    fi
}

assert_trainers_file_exists() {
    if [[ ! -f $GTB_TRAINERS_FILE ]]
    then
        error "Cannot find trainers file: '$GTB_TRAINERS_FILE'."
        error "If you upgrade from the old versions, please run \`gtb init\` to clone config repo."
        exit 1
    fi
}

assert_students_file_exists() {
    if [[ ! -f $GTB_STUDENTS_FILE ]]
    then
        error "Cannot find students file: '$GTB_STUDENTS_FILE'."
        error "If you upgrade from the old versions, please run \`gtb init\` to clone config repo."
        exit 1
    fi
}

extract_comment_context() {
    while read -r line
    do
        echo "$line" | \
            sed 's:^.*TODO ::' | \
            sed 's: \{0,\}-->$::' | \
            sed 's: \{0,\}\*/}$::' | \
            sed 's: \{0,\}\*/$::' | \
            cut -d' ' -f2-
    done
}

extract_summary_comments_for_dimension() {
    local DIMENSION=${1:?dimension code is required!}
    grep "TODO GTB-\(${DIMENSION}\): \*" -R ${GTB_EXCLUDE_DIRS[@]} * | \
        extract_comment_context
}

extract_detail_comments_for_dimension() {
    local DIMENSION=${1:?dimension code is required!}
    local SYMBOL=${2:?symbol is required!}

    grep "TODO GTB-\(${DIMENSION}\): ${SYMBOL}" -R ${GTB_EXCLUDE_DIRS[@]} * | \
        extract_comment_context | \
        sed "s:^:${SYMBOL} \\\\:"
}

prepare_run_context() {
    local HOMEWORK_ROOT=${1:?homework root is required!}
    local HOMEWORK_TESTS_ROOT=${2:?homework tests root is required!}
    local REPO_NAME=${3:?repository name is required!}

    info "Start preparing run context..."
    cd "$HOMEWORK_ROOT"
    cp ${HOMEWORK_TESTS_ROOT}/docker/* .
    cp settings.gradle settings.gradle.backup
    echo "rootProject.name = '${REPO_NAME}'" > settings.gradle
}

clear_run_context() {
    local HOMEWORK_ROOT=${1:?homework root is required!}

    info "Start clearing run context..."
    cd "$HOMEWORK_ROOT"
    for f in `echo ${HOMEWORK_TESTS_ROOT}/docker/*`; do
        rm `basename $f`
    done
    mv settings.gradle.backup settings.gradle
}

ensure_application_is_ready() {
    local TIMEOUT=${1:?timeout is required!}

    timeout ${TIMEOUT}s bash << "EOF"
while :; do
    sleep 1; curl http://localhost:8080 > /dev/null 2>&1
    [[ "$?" -eq 0 ]] && break
done
EOF

    return $?
}

strip_blank_details_block() {
    cat $1 | \
        tr '\n' '\t' | \
        sed 's/__Details:__		/__Details:__	/g' | \
        sed 's/__Details:__			//g' | \
        sed 's/	\{3,\}/		/g' | \
        tr '\t' '\n'
}

extract_and_format_comments() {
    cat <<-EOF
### 完成度：
$(extract_summary_comments_for_dimension '1\|完成度')
$([ -f ./gtb-test-results.md ] && echo '* 具体验收测试结果详见：`gtb-test-results.md`')

__Details:__
$(extract_detail_comments_for_dimension '1\|完成度' '+')
$(extract_detail_comments_for_dimension '1\|完成度' '-')

### 测试：
$(extract_summary_comments_for_dimension '2\|测试')

__Details:__
$(extract_detail_comments_for_dimension '2\|测试' '+')
$(extract_detail_comments_for_dimension '2\|测试' '-')

### 知识点：
$(extract_summary_comments_for_dimension '3\|知识点')

__Details:__
$(extract_detail_comments_for_dimension '3\|知识点' '+')
$(extract_detail_comments_for_dimension '3\|知识点' '-')

### 工程实践：
$(extract_summary_comments_for_dimension '4\|工程实践')

__Details:__
$(extract_detail_comments_for_dimension '4\|工程实践' '+')
$(extract_detail_comments_for_dimension '4\|工程实践' '-')

### 综合：
$(extract_summary_comments_for_dimension '0\|综合')

__Details:__
$(extract_detail_comments_for_dimension '0\|综合' '+')
$(extract_detail_comments_for_dimension '0\|综合' '-')

EOF
}

_gtb_is_a_trainer() {
    if [[ -z "$*" ]]; then
        return 1
    fi

    while read -r FULLNAME USERNAME ID TAGS
    do
        if echo "$*" | grep --silent "\<${FULLNAME}\>" || echo "$*" | grep --silent "\<${USERNAME}\>" || echo "$TAGS" | grep --silent "\<$1\>"
        then
            return 0
        fi
    done < $GTB_TRAINERS_FILE

    return 2
}

_gtb_trainer_id() {
    while read -r FULLNAME USERNAME ID TAGS
    do
        if [[ -z "$*" ]] || echo "$*" | grep --silent "\<${FULLNAME}\>" || echo "$*" | grep --silent "\<${USERNAME}\>" || echo "$TAGS" | grep --silent "\<$1\>"
        then
            echo "$ID"
        fi
    done < $GTB_TRAINERS_FILE
}

_gtb_trainer_username() {
    while read -r FULLNAME USERNAME ID TAGS
    do
        if [[ -z "$*" ]] || echo "$*" | grep --silent "\<${FULLNAME}\>" || echo "$*" | grep --silent "\<${USERNAME}\>" || echo "$TAGS" | grep --silent "\<$1\>"
        then
            echo "$USERNAME"
        fi
    done < $GTB_TRAINERS_FILE
}

_gtb_trainer_fullname() {
    while read -r FULLNAME USERNAME ID TAGS
    do
        if [[ -z "$*" ]] || echo "$*" | grep --silent "\<${FULLNAME}\>" || echo "$*" | grep --silent "\<${USERNAME}\>" || echo "$TAGS" | grep --silent "\<$1\>"
        then
            echo "$FULLNAME"
        fi
    done < $GTB_TRAINERS_FILE
}

_gtb_trainer_list() {
    while read -r FULLNAME USERNAME ID TAGS
    do
        if [[ -z "$*" ]] || echo "$*" | grep --silent "\<${FULLNAME}\>" || echo "$*" | grep --silent "\<${USERNAME}\>" || echo "$TAGS" | grep --silent "\<$1\>"
        then
            echo "$FULLNAME $USERNAME $ID $TAGS"
        fi
    done < $GTB_TRAINERS_FILE
}

_gtb_trainer() {
    assert_trainers_file_exists

    if ! echo $1 | grep --silent '^\(list\|fullname\|username\|id\)$'; then
        set -- list "$@"
    fi

    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_git_list_all_branches_of_remote() {
    local REMOTE_NAME=${1:?Remote name is required!}
    local BRANCH_NAMES=$(run "git branch -r --no-color --list '${REMOTE_NAME}/*' $(_gtb_mute_stderr) | grep -wv 'HEAD' | tr -d '\t ' | cut -d'/' -f2")
    # ensure master/main branch is the first branch in list
    echo "$BRANCH_NAMES" | grep --color=never -wE 'master|main' | sort -r
    echo "$BRANCH_NAMES" | grep --color=never -vwE 'master|main' | sort
}

_gtb_git_verify_refs() {
    local REPO_NAME=${1:?Repo name is required!}
    local GTB_REFS=${2:-}

    if [[ -z "$GTB_REFS" ]]; then
        return
    fi

    _gtb_clone_default_repo $REPO_NAME

    run "cd $(_gtb_default_repo_dir $REPO_NAME)"

    local REFS=$(echo "$GTB_REFS" | tr ',' ' ' | tr -s ' ')
    local commits_to_pick=''

    for ref in $REFS; do
        if _gtb_is_valid_git_ref $ref; then
            commits_to_pick="$commits_to_pick $ref"
        fi
    done

    if [[ -z "$commits_to_pick" ]]; then
        return
    fi

    echo "$commits_to_pick" | sed -E 's/^ +//g'
}

_gtb_is_valid_git_ref() {
    local REF=${1:?Ref is required!}

    run "git cat-file -t $REF 1>/dev/null 2>&1"
}

_gtb_quiz_tag() {
    local WEEK=${1:?Week is required!(e.g. '1', '2', '10', etc.)}
    local DEFAULT_SESSION=${2:?Default session is required!(e.g. '509', '609')}
    local APPOINTMENTS_FILE=${3:?Evaluation appointments file is required!}

    if [[ ! -s $APPOINTMENTS_FILE ]]
    then
        echo "File $APPOINTMENTS_FILE not found or empty!"
        return 1
    fi

    local WEEK_NUM=$(echo "$WEEK" | tr -d ' ' | grep -o -E --color=never '[0-9]{1,}')
    local DEFAULT_TAG="w${WEEK_NUM}d${DEFAULT_SESSION}"

    gtb tag add "$DEFAULT_TAG"

    local TAG_INDEX=$(gtb tag index | tail -n1 | tr -d ' ' | cut -f1)

    cat "$APPOINTMENTS_FILE" \
        | grep "Week $WEEK_NUM" \
        | cut -d, -f2,4 \
        | grep -E "[1-7][0-9]{2}" \
        | parallel --jobs 1 --linebuffer --colsep ',' --verbose "gtb tag replace "$DEFAULT_TAG" "w${WEEK_NUM}d{2}" {1} 1>/dev/null"

    gtb tag stat "$TAG_INDEX"
}

_gtb_quiz_send() {
    local SCHEDULES_FILE=${1:?Schedules filename is required!}
    [[ -f "$SCHEDULES_FILE" ]] || fail "error: cannot find schedules file '$SCHEDULES_FILE'!"

    local UNORDERED_PLANS=$(while read -r tag repo start_time basic_duration refactor_duration publish_offset marks
    do
        create_submission_time=$(gtb date now)
        publish_time=$(gtb date $start_time $(echo $publish_offset | tr ',' ' '))
        start_time=$(gtb date $start_time)
        pick_time=$(gtb date $start_time +$basic_duration)
        end_time=$(gtb date $start_time +$refactor_duration)

        if ! echo "$marks" | grep --silent 'sub_created'; then
            echo "$create_submission_time $tag $repo gtb dash sub create --repo $repo --start $start_time --basic $basic_duration --refactor $refactor_duration --yes --notify $tag"
        fi
        if ! echo "$marks" | grep --silent 'repo_published'; then
            echo "$publish_time $tag $repo gtb repo publish $repo --yes --notify $tag"
        fi
        if ! echo "$marks" | grep --silent 'repo_picked'; then
            echo "$pick_time $tag $repo gtb repo pick --repo $repo --refs extended-tests --workflow gtb-test-extended.yml --yes --notify $tag"
        fi
    done < <(cat $SCHEDULES_FILE | tr -s ' ') | sort)

    declare -a PLANS

    while IFS= read -r -d$'\n' LINE
    do
        PLANS+=( "$LINE" )
    done < <(echo "$UNORDERED_PLANS")

    printf "%s\n" "${PLANS[@]}" | nl
    echo

    GTB_YES='true'

    for PLAN in "${PLANS[@]}"; do
        local run_at=$(echo "$PLAN" | _gtb_cuts 1)
        local tag=$(echo "$PLAN" | _gtb_cuts 2)
        local repo=$(echo "$PLAN" | _gtb_cuts 3)
        local command=$(echo "$PLAN" | _gtb_cuts 4-)

        header "$command"

        GTB_SCHEDULE="$run_at"
        _gtb_auto_schedule

        $command

        if [[ $? -eq 0 ]]; then
            if echo "$command" | grep --silent 'gtb dash sub create'; then
                MARK='sub_created'
            elif echo "$command" | grep --silent 'gtb repo publish'; then
                MARK='repo_published'
            elif echo "$command" | grep --silent 'gtb repo pick'; then
                MARK='repo_picked'
            fi

            sed -i '' -E "/$tag $repo/s/$/ $MARK/" "$SCHEDULES_FILE"
        fi
    done
}

_gtb_quiz() {
    assert_students_file_exists

    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_evaluation() {
    _gtb_quiz "$@"
}

_gtb_eval() {
    _gtb_quiz "$@"
}

_gtb_student_random_clear() {
    _gtb_student_random_reset
}

_gtb_student_random_reset() {
    echo -n > $GTB_RANDOM_LIST_FILE
}

_gtb_student_random_show() {
    cat $GTB_RANDOM_LIST_FILE
}

_gtb_student_random_next() {
    if [[ ! -s $GTB_RANDOM_LIST_FILE ]]
    then
        fail 'error: Please run `gtb student random` to generate random list first.'
    fi

    local next=$(head -n1 $GTB_RANDOM_LIST_FILE)
    local rest=$(tail -n +2 $GTB_RANDOM_LIST_FILE)

    echo "$rest" > $GTB_RANDOM_LIST_FILE
    echo "$next" >> $GTB_RANDOM_LIST_FILE

    echo $next
}

_gtb_student_random_generate() {
    _gtb_filter_students "$@" | \
        shuf | \
        cut -d' ' -f2 | \
        cat -n > $GTB_RANDOM_LIST_FILE
}

_gtb_student_random() {
    if ! echo $1 | grep --silent '^\(next\|show\|reset\|generate\|clear\)$'; then
        set -- generate "$@"
    fi

    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_student_org_invite_cancel() {
    local student_lines=$(_gtb_filter_students "$@")
    local students_count=$(_gtb_count_lines "$student_lines")

    echo "$student_lines" | while read -r FULLNAME ORG TERM_NAME USERNAME TAGS
    do
        echo $(gh_cancel_org_invitations $ORG | tr '\n' '|')
    done | _gtb_pv $students_count \
        | _gtb_tee1 \
        | sed 's/|$//' \
        | tr '|' '\n' \
        | tr ' ' '|' \
        | sort \
        | _gtb_tabularize 'List of All Pending Student Org Invitations'
}

_gtb_student_org_invite_create() {
    assert_trainers_file_exists

    local TRAINER_FULLNAME=${1:?Trainer fullname is required! (e.g. qu.hang wang.xiaofeng)}
    shift 1

    local TRAINER_USERNAME=$(_gtb_trainer_username $TRAINER_FULLNAME)
    assert_not_empty "Cannot find '$TRAINER_FULLNAME' in ${GTB_TRAINERS_FILE}!" "$TRAINER_USERNAME"

    local student_lines=$(_gtb_filter_students "$@")
    local students_count=$(_gtb_count_lines "$student_lines")
    assert_not_empty "error: cannot find any students with filters: '$@'!" "$student_lines"

    echo "$student_lines" \
        | env_parallel \
            --linebuffer \
            --jobs $JOBS \
            --colsep ' ' \
            --bar \
            gh_invite_user_to_org "{2}" "$TRAINER_USERNAME" 'admin' "{7}" \
        | _gtb_sort '1,1r;2,2' \
        | _gtb_table_format \
        | _gtb_tr_symbols
}

_gtb_student_org_invite_list() {
    local student_lines=$(_gtb_filter_students "$@")
    local students_count=$(_gtb_count_lines "$student_lines")
    assert_not_empty "error: cannot find any students with filters: '$@'!" "$student_lines"

    local result=$(echo "$student_lines" \
        | _gtb_cuts 2 \
        | env_parallel \
            --linebuffer \
            --jobs $JOBS \
            --colsep ' ' \
            --bar \
            gh_list_org_invitations "{}")
    local trainers=$(echo "$result" | _gtb_cuts 1 | sort -ur)

    for trainer in $trainers
    do
        echo "$result" \
            | grep -w -E --color=never "$trainer" \
            | _gtb_sort '1,1;2,2' \
            | _gtb_nl
    done | _gtb_table_format
}

_gtb_student_org_invite() {
    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_student_org_membership_role() {
    assert_trainers_file_exists

    local ROLE=${1:?Role is required!(admin|member)}
    shift 1
    local TRAINER_FULLNAME=${1:?Trainer fullname is required! (e.g. qu.hang wang.xiaofeng)}
    shift 1

    local TRAINER_USERNAME=$(_gtb_trainer_username $TRAINER_FULLNAME)
    assert_not_empty "Cannot find '$TRAINER_FULLNAME' in ${GTB_TRAINERS_FILE}!" "$TRAINER_USERNAME"

    local student_lines=$(_gtb_filter_students "$@")
    local students_count=$(_gtb_count_lines "$student_lines")
    assert_not_empty "error: cannot find any students with filters: '$@'!" "$student_lines"

    echo "$student_lines" \
        | _gtb_cuts 2 \
        | env_parallel \
            --linebuffer \
            --jobs $JOBS \
            --colsep ' ' \
            --bar \
            gh_set_org_membership {} $TRAINER_USERNAME $ROLE \
        | _gtb_sort '3,3;4,4;2,2' \
        | _gtb_table_format
}

_gtb_student_org_membership() {
    if ! echo $1 | grep --silent '^\(role\)$'; then
        set -- role "$@"
    fi

    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_student_org_join() {
    local TRAINER_FULLNAME=${1:?Trainer fullname is required! (e.g. zhang.zhe, wang.ke)}
    shift

    local trainer_username=$(_gtb_trainer_username $TRAINER_FULLNAME)
    assert_not_empty "Cannot find '$TRAINER_FULLNAME' in ${GTB_TRAINERS_FILE}!" "$trainer_username"

    local student_lines=$(_gtb_filter_students "$@")
    local students_count=$(_gtb_count_lines "$student_lines")
    assert_not_empty "error: cannot find any students with filters: '$@'!" "$student_lines"

    local orgs_to_join=$(echo "$student_lines" \
        | _gtb_cuts 2 \
        | env_parallel --jobs $JOBS --bar --linebuffer gh_membership "{}" "$trainer_username" \
        | grep --color=never 'admin pending')
    assert_not_empty "no pending admin invitations to join!" "$orgs_to_join"

    echo "$orgs_to_join" | _gtb_sort 1 | _gtb_table_format

    if [[ "false" == "$GTB_YES" ]]
    then
        read -p "about to JOIN above student orgs? (y|n) " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]
        then
            return 1
        fi
    fi

    for ORG in $(echo "$orgs_to_join" | _gtb_cuts 2)
    do
        run "open -g https://github.com/orgs/${ORG}/invitation"
        sleep .5
    done
}

_gtb_check_student_org_for_presence() {
    if _gtb_is_a_trainer $1; then
        shift
    fi

    header "Checking presence of student org..."

    _gtb_filter_students "$@" | cut -d' ' -f2 \
        | env_parallel --jobs $JOBS --bar --linebuffer gh_find_org {1} \
        | sort -k1,2 \
        | tr ' ' '|' \
        | _gtb_tabularize \
        | cat -n
}

_gtb_check_student_org_for_trainer_role() {
    assert_trainers_file_exists

    header "Checking trainer's role in student org..."

    local TRAINER_FULLNAME=${1:?Trainer fullname is required! (e.g. zhang.zhe, wang.ke)}
    shift

    local trainer_username=$(_gtb_trainer_username $TRAINER_FULLNAME)
    assert_not_empty "Cannot find '$TRAINER_FULLNAME' in ${GTB_TRAINERS_FILE}!" "$trainer_username"

    _gtb_filter_students "$@" \
        | _gtb_cuts 2 \
        | env_parallel --jobs $JOBS --bar --linebuffer gh_membership "{}" "$trainer_username" \
        | sed "s/^/$TRAINER_FULLNAME /" \
        | _gtb_sort '4,4;5,5;3,3' \
        | _gtb_table_format \
        | _gtb_highlight \
            'admin' green \
            'active' green \
            'pending' blue \
            'member' yellow \
            'not_a_member' red \
            '404' red
}

_gtb_student_org_delete() {
    local student_lines=$(_gtb_filter_students "$@")
    assert_not_empty "error: cannot find any students with filters: '$@'!" "$student_lines"

    echo "$student_lines" \
        | _gtb_cuts 2 \
        | env_parallel \
            --linebuffer \
            --jobs 1 \
            --bar \
            _gtb_open "https://github.com/organizations/{}/settings/profile#rename-org-dialog"
}

_gtb_student_org_check() {
    if [[ "$CHECK_ROLE_ONLY" == "false" ]]; then
        _gtb_check_student_org_for_presence "$@"
    fi

    assert_trainers_file_exists
    if ! _gtb_is_a_trainer $1; then
        return 0
    fi

    _gtb_check_student_org_for_trainer_role "$@"
}

_gtb_student_org_open() {
    local student_lines=$(_gtb_filter_students "$@")
    assert_not_empty "error: cannot find any students with filters: '$@'!" "$student_lines"

    echo "$student_lines" \
        | _gtb_cuts 2 \
        | env_parallel \
            --linebuffer \
            --jobs 1 \
            --bar \
            _gtb_open "https://github.com/{}"
}

_gtb_student_org() {
    if ! echo $1 | grep --silent '^\(open\|check\|delete\|invite\|join\|membership\)$'; then
        set -- check "$@"
    fi

    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_student_user_check() {
    local student_lines=$(_gtb_filter_students "$@")
    assert_not_empty "error: cannot find any students with filters: '$@'!" "$student_lines"

    echo "$student_lines" \
        | env_parallel \
            --linebuffer \
            --jobs $JOBS \
            --colsep ' ' \
            --bar \
            gh_check_user "{4}" "{2}" "{7}" \
        | _gtb_sort '1,1r;3;3' \
        | _gtb_table_format \
        | _gtb_tr_symbols
}

_gtb_student_user() {
    if ! echo $1 | grep --silent '^\(check\)$'; then
        set -- check "$@"
    fi

    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_student_workflow_runs() {
    local REPO_NAME=${GTB_REPO:?repo name should be provided using --repo option.}
    local WORKFLOW_FILENAME=${WORKFLOW_FILENAME:?Workflow filename should be provided using --workflow option.}

    local student_lines=$(_gtb_filter_students "$@")
    assert_not_empty "error: cannot find any students with filters: '$@'!" "$student_lines"

    echo "$student_lines" \
        | _gtb_cuts 2 \
        | env_parallel \
            --linebuffer \
            --jobs $JOBS \
            --bar \
            gh_list_repo_workflow_runs "{}" "$REPO_NAME" "$WORKFLOW_FILENAME" \
        | _gtb_sort '1,1;2,2rn' '|' \
        | _gtb_table_format -s '|'
}

_gtb_student_workflow_run() {
    local REPO_NAME=${1:?Repo name is required!}
    local WORKFLOW_FILENAME=${2:?Workflow filename is required!}
    shift 2

    local student_lines=$(_gtb_filter_students "$@")
    assert_not_empty "error: cannot find any students with filters: '$@'!" "$student_lines"

    echo "$student_lines" \
        | _gtb_cuts 2 \
        | env_parallel \
            --linebuffer \
            --jobs $JOBS \
            --bar \
            gh_run_repo_workflow "{}" $REPO_NAME $WORKFLOW_FILENAME \
        | sort \
        | column -t \
        | nl
}

_gtb_student_workflow_list() {
    local REPO_NAME=${1:?Repo name is required!}
    shift

    local student_lines=$(_gtb_filter_students "$@")
    assert_not_empty "error: cannot find any students with filters: '$@'!" "$student_lines"

    echo "$student_lines" \
        | _gtb_cuts 2 \
        | env_parallel \
            --linebuffer \
            --jobs $JOBS \
            --bar \
            gh_workflow_list "{}" "$REPO_NAME" \
        | sort -k2 \
        | _gtb_table_format
}

_gtb_student_workflow() {
    if ! echo $1 | grep --silent '^\(list\|run\|runs\)$'; then
        set -- list "$@"
    fi

    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_student_secret_init() {
    local REPO_NAME=${1:?Repo name is required!}
    shift

    local student_lines=$(_gtb_filter_students "$@")
    assert_not_empty "error: cannot find any students with filters: '$@'!" "$student_lines"

    echo "$student_lines" | cut -d' ' -f1-3 \
        | env_parallel \
        --jobs $JOBS \
        --linebuffer \
        --colsep ' ' \
        --bar \
        "gh_init_repo_secrets {2} $REPO_NAME {3} {1} $(_gtb_mute_stderr) 1>&2"

    _gtb_student_secret_stat "$REPO_NAME" "$@"
}

_gtb_student_secret_remove() {
    local REPO_NAME=${1:?Repo name is required!}
    local NAME=${2:?Secret name is required!}
    shift 2

    local student_lines=$(_gtb_filter_students "$@")
    assert_not_empty "error: cannot find any students with filters: '$@'!" "$student_lines"

    echo "$student_lines" | cut -d' ' -f1-3 \
        | env_parallel \
        --jobs $JOBS \
        --linebuffer \
        --colsep ' ' \
        --bar \
        "gh_remove_repo_secret {2} $REPO_NAME $NAME $(_gtb_mute_stderr) 1>&2"
}

_gtb_student_secret_set() {
    local REPO_NAME=${1:?Repo name is required!}
    local NAME=${2:?Secret name is required!}
    local VALUE=${3:?Secret value is required!}
    shift 3

    local student_lines=$(_gtb_filter_students "$@")
    assert_not_empty "error: cannot find any students with filters: '$@'!" "$student_lines"

    echo "$student_lines" | cut -d' ' -f1-3 \
        | env_parallel \
        --jobs $JOBS \
        --linebuffer \
        --colsep ' ' \
        --bar \
        "gh_set_repo_secret {2} $REPO_NAME $NAME $VALUE $(_gtb_mute_stderr) 1>&2"
}

_gtb_student_secret_check() {
    local REPO_NAME=${1:?Repo name is required!}
    shift

    local MAX_JOBS=$JOBS
    if [[ $MAX_JOBS -gt 20 ]]
    then
        MAX_JOBS=20
    fi

    local student_lines=$(_gtb_filter_students "$@")

    join -1 1 -2 2 -a 1 -o '2.1,1.1' -e '0' \
        <(echo "$student_lines" | cut -d' ' -f2 | sort) \
        <(echo "$student_lines" | cut -d' ' -f2 \
            | env_parallel --jobs $MAX_JOBS --colsep ' ' --tagstring {1} --bar --linebuffer gh_secret_list {1} $REPO_NAME \
            | cut -f1 \
            | sort | uniq -c | tr -s ' ' \
            | sort -k2) \
        | sort -k1,2 -nr \
        | _gtb_table_format
}

_gtb_student_secret_list() {
    local REPO_NAME=${1:?Repo name is required!}
    shift

    local MAX_JOBS=$JOBS
    if [[ $MAX_JOBS -gt 20 ]]
    then
        MAX_JOBS=20
    fi

    local student_lines=$(_gtb_filter_students "$@")

    echo "$student_lines" | cut -d' ' -f2 \
        | env_parallel --jobs $MAX_JOBS --colsep ' ' --bar --linebuffer gh_secret_list {1} $REPO_NAME
}

_gtb_student_secret_stat() {
    local REPO_NAME=${1:?Repo name is required!}
    shift

    local student_lines=$(_gtb_filter_students "$@")
    assert_not_empty "error: cannot find any students with filters: '$@'!" "$student_lines"

    header 'Query secret list...'
    local all_secrets=$(echo "$student_lines" \
        | cut -d' ' -f2 \
        | env_parallel --jobs $JOBS --colsep ' ' --bar --linebuffer --tagstring '{1}' gh_secret_list {1} $REPO_NAME \
        | tr '\t' ' ' \
        | tr -s ' ')

    header 'Count by student name...'
    echo "$all_secrets" \
        | _gtb_cuts 1 \
        | sort \
        | uniq -c \
        | sort -k1,1rn -k2,2 \
        | _gtb_table_format

    header 'Count by secret name...'
    echo "$all_secrets" \
        | _gtb_cuts 2 \
        | sort \
        | uniq -c \
        | sort -k1,1rn -k2,2 \
        | _gtb_table_format
}

_gtb_student_secret() {
    if ! echo $1 | grep --silent '^\(list\|check\|set\|remove\|init\|stat\)$'; then
        set -- list "$@"
    fi

    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_student_repo_delete() {
    local REPO_NAME=${1:?Repo name is required!}
    shift

    local student_lines=$(_gtb_filter_students "$@")
    local students_count=$(_gtb_count_lines "$student_lines")
    assert_not_empty "error: cannot find any students with filters: '$@'!" "$student_lines"


    echo "$student_lines" | _gtb_table_format
    read -p "Are you SURE to delete repo '$(red $REPO_NAME)' from above $(red $students_count) students? (y|n) " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]
    then
        return 1
    fi

    echo "$student_lines" | cut -d' ' -f2 \
        | _gtb_remove_remote_student_repo $REPO_NAME \
        | env_parallel --jobs $JOBS --colsep ' ' --bar --linebuffer gh_delete_repo {1} {2} \
        | _gtb_table_format
}

_gtb_student_repo_create() {
    local REPO_NAMES=${GTB_REPO:?repo names should be provided using --repo option. (e.g. --repo 'bronze-java-level-1', --repo 'bronze-java-level-1,bronze-java-level-2'}

    local student_lines=$(_gtb_filter_students "$@")
    assert_not_empty "error: cannot find any students with filters: '$@'!" "$student_lines"

    env_parallel \
        --bar \
        --linebuffer \
        --jobs $JOBS \
        gh_create_org_repo \
        :::: <(echo "$student_lines" | _gtb_cuts 2) \
        :::: <(echo "$REPO_NAMES" | tr ',; ' '\n')
}

_format_repo_time_fields() {
    while read -r f1 f2 f3 created_at rest
    do
        echo "$f1 $f2 $f3 $(_gtb_time_format_convert_time_zone $created_at)"
    done
}

_gtb_student_repo_stat() {
    local student_lines=$(_gtb_filter_students "$@")

    assert_not_empty "error: cannot find any students with filters: '$@'!" "$student_lines"

    local result=$(echo "$student_lines" \
        | cut -d' ' -f2 \
        | env_parallel \
            --jobs $JOBS \
            --colsep ' ' \
            --bar --linebuffer \
            gh_list_org_repos {1})

    pr -m -t \
        <(echo "$result" | cut -d' ' -f1 | sort | uniq -c | sort -nr) \
        <(echo "$result" | cut -d' ' -f2 | sort | uniq -c | sort -nr) \
        | nl
}

_gtb_sort() {
    local DEFAULT_SORT_ORDER="${1:?default sort keys are required! (e.g. '9,9nr;2,2')}"
    local FIELD_SEPARATOR="${2}"

    GTB_SORT_ORDER=${GTB_SORT_ORDER:-$DEFAULT_SORT_ORDER}

    local SORT_KEYS=""
    for KEY in $(echo $GTB_SORT_ORDER | tr ';%' ' ')
    do
        SORT_KEYS="$SORT_KEYS -k${KEY}"
    done

    if [[ -z "$FIELD_SEPARATOR" ]]
    then
        cat | sort $SORT_KEYS
    else
        cat | sort -t"$FIELD_SEPARATOR" $SORT_KEYS
    fi
}

_gtb_student_repo_list() {
    local student_lines=$(_gtb_filter_students "$@")
    assert_not_empty "error: cannot find any students with filters: '$@'!" "$student_lines"

    echo "$student_lines" \
        | cut -d' ' -f2 \
        | env_parallel \
            --jobs $JOBS \
            --colsep ' ' \
            --bar --linebuffer \
            gh_list_org_repos {1} \
        | _format_repo_time_fields \
        | _gtb_sort "4,4;2,2" \
        | _gtb_table_format \
        | sed "s/ public / $(red public) /"
}

_gtb_student_repo_check() {
    local REPO_NAME=${1:?Repo name is required!}
    shift 1
    local COMMIT_REF=$(_gtb_last_commit_of_branch $REPO_NAME master)
    local student_lines=$(_gtb_filter_students "$@")

    join -1 1 -2 2 -a 1 -o '2.1,1.1' -e 'NotFound' \
        <(echo "$student_lines" | cut -d' ' -f2 | sort) \
        <(echo "$student_lines" | cut -d' ' -f2 \
            | env_parallel --jobs $JOBS --bar --linebuffer gh_show_org_repo_commit {1} $REPO_NAME $COMMIT_REF \
            | sort -k2) \
        | sort -k1,2 \
        | _gtb_table_format
}

_gtb_student_repo_show() {
    local REPO_NAME=${1:?Repo name is required!}
    shift

    local student_lines=$(_gtb_filter_students "$@")

    join -1 1 -2 2 -a 1 -a 2 -o '2.1,1.1' -e 'NotFound' \
        <(echo "$student_lines" | cut -d' ' -f2 | sort) \
        <(echo "$student_lines" | cut -d' ' -f2 \
            | env_parallel --jobs $JOBS --bar --linebuffer gh_show_org_repo {1} $REPO_NAME \
            | sort -k2) \
        | sort -k1,2 \
        | tr ' ' '|' \
        | _gtb_tabularize \
        | cat -n
}

_gtb_student_repo_open() {
    local REPO_NAME=${1:?Repo name is required!}
    shift

    if [[ $# -eq 0 ]]; then
        fail 'At least one filter is required to match student with name, term, or tags, etc. (e.g. gtb student repo open bronze-java-level-1 zhang.san)'
    fi

    _gtb_filter_students "$@" \
        | _gtb_cuts 2 \
        | env_parallel \
            --linebuffer \
            --jobs 1 \
            --bar \
            _gtb_open "https://github.com/{}/$REPO_NAME"
}

_gtb_student_repo() {
    if ! echo $1 | grep --silent '^\(show\|check\|list\|stat\|create\|delete\|open\|pick\)$'; then
        set -- list "$@"
    fi

    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_student_group() {
    local GROUPS_COUNT=${1:?error: <GROUPS_COUNT> is required!}
    shift

    _gtb_filter_students "$@" | \
        shuf | \
        cut -d' ' -f2 | \
        xargs -n$GROUPS_COUNT echo | \
        datamash transpose --no-strict -t' ' | \
        sed 's: N/A::' | \
        cat -n | \
        column -t
}

_gtb_count_lines() {
    if [[ -z "$*" ]]; then
        echo 0
        return
    fi
    echo "$*" | wc -l | tr -d ' '
}

_gtb_student_quit() {
    local student_lines=$(_gtb_filter_students "$@")
    assert_not_empty "error: cannot find any students with filters: '$@'!" "$student_lines"

    local students_count=$(_gtb_count_lines "$student_lines")

    echo "$student_lines" \
        | sort \
        | _gtb_table_format

    read -p "about to QUIT above $(red ${students_count}) students? (y|n) " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]
    then
        return 1
    fi

    _gtb_org_remove "$@"
    _gtb_student_org_delete "$@"
    GTB_TRELLO_BOARD_NAME=$(echo $GTB_TERM | sed 's/gtb/GTB/')
    _gtb_trello_board_remove "$@"
    GTB_TRELLO_BOARD_NAME="GTB-Resource"
    _gtb_trello_board_remove "$@"
    _gtb_dashboard_student_deactivate "$@"
    _gtb_student_delete "$@"
    _gtb_config_commit "chore: $GTB_TERM quit students $@"
    _gtb_config_push
}

_gtb_student_delete() {
    local student_lines=$(_gtb_filter_students "$@")
    assert_not_empty "error: cannot find any students with filters: '$@'!" "$student_lines"

    local students_count=$(_gtb_count_lines "$student_lines")

    echo "$student_lines" \
        | sort \
        | _gtb_table_format

    read -p "about to DELETE $(red ${students_count}) students from $(red $GTB_STUDENTS_FILE)? (y|n) " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]
    then
        return 1
    fi

    echo "$student_lines" \
        | _gtb_cuts 1 \
        | env_parallel \
            --bar \
            --linebuffer \
            --jobs 1 \
            "sed -i '' -E '/^{}/d' '$GTB_STUDENTS_FILE'"

    _gtb_config_diff "$GTB_STUDENTS_FILE"
}

_gtb_student_remove() {
    _gtb_student_delete "$@"
}

_gtb_student_list_format() {
    if [[ "$GTB_RAW" == "true" ]]
    then
        cat
        return 0
    fi

    cat | tr ' ' '|' | sort | _gtb_tabularize | cat -n
}

_gtb_student_list() {
    _gtb_filter_students "$@" | while read -r FULLNAME ORG TERM_NAME USERNAME TAGS; do
        printf "%s\n" "$TERM_NAME $FULLNAME $ORG $USERNAME $TAGS"
    done \
        | _gtb_cuts "$GTB_FIELDS" \
        | ${FUNCNAME[0]}_format
}

_gtb_student_show_format() {
    cat | tr ' ' '\n' | cat -n
}

_gtb_student_show() {
    local STUDENT_FULLNAME=${1:?Trainee fullname is required! (e.g. zhang.san, li.si, etc.)}

    _gtb_filter_students \
        | grep "\<$STUDENT_FULLNAME\>" \
        | while read -r FULLNAME ORG TERM_NAME USERNAME TAGS; do
            printf "%s\n" "$TERM_NAME $FULLNAME $ORG $USERNAME $TAGS"
        done \
        | ${FUNCNAME[0]}_format
}

_gtb_student() {
    assert_students_file_exists

    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_stu() {
    _gtb_student "$@"
}

_gtb_st() {
    _gtb_student "$@"
}

remove_repo_from_team() {
    local ORG=$1
    local TEAM=$2
    local REPO=$3
    local ENDPOINT="/orgs/$ORG/teams/$TEAM/repos/$ORG/$REPO"

    run "gh api --silent -X DELETE $ENDPOINT"

    [[ $? -eq 0 ]] && info "DONE" || error "FAILED"
}

_gtb_actions_url() {
    local ORG=${1:?Org is required!}
    local REPO_NAME=${2:?Repo name is required!}

    echo "https://github.com/$ORG/$REPO_NAME/actions"
}

_gtb_push_to_student_repo() {
    local ORG=${1:?Org is required!}
    local REPO_NAME=${2:?Repo name is required!}

    cd $(_gtb_default_repo_dir $REPO_NAME)

    local BRANCHES=$(_git_list_all_branches_of_remote 'origin')
    for BRANCH in ${BRANCHES}
    do
        if [[ "$GTB_ALL_BRANCHES" == "true" ]] || [[ "${BRANCH}" == "master" ]]
        then
            run "git push $ORG origin/${BRANCH}:refs/heads/${BRANCH} $(_gtb_mute_stderr)"
        fi
    done

    echo $*
}

_gtb_last_commit_of_branch() {
    local REPO_NAME=${1:?Repo name is required!}
    local BRANCH=${2:?Branch name is required!}
    local REPO_DIR=$(_gtb_default_repo_dir $REPO_NAME)

    [[ -d $REPO_DIR ]] || fail "Cannot find local directory for repo '$REPO_NAME'!"

    cd $REPO_DIR

    if ! git remote | grep --silent "$ORG"; then
        return 0
    fi

    run "git rev-parse $BRANCH"
}

_gtb_remove_remote_student_repo() {
    local REPO_NAME=${1:?Repo name is required!}
    local REPO_DIR=$(_gtb_default_repo_dir $REPO_NAME)

    [[ -d $REPO_DIR ]] || return 0

    run "cd $REPO_DIR"

    while read -r ORG
    do
        run "git remote remove $ORG 2>/dev/null"
        echo $ORG $REPO_NAME
    done
}

_gtb_add_student_repo_as_remote() {
    local ORG=${1:?org name is required!}
    local REPO_NAME=${2:?Repo name is required!}

    local REPO_DIR=$(_gtb_default_repo_dir $REPO_NAME)
    [[ -d $REPO_DIR ]] || fail "Cannot find local directory for repo '$REPO_NAME'!"

    run "cd $REPO_DIR"

    local REMOTES=$(run "git remote")

    if ! echo "$REMOTES" | grep --silent "$ORG"; then
        local repo_url="git@github.com:$ORG/${REPO_NAME}.git"
        run "git remote add $ORG $repo_url" >&2
    fi

    if [[ $? -eq 0 ]]
    then
        echo "$* $SYMBOL_OK"
    else
        echo "$* $SYMBOL_ERROR"
    fi
}

_gtb_fetch_remote() {
    local REPO_NAME=${1:?Repo name is required!}
    local ORG=${2:?org name is required!}

    local REPO_DIR=$(_gtb_default_repo_dir $REPO_NAME)
    [[ -d $REPO_DIR ]] || fail "Cannot find local directory for repo '$REPO_NAME'!"

    run "cd $REPO_DIR"
    run "git fetch $ORG" >&2

    if [[ $? -eq 0 ]]
    then
        echo "$SYMBOL_OK $ORG"
    else
        echo "$SYMBOL_ERROR $ORG"
    fi
}

_gtb_create_local_branch() {
    local REPO_NAME=${1:?Repo name is required!}
    local ORG=${2:?org name is required!}

    local REPO_DIR=$(_gtb_default_repo_dir $REPO_NAME)
    [[ -d $REPO_DIR ]] || fail "Cannot find local directory for repo '$REPO_NAME'!"

    run "cd $REPO_DIR"
    run "git checkout -b $ORG $ORG/master" >&2

    if [[ $? -eq 0 ]]
    then
        echo "$SYMBOL_OK $ORG"
    else
        echo "$SYMBOL_ERROR $ORG"
    fi
}

_gtb_pick_refs() {
    local REPO_NAME=${1:?Repo name is required!}
    local ORG=${2:?org name is required!}

    shift 2

    local REPO_DIR=$(_gtb_default_repo_dir $REPO_NAME)
    [[ -d $REPO_DIR ]] || fail "Cannot find local directory for repo '$REPO_NAME'!"

    run "cd $REPO_DIR"
    run "git cherry-pick --abort" >&2
    run "git checkout $ORG" >&2 \
        && run "git cherry-pick --ff --allow-empty --keep-redundant-commits $*" >&2

    if [[ $? -eq 0 ]]
    then
        echo "$SYMBOL_OK $ORG"
    else
        run "git cherry-pick --abort" >&2
        echo "$SYMBOL_ERROR $ORG"
    fi
}

_gtb_push_master() {
    local REPO_NAME=${1:?Repo name is required!}
    local ORG=${2:?org name is required!}

    local REPO_DIR=$(_gtb_default_repo_dir $REPO_NAME)
    [[ -d $REPO_DIR ]] || fail "Cannot find local directory for repo '$REPO_NAME'!"

    run "cd $REPO_DIR"
    run "git push $ORG $ORG:master" >&2

    if [[ $? -eq 0 ]]
    then
        echo "$SYMBOL_OK $ORG"
    else
        echo "$SYMBOL_ERROR $ORG"
    fi
}

_gtb_delete_existing_remote() {
    local REPO_NAME=${1:?Repo name is required!}
    local REPO_DIR=$(_gtb_default_repo_dir $REPO_NAME)
    [[ -d $REPO_DIR ]] || fail "Cannot find local directory for repo '$REPO_NAME'!"

    run "cd $REPO_DIR"

    while read -r FULLNAME ORG TERM_NAME
    do
        run "git remote remove $ORG 2>/dev/null"
        echo $ORG $REPO_NAME $TERM_NAME $FULLNAME
    done
}

_gtb_create_repo_in_student_org() {
    local ORG=${1:?Org is required!}
    local REPO_NAME=${2:?Repo name is required!}

    gh_create_org_repo $ORG $REPO_NAME
    local result=$?
    if [[ $result -ne 0 ]]; then
        error "Failed to create repo '$REPO_NAME' in '$ORG'."
        return $result
    fi

    echo $*
}

_gtb_clone_default_repo() {
    local REPO_NAME=${1:?Repo name is required!}
    local repo_dir=$(_gtb_default_repo_dir $REPO_NAME)

    [[ -d $repo_dir ]] && run "rm -rf '$repo_dir'"

    gh_clone_repo $GTB_ORG $REPO_NAME $repo_dir

    if [[ $? -ne 0 ]]; then
        fail "Failed to clone repo $REPO_NAME to $repo_dir"
    fi
}

_gtb_update_default_repo() {
    local REPO_NAME=${1:?Repo name is required!}
    local repo_dir=$(_gtb_default_repo_dir $REPO_NAME)

    run "cd $repo_dir"
    run "git fetch origin --prune --prune-tags"
}

_gtb_repo_pick() {
    local REPO_NAME=${GTB_REPO:?repo name should be provided using --repo option.}

    local student_lines=$(_gtb_filter_students "$@")
    local students_count=$(_gtb_count_lines "$student_lines")
    assert_not_empty "error: cannot find any students with filters: '$@'!" "$student_lines"

    header "Verifying refs '$GTB_REFS'..."
    local commits_to_pick=$(_gtb_git_verify_refs "$REPO_NAME" "$GTB_REFS")
    if [[ -z "$commits_to_pick" ]]; then
        fail 'error: no valid commits is to be picked not provided. (e.g. gtb student repo pick --refs "origin/extended-tests" ...)'
    fi

    echo "$student_lines" | _gtb_cuts 3,2,1,7,8,9 | _gtb_table_format
    echo
    echo "$commits_to_pick" | tr ' ' '\n' | _gtb_nl

    if [[ "false" == "$GTB_YES" ]]
    then
        read -p "about to pick these refs to above $(red $students_count) students? (y|n) " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]
        then
            return 1
        fi
    fi

    _gtb_auto_schedule

    header "Clone repo $REPO_NAME..."
    _gtb_clone_default_repo $REPO_NAME

    header "Filter students..."
    local student_lines=$(_gtb_filter_students "$@")
    local students_count=$(_gtb_count_lines "$student_lines")

    [[ $students_count -eq 0 ]] && fail "error: no students matched by filters: '$@'"

    header "Add students' repo as remote..."
    local result_add_remote=$(echo "$student_lines" \
        | _gtb_cuts 1-2 \
        | env_parallel --jobs 1 --colsep ' ' --bar --linebuffer "_gtb_add_student_repo_as_remote {2} $REPO_NAME $(_gtb_mute_stderr)" \
        | sort \
        | _gtb_cuts 3)

    header "Fetch all remotes..."
    local result_fetch_remote=$(echo "$student_lines" \
        | _gtb_cuts 1-2 \
        | env_parallel --jobs $JOBS --colsep ' ' --bar --linebuffer "_gtb_fetch_remote $REPO_NAME {2} $(_gtb_mute_stderr)" \
        | sort -k2 \
        | _gtb_cuts 1)

    header "Create local branches..."
    local result_create_branch=$(echo "$student_lines" \
        | _gtb_cuts 1-2 \
        | env_parallel --jobs 1 --colsep ' ' --bar --linebuffer "_gtb_create_local_branch $REPO_NAME {2} $(_gtb_mute_stderr)" \
        | sort -k2 \
        | _gtb_cuts 1)

    header "Pick refs..."
    local result_pick_ref=$(echo "$student_lines" \
        | _gtb_cuts 1-2 \
        | env_parallel --jobs 1 --colsep ' ' --bar --linebuffer "_gtb_pick_refs $REPO_NAME {2} $commits_to_pick $(_gtb_mute_stderr)" \
        | sort -k2 \
        | _gtb_cuts 1)

    header "Push to remotes..."
    local result_push_to_remote=$(echo "$student_lines" \
        | _gtb_cuts 1-2 \
        | env_parallel --jobs $JOBS --colsep ' ' --bar --linebuffer "_gtb_push_master $REPO_NAME {2} $(_gtb_mute_stderr)" \
        | sort -k2 \
        | _gtb_cuts 1)

    if [[ -n $WORKFLOW_FILENAME ]]
    then
        header "Run workflows..."
        local result_run_workflow=$(echo "$student_lines" \
            | _gtb_cuts 1-2 \
            | env_parallel --jobs $JOBS --colsep ' ' --bar --linebuffer "gh_run_repo_workflow {2} $REPO_NAME $WORKFLOW_FILENAME" \
            | sort -k2 \
            | _gtb_cuts 1,3)
    fi

    {
        echo "ID ORG ADD FETCH BRANCH PICK PUSH RUN ACTIONS"
        pr -m -t -s' ' \
            <(echo "$student_lines" | _gtb_cuts 2 | sort) \
            <(echo "$result_add_remote") \
            <(echo "$result_fetch_remote") \
            <(echo "$result_create_branch") \
            <(echo "$result_pick_ref") \
            <(echo "$result_push_to_remote") \
            <(echo "$result_run_workflow") \
            | _gtb_nl
    } | _gtb_table_format -N \
        | _gtb_auto_notify
}

_gtb_repo_publish() {
    local REPO_NAME=$1
    shift

    local student_lines=$(_gtb_filter_students "$@")
    local students_count=$(_gtb_count_lines "$student_lines")
    assert_not_empty "error: cannot find any students with filters: '$@'!" "$student_lines"

    echo "$student_lines" | _gtb_cuts 3,2,1,7,8,9 | _gtb_table_format

    if [[ "false" == "$GTB_YES" ]]
    then
        read -p "about to publish repo '$(red $REPO_NAME)' to above $(red $students_count) students? (y|n) " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]
        then
            return 1
        fi
    fi

    _gtb_auto_schedule

    header "Clone repo $REPO_NAME..."
    _gtb_clone_default_repo $REPO_NAME

    local MAX_JOBS=$JOBS
    if [[ $MAX_JOBS -gt 20 ]]
    then
        MAX_JOBS=20
    fi

    header "Create repo $REPO_NAME in student's org..."
    echo "$student_lines" | cut -d' ' -f1-3 \
        | env_parallel --jobs $JOBS --colsep ' ' --bar --linebuffer "_gtb_create_repo_in_student_org {2} $REPO_NAME $(_gtb_mute_stderr) 1>&2"

    header "Add student's repo as remote..."
    echo "$student_lines" | cut -d' ' -f1-3 \
        | env_parallel --jobs 1 --colsep ' ' --bar --linebuffer "_gtb_add_student_repo_as_remote {2} $REPO_NAME $(_gtb_mute_stderr) 1>&2"

    header "Initialize secrets in student's repo..."
    echo "$student_lines" | cut -d' ' -f1-3 \
        | env_parallel --jobs $MAX_JOBS --colsep ' ' --bar --linebuffer "gh_init_repo_secrets {2} $REPO_NAME {3} {1} $(_gtb_mute_stderr) 1>&2"

    header "Push commits to student's repo..."
    local result_push=$(echo "$student_lines" | cut -d' ' -f1-3 \
        | env_parallel --jobs $JOBS --colsep ' ' --bar --linebuffer "_gtb_push_to_student_repo {2} $REPO_NAME $(_gtb_mute_stderr)")

    local RAW="$GTB_RAW"
    GTB_RAW="true"
    header "Check commits of student's repo..."
    local result_of_repo_check=$(_gtb_student_repo_check $REPO_NAME "$@" | sort -k2 | _gtb_cuts 1)
    header "Check secrets of student's repo..."
    local result_of_secret_check=$(_gtb_student_secret_check $REPO_NAME "$@" | sort -k2 | _gtb_cuts 1)
    header "Check workflows of student's repo..."
    local result_of_workflow_check=$(join -1 1 -2 1 -a 1 -o '1.1,2.2' -e '0' \
        <(echo "$student_lines" | _gtb_cuts 2 | sort) \
        <(_gtb_student_workflow_list $REPO_NAME "$@" | _gtb_cuts 2,3 | sort -k1) \
        | _gtb_cuts 2)
    GTB_RAW="$RAW"

    {
        echo 'No. Student LastCommit SecretsCount WorkflowsCount'
        pr -m -t -s' ' \
            <(echo "$student_lines" | _gtb_cuts 2 | sort) \
            <(echo "$result_of_repo_check") \
            <(echo "$result_of_secret_check") \
            <(echo "$result_of_workflow_check") \
            | _gtb_nl
    } | _gtb_table_format -N \
        | _gtb_auto_notify
}

_gtb_repo_remove() {
    local ORG=${1:?Organization is required!}
    shift
    local TEAM=${1:?Team is required!}
    shift

    if [[ -p /dev/stdin ]]
    then
        while read line
        do
            for repo in $line
            do
                remove_repo_from_team $ORG $TEAM $repo
            done
        done
    fi

    for repo in $@
    do
        remove_repo_from_team $ORG $TEAM $repo
    done
}

add_repo_to_team() {
    local ORG=$1
    local TEAM=$2
    local REPO=$3
    local ENDPOINT="/orgs/$ORG/teams/$TEAM/repos/$ORG/$REPO"

    run "gh api --silent -X PUT $ENDPOINT -F permission='pull'"

    [[ $? -eq 0 ]] && info "DONE" || error "FAILED"
}

_gtb_repo_add() {
    local ORG=${1:?Organization is required!}
    shift
    local TEAM=${1:?Team is required!}
    shift

    if [[ -p /dev/stdin ]]
    then
        while read line
        do
            for repo in $line
            do
                add_repo_to_team $ORG $TEAM $repo
            done
        done
    fi


    for repo in $@
    do
        add_repo_to_team $ORG $TEAM $repo
    done
}

_gtb_repo_list() {
    gh_list_org_repos \
        | sort -k2,2 \
        | _format_repo_time_fields \
        | _gtb_table_format \
        | sed "s/ public / $(red public) /"
}

_gtb_repo() {
    if ! echo $1 | grep --silent '^\(list\|add\|remove\|publish\|pick\)$'; then
        set -- list "$@"
    fi

    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_org_team_open() {
    run "open https://github.com/orgs/${GTB_ORG}/teams/${GTB_TERM}/members"
}

_gtb_org_team_invite() {
    local student_lines=$(_gtb_filter_students "$@")
    local students_count=$(_gtb_count_lines "$student_lines")
    assert_not_empty "error: cannot find any students with filters: '$@'!" "$student_lines"

    echo "$student_lines" \
        | env_parallel \
            --linebuffer \
            --jobs $JOBS \
            --colsep ' ' \
            --bar \
            gh_invite_user_to_team "$GTB_ORG" "$GTB_TERM" "{4}" "{2}" "{7}" \
        | _gtb_sort '1,1r;4,4' \
        | _gtb_table_format \
        | _gtb_tr_symbols
}

_gtb_org_team_members() {
    (
    echo 'No. Config Github Student'
    join -1 5 -2 2 -a 1 -a 2 -o '1.1,2.1,0,1.3,1.2,1.6,1.7' -e 'NO' \
        <(_gtb_filter_students | sort -k4 | sed 's/^/YES /') \
        <(gh_list_org_team_members $GTB_ORG $GTB_TERM | sort | sed 's/^/YES /') \
        | sort -k1,2 -r \
        | _gtb_nl
    ) | _gtb_table_format -N
}

_gtb_org_team_list() {
    local ORG=${1:-$GTB_ORG}
    gh_list_org_teams $ORG
}

_gtb_org_team() {
    if ! echo $1 | grep --silent '^\(list\|open\|invite\|members\)$'; then
        set -- open "$@"
    fi

    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_org_remove() {
    local student_lines=$(_gtb_filter_students "$@")
    local students_count=$(_gtb_count_lines "$student_lines")

    echo "$student_lines" \
        | _gtb_cuts 2,4,7 \
        | sort \
        | column -t \
        | cat -n

    read -p "about to DELETE ${students_count} students from $GTB_ORG? (y|n) " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]
    then
        return 1
    fi

    echo "$student_lines" \
        | _gtb_cuts 2,4 \
        | env_parallel \
            --bar \
            --colsep ' ' \
            --linebuffer \
            --jobs $JOBS \
            gh_remove_user_from_org $GTB_ORG {2}
}

_gtb_org_invite() {
    local student_lines=$(_gtb_filter_students "$@")
    local students_count=$(_gtb_count_lines "$student_lines")
    assert_not_empty "error: cannot find any students with filters: '$@'!" "$student_lines"

    echo "$student_lines" \
        | env_parallel \
            --linebuffer \
            --jobs $JOBS \
            --colsep ' ' \
            --bar \
            gh_invite_user_to_org "$GTB_ORG" "{4}" 'direct_member' "{2}" "{7}" \
        | _gtb_sort '1,1r;2,2' \
        | _gtb_table_format \
        | _gtb_tr_symbols
}

_gtb_org_members() {
    (
    echo 'No. Config Github Student'
    join -1 5 -2 2 -a 1 -o '1.1,2.1,0,1.3,1.2,1.6,1.7' -e 'NO' \
        <(_gtb_filter_students | sort -k4 | sed 's/^/YES /') \
        <(gh_list_org_members $GTB_ORG | sort | sed 's/^/YES /') \
        | sort -k1,2 -r \
        | _gtb_nl
    ) | _gtb_table_format -N
}

_gtb_org_open() {
    local ORG=${1:-$GTB_ORG}
    run "open https://github.com/${ORG}"
}

_gtb_org() {
    assert_students_file_exists

    if ! echo $1 | grep --silent '^\(open\|invite\|remove\|team\|members\)$'; then
        set -- open "$@"
    fi

    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_trello_card_create() {
    GTB_TRELLO_BOARD_NAME="${GTB_TRELLO_BOARD_NAME:?Trello board name is required! Specify by --board <NAME>.}"
    GTB_TRELLO_LIST_NAME="${GTB_TRELLO_LIST_NAME:?Trello list name is required! Specify by --list <NAME>.}"

    local LIST_ID=$(_gtb_trello_find_list_id "$GTB_TRELLO_BOARD_NAME" "$GTB_TRELLO_LIST_NAME")
    local CARD_NAME=$(_gtb_urlencode "$*")

    if [[ $# -lt 1 ]]
    then
        fail 'Card name is required!'
    fi

    run "http POST '$GTB_TRELLO_API/cards?idList=${LIST_ID}&pos=top&name=$CARD_NAME&$GTB_TRELLO_AUTH'" \
        | jq -r '.shortUrl, .name'
}

_gtb_trello_card_check() {
    GTB_TRELLO_BOARD_NAME="${GTB_TRELLO_BOARD_NAME:?Trello board name is required! Specify by --board <NAME>.}"
    GTB_TRELLO_LIST_NAME="${GTB_TRELLO_LIST_NAME:?Trello list name is required! Specify by --list <NAME>.}"

    local LIST_ID=$(_gtb_trello_find_list_id "$GTB_TRELLO_BOARD_NAME" "$GTB_TRELLO_LIST_NAME")
    assert_not_empty "Cannot find list with name '$GTB_TRELLO_LIST_NAME'!" "$LIST_ID"

    local cards_info=$(run "http GET '$GTB_TRELLO_API/lists/${LIST_ID}/cards?$GTB_TRELLO_AUTH'" \
        | jq -jr '.[] | .pos, " ", .name, " ", .badges.checkItemsChecked, " ", .badges.checkItems, " ", .id, " ", .shortUrl, "\n"')

    local student_lines=$(_gtb_filter_students "$@")
    echo "$student_lines" | cut -d' ' -f2,7 | while read -r ORG CHINESE_NAME REST
    do
        local card_info=$(echo "$cards_info" | grep --color=never "$CHINESE_NAME")
        [[ -n "$card_info" ]] && status='OK' || status="ER"
        echo $status $ORG $card_info
    done \
        | _gtb_sort '1,1r;5,5n;6,6n;7,7' \
        | _gtb_table_format \
        | _gtb_tr_symbols
}

_gtb_trello_card_list() {
    GTB_TRELLO_BOARD_NAME="${GTB_TRELLO_BOARD_NAME:?Trello board name is required! Specify by --board <NAME>.}"
    GTB_TRELLO_LIST_NAME="${GTB_TRELLO_LIST_NAME:?Trello list name is required! Specify by --list <NAME>.}"

    local LIST_ID=$(_gtb_trello_find_list_id "$GTB_TRELLO_BOARD_NAME" "$GTB_TRELLO_LIST_NAME")
    assert_not_empty "Cannot find list with name '$GTB_TRELLO_LIST_NAME'!" "$LIST_ID"

    run "http GET '$GTB_TRELLO_API/lists/${LIST_ID}/cards?$GTB_TRELLO_AUTH'" \
        | jq -jr '.[] | .pos, " ", .name, " ", .badges.checkItemsChecked, " ", .badges.checkItems, " ", .id, " ", .shortUrl, "\n"' \
        | _gtb_sort '3,3n;4,4n;5,5' \
        | _gtb_table_format
}

_gtb_trello_card() {
    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_trello_list_list() {
    GTB_TRELLO_BOARD_NAME="${GTB_TRELLO_BOARD_NAME:?Trello board name is required! Specify by --board <NAME>.}"
    local BOARD_ID=$(_gtb_trello_find_board_id "$GTB_TRELLO_BOARD_NAME")

    run "http GET '$GTB_TRELLO_API/boards/${BOARD_ID}/lists?$GTB_TRELLO_AUTH'" \
        | jq -r '.[].name' \
        | cat -n
}

_gtb_trello_list() {
    if ! echo $1 | grep --silent '^\(list\)$'; then
        set -- list "$@"
    fi

    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_trello_board_remove() {
    GTB_TRELLO_BOARD_NAME="${GTB_TRELLO_BOARD_NAME:?Trello board name is required! Specify by --board <NAME>.}"

    local student_lines=$(_gtb_filter_students "$@")
    local students_count=$(_gtb_count_lines "$student_lines")

    assert_not_empty "error: cannot find any students with filters: '$@'!" "$student_lines"

    echo "$student_lines" \
        | _gtb_cuts 2,4,7 \
        | sort \
        | column -t \
        | cat -n

    read -p "about to REMOVE ${students_count} students from Trello board $GTB_TRELLO_BOARD_NAME? (y|n) " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]
    then
        return 1
    fi

    echo "$student_lines" \
        | _gtb_unformat \
        | _gtb_cuts '2,5' \
        | env_parallel --jobs $JOBS --colsep ' ' --bar --linebuffer \
            _gtb_trello_remove_member_from_board {1} {2} \
        | sort \
        | column -t \
        | cat -n
}

_gtb_trello_board_invite() {
    _gtb_filter_students "$@" \
        | _gtb_unformat \
        | _gtb_cuts '2,5' \
        | env_parallel --jobs $JOBS --colsep ' ' --bar --linebuffer \
            _gtb_trello_invite_member_to_board {1} {2} \
        | _gtb_sort 1r \
        | _gtb_table_format \
        | _gtb_tr_symbols
}

_gtb_trello_board_list() {
    GTB_TRELLO_USERNAME="${GTB_TRELLO_USERNAME:?Trello username is required! Specify by GTB_TRELLO_USERNAME or --username.}"

    run "http '$GTB_TRELLO_API/members/${GTB_TRELLO_USERNAME}/boards?$GTB_TRELLO_AUTH'" \
        | jq -jr '.[] | .id, "^", .name, "\n"' \
        | _gtb_table_format -s '^'
}

_gtb_trello_board() {
    if ! echo $1 | grep --silent '^\(list\|invite\|remove\)$'; then
        set -- list "$@"
    fi

    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_trello() {
    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_tag_stat() {
    local POSITION=${1:?Tag position, starts from 1, is required!}
    shift

    local total_fields=$(head -n1 $GTB_STUDENTS_FILE | wc -w)

    if [[ "$POSITION" -lt 1 ]] || [[ "$POSITION" -gt $total_fields ]]
    then
        fail "error: position '$POSITION' is out of range."
    fi

    GTB_RAW="true"
    GTB_FIELDS="$POSITION"

    _gtb_student_list "$@" | _gtb_count
}

_gtb_tag_remove() {
    local POSITION=${1:?Tag position, starts from 1, is required!}

    local total_fields=$(head -n1 $GTB_STUDENTS_FILE | wc -w)

    if [[ "$POSITION" -lt 1 ]] || [[ "$POSITION" -gt $total_fields ]]
    then
        fail "error: position '$POSITION' is out of range."
    fi

    local BACKUP_FILE="/tmp/${GTB_STUDENTS_FILE##*/}"
    run "cp $GTB_STUDENTS_FILE $BACKUP_FILE"

    [[ -f "$BACKUP_FILE" ]] || fail "error: cannot backup students file to '$BACKUP_FILE'."

    local fields=$(seq 1 $total_fields | tr '\n' ',' | sed "s/${POSITION},//" | sed 's/,$//')
    run "cat $BACKUP_FILE | cut -d' ' -f${fields} > $GTB_STUDENTS_FILE"

    _gtb_config_diff "$GTB_STUDENTS_FILE"
}

_gtb_tag_replace() {
    local FROM_TAG=${1:?Source tag is required!}
    local TO_TAG=${2:?Target tag is required!}
    shift 2

    local student_lines=$(_gtb_filter_students "$@")

    if ! grep -w --color --silent "$FROM_TAG" <(echo "$student_lines") 1>&2
    then
        fail 'error: source tag not found, please make sure you are using the correct value.'
    fi

    if grep -w --color "$TO_TAG" <(echo "$student_lines") 1>&2
    then
        fail 'error: new tag conficts with existing entires shown as above, please change a new one.'
    fi

    echo "$student_lines" \
        | _gtb_cuts 1 \
        | env_parallel --linebuffer --jobs 1 --bar "sed -i '' -E '/{}/s/[[:<:]]$FROM_TAG[[:>:]]/$TO_TAG/g' $GTB_STUDENTS_FILE"

    _gtb_config_diff "$GTB_STUDENTS_FILE"
}

_gtb_tag_add() {
    local TAG=${1:?Tag is required!}

    if grep -w --color "$TAG" "$GTB_STUDENTS_FILE" 1>&2
    then
        fail 'error: new tag conficts with existing entires shown as above, please change a new one.'
    fi

    local total_fields=$(head -n1 $GTB_STUDENTS_FILE | wc -w)
    local POSITION=${GTB_POSITION:-$((total_fields + 1))}

    if [[ "$POSITION" -le 1 ]]
    then
        run "sed -i '' 's/^/$TAG /g' $GTB_STUDENTS_FILE"
    elif [[ "$POSITION" -gt $total_fields ]]
    then
        run "sed -i '' 's/$/ $TAG/g' $GTB_STUDENTS_FILE"
    else
        local BACKUP_FILE="/tmp/${GTB_STUDENTS_FILE##*/}"
        run "cp $GTB_STUDENTS_FILE $BACKUP_FILE"

        [[ -f "$BACKUP_FILE" ]] || fail "error: cannot backup students file to '$BACKUP_FILE'."

        paste -d ' ' \
            <(cat $BACKUP_FILE | _gtb_cuts "1-$((POSITION - 1))") \
            <(jot -n -b "$TAG" $(wc -l $BACKUP_FILE)) \
            <(cat $BACKUP_FILE | _gtb_cuts "$((POSITION))-") \
            > $GTB_STUDENTS_FILE
    fi

    _gtb_config_diff "$GTB_STUDENTS_FILE"
}

_gtb_tag_index() {
    head -n1 $GTB_STUDENTS_FILE | _gtb_student_show_format
}

_gtb_tag() {
    assert_students_file_exists

    if ! echo $1 | grep --silent '^\(index\|add\|replace\|remove\|stat\)$'; then
        set -- index "$@"
    fi

    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_config_pull() {
    run "cd '$GTB_CONFIG_DIR'"
    run "git pull --rebase --autostash"
}

_gtb_config_push() {
    run "cd '$GTB_CONFIG_DIR'"
    run "git pull --rebase --autostash"
    run "git push"
}

_gtb_config_commit() {
    run "cd '$GTB_CONFIG_DIR'"
    run "git add students*.txt"
    run "git commit -m '$*'"
}

_gtb_config_show() {
    local TERM_NAME=${1:-$GTB_TERM}
    less -N "$GTB_CONFIG_DIR/students-${TERM_NAME}.txt"
}

_gtb_config_edit() {
    local TERM_NAME=${1:-$GTB_TERM}
    vim "$GTB_CONFIG_DIR/students-${TERM_NAME}.txt"
}

_gtb_config_diff() {
    local FILES="${1:-.}"
    run "cd '$GTB_CONFIG_DIR'"
    run "git diff --stat $FILES"
    run "git diff --color-words $FILES"
}

_gtb_config_list() {
    run "cd '$GTB_CONFIG_DIR'"
    run 'ls -l students*.txt'
}

_gtb_config_dir() {
    echo "$GTB_CONFIG_DIR"
}

_gtb_config() {
    assert_students_file_exists

    if ! echo $1 | grep --silent '^\(dir\|list\|diff\|edit\|show\|commit\|push\|pull\)$'; then
        set -- dir "$@"
    fi

    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_dashboard_list_students() {
    run "http --print b GET $GTB_DASHBOARD_ADDRESS/terms/${GTB_TERM}/students/list" \
        | jq -r '.[] | .gtbTerm.name, .gtbUsername, .displayName, .githubUsername, .id' \
        | paste -d' ' - - - - - \
        | sort -k1,2
}

_gtb_dashboard_search_student() {
    run "http --print b GET $GTB_DASHBOARD_ADDRESS/terms/${GTB_TERM}/students/search?gtbUsername=${1}" \
        | jq .
}

_gtb_dashboard_deactivate_student() {
    local FULLNAME=${1:?Trainee fullname is required! (e.g. zhang.san, li.si, etc.)}

    local id=$(run "_gtb_dashboard_search_student '$FULLNAME' | jq -r '.id'")

    local result=$(run "http --print b --auth 'user:$GTB_SONAR_TOKEN' PUT '$GTB_DASHBOARD_ADDRESS/terms/${GTB_TERM}/students/${id}/deactivate' | jq -r '.deactivated'")

    if [[ "$result" == "true" ]]; then
        echo "✅ $FULLNAME"
        return 0
    fi

    echo "❌ $FULLNAME"
    return 1
}

_gtb_dashboard_list_scores() {
    run "http --print b GET $GTB_DASHBOARD_ADDRESS/terms/${GTB_TERM}/submissions" \
        | jq -r '.[] | .student.gtbUsername, .evaluationAverageScore, .homeworkAverageScore, .performanceAverageScore' \
        | paste -d' ' - - - - \
        | awk '{print $1, $2 + $3, $2, $3, $4}' \
        | sort -k1
}

_gtb_sort_submission_list() {
    if echo "$GTB_SORT_ORDER" | grep --silent -E '\d'
    then
        _gtb_sort "$GTB_SORT_ORDER"
        return
    fi

    case "$GTB_SORT_ORDER" in
        type)
            cat | sort -k1,1 -k10,10 -k2,2
            ;;
        name)
            cat | sort -k2,2 -k3,3
            ;;
        score)
            cat | sort -k5,5r -k7,7r -k6,6rn -k8,8rn -k9,9rn -k3,3
            ;;
        *) # default to start time
            cat | sort -k10,10 -k2,2 -k3,3
            ;;
    esac
}

_gtb_dashboard_list_submissions() {
    run "http --print b GET $GTB_DASHBOARD_ADDRESS/terms/${GTB_TERM}/submissions" \
        | jq -r '[.[].submissions[]] | .[] | .assignmentType, .repository, .gtbUsername, .displayName, .firstMeasurementTestStatus, .firstMeasurementScore, .finalMeasurementTestStatus, .finalMeasurementScore, .extendTestPassPercentage, .startTime, .firstMeasurementTime, .finalMeasurementTime' \
        | paste -d' ' - - - - - - - - - - - - \
        | _gtb_sort_submission_list
}

_gtb_dashboard_create_submission() {
    local ASSIGNMENT_KEY="${1:?assignmentKey is required!}"
    local START_TIME="${2:?startTime is required!}"
    local FIRST_MEASUREMENT_TIME="${3:?firstMeasurementTime is required!}"
    local FINAL_MEASUREMENT_TIME="${4:?finalMeasurementTime is required!}"
    local USERNAMES="${5:?gtbUsernames is required!}"

    local PAYLOAD_JSON_FILE="/tmp/gtb-create-submission-$ASSIGNMENT_KEY-$$.json"

    cat <<EOF > "$PAYLOAD_JSON_FILE"
{
    "assignmentKey": "$ASSIGNMENT_KEY",
    "startTime": "$START_TIME",
    "firstMeasurementTime": "$FIRST_MEASUREMENT_TIME",
    "finalMeasurementTime": "$FINAL_MEASUREMENT_TIME",
    "gtbUsernames":[$USERNAMES]
}
EOF
    http --print=b \
        --auth "user:$GTB_SONAR_TOKEN" \
        PUT "$GTB_DASHBOARD_ADDRESS/terms/$GTB_TERM/submissions" \
        < "$PAYLOAD_JSON_FILE"
}

_gtb_dashboard_delete_submission() {
    local ASSIGNMENT_KEY="${1:?assignmentKey is required!}"
    local USERNAME="${2:?gtbUsername is required!}"

    run "http --auth 'user:$GTB_SONAR_TOKEN' DELETE '$GTB_DASHBOARD_ADDRESS/terms/${GTB_TERM}/submissions?assignmentKey=${ASSIGNMENT_KEY}&gtbUsername=${USERNAME}'"

    echo "$ASSIGNMENT_KEY $USERNAME"
}

_gtb_dashboard_submission_remove() {
    GTB_RAW="true"
    local found_submissions="$(_gtb_dashboard_submission_list "$@")"
    local found_submissions_count="$(_gtb_count_lines "$found_submissions")"

    if [[ "$found_submissions_count" -eq 0 ]]
    then
        info 'No submissions found.'
        exit 0
    fi

    GTB_RAW="false"
    echo "$found_submissions" | _gtb_table_format

    read -p "about to DELETE submissions above? (y|n) " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]
    then
        return 1
    fi

    info "Delete submissions..."
    echo "$found_submissions" \
        | _gtb_cuts 2,3 \
        | env_parallel \
            --colsep ' ' \
            --linebuffer \
            --jobs $JOBS \
            --bar \
            _gtb_dashboard_delete_submission "{1}" "{2}" \
        | sort \
        | cat -n

    info "Query submissions..."
    GTB_RAW="true"
    local left_submissions="$(_gtb_dashboard_submission_list "$@")"
    local left_submissions_count=$(_gtb_count_lines "$left_submissions")

    if [[ "$left_submissions_count" -gt 0 ]]
    then
        GTB_RAW="false"
        echo
        error "failed to delete following $left_submissions_count submissions:"
        echo "$left_submissions" | _gtb_table_format
        exit 1
    fi

    info "All specified submissions deleted!"
}

_gtb_dashboard_submission_delete() {
    _gtb_dashboard_submission_remove "$@"
}

_gtb_dashboard_submission_create() {
    # gtb dashboard submission add --repo bronze-java-level-1 --start 2021041609 --basic 8H --refactor 14d w02fri1
    local REPO_NAME=${GTB_REPO:?repo name should be provided using --repo option.}
    local START_AT=${GTB_START_AT:?start time should be provided using --start optoin, e.g. 2022-06-01 09:30:00, 2021041609}
    local DURATION_BASIC=${GTB_DURATION_BASIC:-$GTB_DURATION_REFACTOR}
    local DURATION_REFACTOR=${GTB_DURATION_REFACTOR:?refactoring duration should be specified using --refactor option, e.g. 14d, 21d, 8h, 10h, etc}

    START_AT=$(echo $START_AT | sed -E 's/[^0-9]//g' | cut -c1-12)
    START_AT=$(echo $(($START_AT * 1000000)) | cut -c1-12)

    DURATION_BASIC=$(echo $DURATION_BASIC | tr 'h' 'H')
    DURATION_REFACTOR=$(echo $DURATION_REFACTOR | tr 'h' 'H')

    # date -v4m -v16d -v9H -v0M -v0S '+%Y-%m-%dT%H:%M:%S%z' | sed -E 's/(..)$/:\1/'
    # 2021-04-16T09:00:00+08:00
    local ts_start=$(date \
        -v$(echo $START_AT | cut -c1-4)y \
        -v$(echo $START_AT | cut -c5-6)m \
        -v$(echo $START_AT | cut -c7-8)d \
        -v$(echo $START_AT | cut -c9-10)H \
        -v$(echo $START_AT | cut -c11-12)M \
        -v0S \
        '+%s')
    local ts_basic_end=$(date -v+${DURATION_BASIC} -jf '%s' "$ts_start" '+%s')
    local ts_refactoring_end=$(date -v+${DURATION_REFACTOR} -jf '%s' "$ts_start" '+%s')

    local student_lines=$(_gtb_filter_students "$@")
    local students_count=$(_gtb_count_lines "$student_lines")

    assert_not_empty "error: cannot find any students with filters: '$@'!" "$student_lines"

    echo "$student_lines" | _gtb_cuts 3,2,1,7,8,9 | _gtb_table_format

    if [[ "false" == "$GTB_YES" ]]
    then
        read -p "about to create submission of repo '$(red $REPO_NAME)' for $(red $students_count) students above? (y|n) " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]
        then
            return 1
        fi
    fi

    info "submission information:"
    echo "$(red $REPO_NAME)"
    echo "$(_gtb_time_format_for_display $ts_start)"
    echo "$(_gtb_time_format_for_display $ts_basic_end)"
    echo "$(_gtb_time_format_for_display $ts_refactoring_end)"

    if [[ "false" == "$GTB_YES" ]]
    then
        read -p "please confirm submission information above? (y|n) " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]
        then
            return 1
        fi
    fi

    local fullnames="$(echo "$student_lines" | _gtb_cuts 1 | _gtb_quotes_line | _gtb_join_lines)"

    info "create submissions..."
    _gtb_dashboard_create_submission \
        "$REPO_NAME" \
        "$(_gtb_time_format_for_api $ts_start)" \
        "$(_gtb_time_format_for_api $ts_basic_end)" \
        "$(_gtb_time_format_for_api $ts_refactoring_end)" \
        "$fullnames"

    info "query created submissions..."
    local RAW="$GTB_RAW"
    GTB_RAW="true"
    local created_submissions="$(_gtb_dashboard_submission_list "$@")"
    local created_submissions_count=$(_gtb_count_lines "$created_submissions")
    GTB_RAW="$RAW"

    echo "$created_submissions" | _gtb_table_format | _gtb_auto_notify

    if [[ "$created_submissions_count" -ne "$students_count" ]]
    then
        error "error: $(($students_count - $created_submissions_count)) submissions are missing!"
        return 1
    fi
}

_gtb_dashboard_submission_add() {
    _gtb_dashboard_submission_create "$@"
}

_format_submission_time_fields() {
    # .assignmentType, .repository, .gtbUsername, .displayName,
    #.firstMeasurementTestStatus, firstMeasurementScore, .finalMeasurementTestStatus, .finalMeasurementScore,
    # .startTime, .firstMeasurementTime, .finalMeasurementTime'
    while read -r f1 f2 f3 f4 f5 f6 f7 f8 f9 start_time first_measurment_time final_measurment_time rest
    do
        local local_start_time=$(_gtb_time_format_convert_time_zone $start_time)
        local local_first_measurment_time=$(_gtb_time_format_convert_time_zone $first_measurment_time)
        local local_final_measurment_time=$(_gtb_time_format_convert_time_zone $final_measurment_time)
        echo "$f1 $f2 $f3 $f4 $f5 $f6 $f7 $f8 $f9 $local_start_time $local_first_measurment_time $local_final_measurment_time"
    done
}

_gtb_dashboard_submission_list() {
    local student_lines=$(_gtb_filter_students "$@")
    local students_count=$(_gtb_count_lines "$student_lines")

    assert_not_empty "error: cannot find any students with filters: '$@'!" "$student_lines"

    local submissions="$(_gtb_dashboard_list_submissions)"

    local REPO_NAME=${GTB_REPO:-}
    if [[ ! -z "$REPO_NAME" ]]
    then
        submissions="$(echo "$submissions" | grep --color=never -w $REPO_NAME)"
    fi

    local fullnames="$(echo "$student_lines" | _gtb_cuts 1 | paste -s -d'|' -)"
    if [[ ! -z "$fullnames" ]]
    then
        submissions="$(echo "$submissions" | grep --color=never -w -E $fullnames)"
    fi

    [[ -z "$submissions" ]] && return

    echo "$submissions" \
        | _format_submission_time_fields \
        | _gtb_table_format
}

_gtb_dashboard_submission() {
    assert_students_file_exists

    if ! echo $1 | grep --silent '^\(list\|create\|add\|remove\|delete\)$'; then
        set -- list "$@"
    fi

    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_dashboard_sub() {
    _gtb_dashboard_submission "$@"
}

_gtb_dashboard_student_deactivate() {
    local student_lines=$(_gtb_filter_students "$@")
    local students_count=$(_gtb_count_lines "$student_lines")

    assert_not_empty "error: cannot find any students with filters: '$@'!" "$student_lines"

    echo "$student_lines" \
        | _gtb_cuts 2,4,7 \
        | sort \
        | column -t \
        | cat -n

    read -p "about to deactivate ${students_count} students from Dashboard? (y|n) " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]
    then
        return 1
    fi

    echo "$student_lines" \
        | _gtb_cuts 1 \
        | env_parallel \
            --linebuffer \
            --jobs $JOBS \
            --bar \
            _gtb_dashboard_deactivate_student {} \
        | sort \
        | cat -n
}

_gtb_dashboard_student_search() {
    local FULLNAME=${1:?Trainee fullname is required! (e.g. zhang.san, li.si, etc.)}
    _gtb_dashboard_search_student "$FULLNAME"
}

_gtb_dashboard_student_list() {
    _gtb_dashboard_list_students \
        | column -t \
        | cat -n
}

_gtb_dashboard_student() {
    if ! echo $1 | grep --silent '^\(list\|search\|deactivate\)$'; then
        set -- list "$@"
    fi

    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_dashboard_st() {
    _gtb_dashboard_student "$@"
}

_gtb_dashboard_open() {
    run "open ${GTB_DASHBOARD_ADDRESS%/api}?term=${GTB_TERM}"
}

_gtb_sort_dashboard_list() {
    if echo "$GTB_SORT_ORDER" | grep --silent -E '\d'
    then
        _gtb_sort "$GTB_SORT_ORDER"
        return
    fi

    case "$GTB_SORT_ORDER" in
        team)
            cat | sort -k7,7 -k8,8nr -k9,9nr -k10,10nr -k11,11nr -k2
            ;;
        evaluation|quiz)
            cat | sort -k9,9nr -k8,8nr -k10,10nr -k11,11nr -k2
            ;;
        homework|exercise|ex.)
            cat | sort -k10,10nr -k8,8nr -k9,9nr -k11,11nr -k2
            ;;
        performance|perf)
            cat | sort -k11,11nr -k8,8nr -k9,9nr -k10,10nr -k2
            ;;
        *)
            cat | sort -k8,8nr -k9,9nr -k10,10nr -k11,11nr -k2
            ;;
    esac
}

_gtb_dashboard_list() {
    local student_lines=$(_gtb_filter_students "$@")
    assert_not_empty "error: cannot find any students with filters: '$@'!" "$student_lines"

    local score_records="$(_gtb_dashboard_list_scores)"
    local sorted_results=$(join -1 1 -2 1 -a 1 -o '1.2,2.1,1.3,1.4,1.7,1.5,1.6,2.2,2.3,2.4,2.5' -e 'MISSING' \
        <(_gtb_filter_students | cut -d' ' -f1,2,6-10 | sort) \
        <(echo "$score_records") \
        | _gtb_sort_dashboard_list \
        | _gtb_nl)
    local fullnames="$(echo "$student_lines" | _gtb_cuts 1 | _gtb_join_lines '|')"
    local filtered_results=$(echo "$sorted_results" | grep -wE "$fullnames")

    {
        echo "ID RANK ORG FULLNAME NICKNAME CN_NAME MAJOR CLASS TEAM TOTAL QUIZ EX. PERF."
        echo "$filtered_results" | _gtb_nl
    } | _gtb_table_format -N
}

_gtb_dashboard() {
    assert_students_file_exists

    if ! echo $1 | grep --silent '^\(list\|open\|student\|st\|submission\|sub\)$'; then
        set -- list "$@"
    fi

    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_dash() {
    _gtb_dashboard "$@"
}

_gtb_comments() {
    local GTB_TMP_COMMENTS_FILE="/tmp/gtb-comments.md"
    local GTB_COMMENTS_FILE="gtb-comments.md"

    extract_and_format_comments > $GTB_TMP_COMMENTS_FILE
    strip_blank_details_block $GTB_TMP_COMMENTS_FILE | tee $GTB_COMMENTS_FILE | tee /dev/tty | pbcopy
}

_gtb_check() {
    assert_students_file_exists

    while read -r FULLNAME USERNAME TERM_NAME TAGS
    do
        if echo "$TERM_NAME" | grep --silent "$GTB_TERM"
        then
            if [[ -z "$*" ]] || echo "$@" | grep --silent "\<${FULLNAME}\>" || echo "$TAGS" | grep --silent "\<$1\>"
            then
                if gh api "/users/$USERNAME" | jsonpp | grep --silent "\"login\": \"$USERNAME\""
                then
                    info "$TERM_NAME $FULLNAME $USERNAME"
                else
                    error "$TERM_NAME $FULLNAME $USERNAME"
                fi
            fi
        fi
    done < $GTB_STUDENTS_FILE
}

_gtb_up() {
    local REPO_NAME=${1:?Repo name is required! (e.g. B-spring-config-homework, F-jest-homework, etc.)}
    local FULLNAME=${2:?Trainee name is required! (e.g. zhang.san, li.si, etc.)}
    local HOMEWORK_ROOT="$GTB_ROOT/$GTB_TERMS_DIR/$GTB_TERM/$REPO_NAME/$FULLNAME"
    local HOMEWORK_TESTS_ROOT="$GTB_ROOT/${REPO_NAME}-ac"
    local DOCKER_ERROR_LOG_FILE='/tmp/docker_error.log'

    [[ -d $HOMEWORK_ROOT ]] || fail "Cannot find homework: $HOMEWORK_ROOT"
    [[ -d $HOMEWORK_TESTS_ROOT ]] || fail "Cannot find homework tests: $HOMEWORK_TESTS_ROOT"

    prepare_run_context "$HOMEWORK_ROOT" "$HOMEWORK_TESTS_ROOT" "$REPO_NAME"

    info "Start starting up..."
    cd "$HOMEWORK_ROOT"
    run "./gradlew build -x test && docker-compose up -d --build --remove-orphans"
    if [[ "$?" -ne 0 ]]; then
        error "Application startup failed!"
        clear_run_context "$HOMEWORK_ROOT"
        exit 1
    fi

    info "Start waiting application ready..."
    ensure_application_is_ready 60
    if [[ $? -ne 0 ]]; then
        docker-compose logs -f app > "$DOCKER_ERROR_LOG_FILE"
        error "Application fail to be ready! See the error log at file: ${DOCKER_ERROR_LOG_FILE}"
        clear_run_context "$HOMEWORK_ROOT"

        _gtb_down "$@"
        exit 1
    fi

    info "Application is ready!"
    clear_run_context "$HOMEWORK_ROOT"

    if [[ "$AUTO_TEST" == "true" ]]; then
        _gtb_test "$@"
        _gtb_down "$@"
    fi
}

_gtb_down() {
    local REPO_NAME=${1:?Repo name is required! (e.g. B-spring-config-homework, F-jest-homework, etc.)}
    local FULLNAME=${2:?Trainee name is required! (e.g. zhang.san, li.si, etc.)}
    local HOMEWORK_ROOT="$GTB_ROOT/$GTB_TERMS_DIR/$GTB_TERM/$REPO_NAME/$FULLNAME"
    local HOMEWORK_TESTS_ROOT="$GTB_ROOT/${REPO_NAME}-ac"

    [[ -d $HOMEWORK_ROOT ]] || fail "Cannot find homework: $HOMEWORK_ROOT"
    [[ -d $HOMEWORK_TESTS_ROOT ]] || fail "Cannot find homework tests: $HOMEWORK_TESTS_ROOT"

    prepare_run_context "$HOMEWORK_ROOT" "$HOMEWORK_TESTS_ROOT" "$REPO_NAME"

    info "Start shutting down..."
    cd "$HOMEWORK_ROOT"
    if [[ `docker-compose ps -q | wc -l` -ne 0 ]]; then
        run "docker-compose down --rmi local"
    else
        error "Application not startup yet!"
    fi

    clear_run_context "$HOMEWORK_ROOT"
}

_gtb_test() {
    local REPO_NAME=${1:?Repo name is required! (e.g. B-spring-config-homework, F-jest-homework, etc.)}
    local FULLNAME=${2:?Trainee name is required! (e.g. zhang.san, li.si, etc.)}
    local HOMEWORK_ROOT="$GTB_ROOT/$GTB_TERMS_DIR/$GTB_TERM/$REPO_NAME/$FULLNAME"
    local HOMEWORK_TESTS_ROOT="$GTB_ROOT/${REPO_NAME}-ac"
    local TEST_OUTPUT_FILE='/tmp/gtb_gradle_test_output.log'

    [[ -d $HOMEWORK_ROOT ]] || fail "Cannot find homework: $HOMEWORK_ROOT"
    [[ -d $HOMEWORK_TESTS_ROOT ]] || fail "Cannot find homework tests: $HOMEWORK_TESTS_ROOT"

    info "Start running acceptance tests..."
    ( cd $HOMEWORK_TESTS_ROOT && \
        run "./gradlew --rerun-tasks test < /dev/null" | \
        tee /dev/tty | \
        strip_colors > $TEST_OUTPUT_FILE )

    echo
    info "Start generating test results..."
    for f in $(cat $TEST_OUTPUT_FILE | grep 'Test _'  | cut -d'_' -f2 | sort -u)
    do
        echo $f
        echo '======='
        cat $TEST_OUTPUT_FILE | grep $f | cut -d'_' -f3 | sed -e 's/^/* /' -e 's/ PASSED//'
        echo
    done | tee $HOMEWORK_ROOT/gtb-test-results.md | grep --color -E 'FAILED|$'
}

_gtb_join() {
    assert_students_file_exists

    REPO_NAME=${1:?Repo name is required! (e.g. B-spring-config-homework, F-jest-homework, etc.)}
    shift

    join_repos $@
}

_gtb_build() {
    assert_students_file_exists

    AUTO_BUILD="true"
    REPO_NAME=${1:?Repo name is required! (e.g. B-spring-config-homework, F-jest-homework, etc.)}
    shift

    build_repos $@
}

_gtb_update() {
    assert_students_file_exists

    AUTO_UPDATE="true"
    REPO_NAME=${1:?Repo name is required! (e.g. B-spring-config-homework, F-jest-homework, etc.)}
    shift

    clone_or_update_repos $@
    build_repos $@
}

_gtb_clone() {
    assert_students_file_exists

    REPO_NAME=${1:?Repo name is required! (e.g. B-spring-config-homework, F-jest-homework, etc.)}
    shift

    clone_or_update_repos $@
    build_repos $@
}

_gtb_show() {
    assert_students_file_exists

    REPO_NAME=${1:?Repo name is required! (e.g. B-spring-config-homework, F-jest-homework, etc.)}
    shift

    while read -r FULLNAME USERNAME TERM_NAME TAGS
    do
        if echo "$TERM_NAME" | grep --silent "$GTB_TERM"
        then
            if [[ -z "$*" ]] || echo "$@" | grep --silent "\<${FULLNAME}\>" || echo "$TAGS" | grep --silent "\<$1\>"
            then
                if gh api /repos/$USERNAME/$REPO_NAME 1>/dev/null 2>&1
                then
                    info "$TERM_NAME $FULLNAME $USERNAME"
                else
                    error "$TERM_NAME $FULLNAME $USERNAME"
                fi
            fi
        fi
    done < $GTB_STUDENTS_FILE
}

_gtb_colors() {
  # for bg_color in {0..$(tput colors)}; do
  for bg_color in $(seq 0 $(tput colors)); do
    tput setaf 231
    tput setab $bg_color
    printf "  %3d  " $bg_color
    if [[ $(( $bg_color % 8 )) -eq 0 ]]; then
        tput sgr0
        printf "\n"
    fi;
  done;
}

_gtb_upgrade() {
    read -p "Are you SURE to upgrade to lastest version? (y|n) " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]
    then
        return 1
    fi

    run "brew upgrade GTB-training/gtb/util"
}

_gtb_update() {
    [[ -d $GTB_CONFIG_DIR ]] || fail 'Cannot find config directory `$GTB_CONFIG_DIR`. Please run `gtb init` to re-init.'
    update_repo $GTB_CONFIG_DIR
}

_gtb_init() {
    mkdir -p $GTB_ROOT/$GTB_REPOS_DIR
    mkdir -p $GTB_ROOT/$GTB_TERMS_DIR

    [[ -d $GTB_CONFIG_DIR ]] || gh_clone_repo $GTB_ORG $GTB_CONFIG_REPO $GTB_CONFIG_DIR
}

_gtb_term() {
    echo $GTB_TERM
}

_gtb_version() {
    echo "gtb $VERSION"
    exit 0
}

_gtb_help() {
    echo "Please refer to the README doc:"
    info "https://github.com/GTB-training/util/blob/master/README.md"
    exit 0
}

OPTIND=1

JOBS=${GTB_DEFAULT_JOBS:-30}
AUTO_UPDATE="false"
AUTO_BUILD="false"
AUTO_ACCEPT="true"
AUTO_TEST="false"
CHECK_ROLE_ONLY="false"

shopt -s extglob

PARAMS=""
while (( "$#" )); do
    case "$1" in
        --jobs)
            if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
                JOBS=$2
                shift 2
            else
                fail "Error: Argument for $1 is missing"
            fi
            ;;
        --workflow)
            if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
                WORKFLOW_FILENAME=$2
                shift 2
            else
                fail "Error: Argument for $1 is missing"
            fi
            ;;
        --username)
            if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
                GTB_TRELLO_USERNAME=$2
                shift 2
            else
                fail "Error: Trello username specified by '$1' is missing"
            fi
            ;;
        --board)
            if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
                GTB_TRELLO_BOARD_NAME=$2
                shift 2
            else
                fail "Error: Trello board name specified by '$1' is missing"
            fi
            ;;
        --list)
            if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
                GTB_TRELLO_LIST_NAME=$2
                shift 2
            else
                fail "Error: Trello list name specified by '$1' is missing"
            fi
            ;;
        --type)
            if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
                GTB_TRELLO_MEMBER_TYPE=$2
                shift 2
            else
                fail "Error: Trello member type specified by '$1' is missing"
            fi
            ;;
        -f|--fields)
            if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
                GTB_FIELDS=$2
                shift 2
            else
                fail "Error: Fields to display specified by '$1' is missing"
            fi
            ;;
        --position)
            if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
                GTB_POSITION=$2
                shift 2
            else
                fail "Error: Position of new tag specified by '$1' is missing"
            fi
            ;;
        --repo)
            if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
                GTB_REPO=$2
                shift 2
            else
                fail "Error: repository name specified by '$1' is missing"
            fi
            ;;
        --refs)
            if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
                GTB_REFS=$2
                shift 2
            else
                fail "Error: refs to pick specified by '$1' is missing, comma separated, e.g. origin/extended-tests,origin/fix"
            fi
            ;;
        --start)
            if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
                GTB_START_AT=$2
                shift 2
            else
                fail "Error: evaluation start_at time specified by '$1' is missing, e.g. 2021041609"
            fi
            ;;
        --basic)
            if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
                GTB_DURATION_BASIC=$2
                shift 2
            else
                fail "Error: evaluation basic part duration specified by '$1' is missing, e.g. 8h, 10h, 7d, 14d"
            fi
            ;;
        --refactor)
            if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
                GTB_DURATION_REFACTOR=$2
                shift 2
            else
                fail "Error: evaluation refactor part duration specified by '$1' is missing, e.g. 14d, 21d, 8h, 10h"
            fi
            ;;
        --sort)
            if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
                GTB_SORT_ORDER=$2
                shift 2
            else
                fail "Error: column to sort with specified by '$1' is missing, e.g. total, evaluation, homework, performance, '1,1nr;2,2'"
            fi
            ;;
        --schedule)
            if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
                GTB_SCHEDULE="$2"
                shift 2
            else
                fail "Error: scheduled time specified by '$1' is missing, e.g. 20200601_0900"
            fi
            ;;
        --all)
            GTB_ALL_BRANCHES="true"
            shift
            ;;
        --notify)
            GTB_NOTIFY="true"
            shift
            ;;
        --yes)
            GTB_YES="true"
            shift
            ;;
        --raw)
            GTB_RAW="true"
            shift
            ;;
        -D|--debug)
            GTB_DEBUG="true"
            shift
            ;;
        -u|--update)
            AUTO_UPDATE="true"
            shift
            ;;
        -b|--build)
            AUTO_BUILD="true"
            shift
            ;;
        -l|--list)
            AUTO_ACCEPT="false"
            shift
            ;;
        -t|--test)
            AUTO_TEST="true"
            shift
            ;;
        --role)
            CHECK_ROLE_ONLY="true"
            shift
            ;;
        -+([0-9])[dHMS])
            PARAMS="$PARAMS $1"
            shift
            ;;
        -*|--*=)
            fail "Unsupported flag $1"
            shift
            ;;
        *)
            PARAMS="$PARAMS $1"
            shift
            ;;
    esac
done

eval set -- "$PARAMS"

source `which env_parallel.bash`

SUBCOMMAND=${1:?Subcommand is required! (e.g. init, clone, build, update, join, test, up, down, check, show, help.)}
shift

# main method starts from here...
if [[ "$(type -t ${SUBCMD_PREFIX}_$SUBCOMMAND)" != 'function' ]]; then
    error "Subcommand \`$SUBCOMMAND\` is INVALID!"
    exit 2
fi

${SUBCMD_PREFIX}_${SUBCOMMAND} $@

