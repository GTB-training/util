#!/usr/bin/env bash

VERSION=1.265.7

GTB_DEBUG=${GTB_DEBUG:-false}

GTB_ROOT="${GTB_ROOT:-$HOME/code/gtb}"
GTB_TERM="${GTB_TERM:-gtb-404}"
GTB_CONFIG_REPO=config
GTB_CONFIG_DIR="$GTB_ROOT/$GTB_CONFIG_REPO"
GTB_TRAINERS_FILE="${GTB_TRAINERS_FILE:-$GTB_CONFIG_DIR/trainers.txt}"
GTB_BUDDIES_FILE="${GTB_BUDDIES_FILE:-$GTB_CONFIG_DIR/buddies-${GTB_TERM}.txt}"
GTB_BUDDIES_MAPPING_FILE="${GTB_BUDDIES_MAPPING_FILE:-$GTB_CONFIG_DIR/buddies-mapping-${GTB_TERM}.txt}"
GTB_STUDENTS_FILE_DEFAULT="${GTB_CONFIG_DIR}/students.txt"
GTB_STUDENTS_FILE_TERM="${GTB_CONFIG_DIR}/students-${GTB_TERM}.txt"
GTB_ASGMT_SUB_FILE="${GTB_ASGMT_SUB_FILE:-${GTB_CONFIG_DIR}/assignment-submissions-${GTB_TERM}.txt}"
GTB_STEP_ASGMT_FILE="${GTB_STEP_ASGMT_FILE:-${GTB_CONFIG_DIR}/step-assignments-${GTB_TERM}.txt}"
GTB_EOT_FEEDBACK_SUBMISSIONS_FILE="${GTB_EOT_FEEDBACK_SUBMISSIONS_FILE:-$GTB_CONFIG_DIR/eot-feedback-submissions-${GTB_TERM}.txt}"

if [[ -f $GTB_STUDENTS_FILE ]]; then
  GTB_STUDENTS_FILE=$GTB_STUDENTS_FILE
elif [[ -f $GTB_STUDENTS_FILE_TERM ]]; then
  GTB_STUDENTS_FILE=$GTB_STUDENTS_FILE_TERM
elif [[ -f $GTB_STUDENTS_FILE_DEFAULT ]]; then
  GTB_STUDENTS_FILE=$GTB_STUDENTS_FILE_DEFAULT
fi

GTB_MAX_RETRY_TIMES_REPO_PICK="${GTB_MAX_RETRY_TIMES_REPO_PICK:-3}"
GTB_RANDOM_LIST_FILE="/tmp/gtb_random_list.txt"
GTB_EXCLUDE_DIRS=(--exclude-dir '.git' --exclude-dir 'build' --exclude-dir 'gradle' --exclude-dir 'node_modules' --exclude-dir 'dist' --exclude-dir '.cache')
GTB_REPOS_DIR="repos"
GTB_TERMS_DIR="terms"
GTB_FEEDBACKS_DIR="feedbacks-${GTB_TERM}"
GTB_USER_CACHE_DIR="$HOME/.cache/gtb"
SUBCMD_PREFIX='_gtb'
GTB_DEFAULT_REPO_ROOT="${GTB_DEFAULT_REPO_ROOT:-$GTB_ROOT/$GTB_REPOS_DIR/default}"
GTB_PER_PAGE=100
GTB_TRAINER_FILTER=''
GTB_BUDDY_FILTER=''
GTB_FROM_STDIN='false'
GTB_FROM_STUDENTS='true'
GTB_FROM_BUDDIES='false'
GTB_FROM_TRAINERS='false'
GTB_LIST_BY_BUDDY='true'
GTB_LIST_BY_BUDDEE='false'
GTB_TRELLO_CARD_DUE_IN_DAYS=3
GTB_HTTP_METHOD='GET'
GTB_HTTP_PRINT=''
GTB_PY_NAME_DEFAULT='~PINYIN_NAME~'
GTB_QUIT_EMPLOYEE='false'

declare -r NULL='-'

if [[ "$(tty)" == 'not a tty' ]]; then
  GTB_PARALLEL_OPT_PROGRESS_BAR=''
else
  GTB_PARALLEL_OPT_PROGRESS_BAR='--bar'
fi

# https://stackoverflow.com/a/8597411
if [[ "$OSTYPE" == "darwin"* ]]; then
  # Mac OSX
  GTB_GREP="ggrep"
  GTB_FIND="gfind"
else
  # Unknown.
  GTB_GREP="grep"
  GTB_FIND="find"
fi

GTB_ORG=tws-graduate-program

GTB_YES="false"
GTB_RAW="false"
GTB_FORCE="false"
GTB_ALL_BRANCHES="false"
GTB_LOCAL="false"
GTB_NOTIFY="false"
GTB_LINE_NUMBERS="true"
GTB_SORT_ORDER=""
GTB_START_NUM='1'
GTB_TABLE_FORMAT_SEPARATOR=' '
GTB_EPOCH_DATETIME='19700101000000'

SYMBOL_OK='✅'
SYMBOL_ERROR='❌'

STATUS_OK='OK'
STATUS_ERROR='Error'
STATUS_FOUND='Found'
STATUS_NOT_FOUND='NotFound'

cuts() {
  cat | cut -d' ' "$@"
}

green() {
  echo -n "$(tput setaf 28)$(tput bold)$*$(tput sgr 0)"
}

blue() {
  echo -n "$(tput setaf 32)$(tput bold)$*$(tput sgr 0)"
}

yellow() {
  echo -n "$(tput setaf 220)$(tput bold)$*$(tput sgr 0)"
}

red() {
  echo -n "$(tput setaf 161)$(tput bold)$*$(tput sgr 0)"
}

info() {
  echo "$(tput setaf 4)$(tput bold)$*$(tput sgr 0)"
}

warn() {
  echo "$(tput setaf 3)$(tput bold)$*$(tput sgr 0)" >&2
}

error() {
  echo "$(tput setaf 1)$(tput bold)$*$(tput sgr 0)" >&2
}

debug() {
  echo "$(tput setaf 5)$(tput bold)$*$(tput sgr 0)"
}

run() {
  if [[ "$GTB_DEBUG" == "true" ]]; then
    echo "$(tput setaf 22)$*$(tput sgr 0)" 1>&2
    start_time=`date +%s`
    eval $*
    end_time=`date +%s`
    info "execution time was `expr $end_time - $start_time` s."
  else
    eval $*
  fi
}

header() {
  tput bold
  tput setaf 19
  tput setab 251
  printf "%-$(tput cols)s" "$*" 1>&2
  tput sgr0
  printf "\n" 1>&2
}

logt() {
  local fg_color=$1
  local bg_color=$2
  shift 2
  echo "$(tput setab $bg_color)$(tput setaf $fg_color)$*$(tput sgr 0)"
}

logtf() {
  local fg_color=$1
  shift
  echo "$(tput setaf $fg_color)$*$(tput sgr 0)"
}

logtb() {
  local bg_color=$1
  shift
  echo "$(tput setab $bg_color)$*$(tput sgr 0)"
}

logtn() {
  local fg_color=$1
  local bg_color=$2
  shift 2
  echo -n "$(tput setab $bg_color)$(tput setaf $fg_color)$*$(tput sgr 0)"
}

fail() {
  if [[ $# -ne 0 ]]; then
    error $*
  fi
  exit 1
}

strip_colors() {
  while read -r line; do
    echo "$line" |
      sed $'s,\x1b\\[[0-9;]*[a-zA-Z],,g'
  done
}

_gtb_open() {
  [[ $# -lt 1 ]] && fail "Arguments required for open command!"
  run "open ${*}"
}

_gtb_mute_stdout() {
  [[ "$GTB_DEBUG" == "true" ]] && echo '' || echo '1>/dev/null'
}

_gtb_mute_stderr() {
  [[ "$GTB_DEBUG" == "true" ]] && echo '' || echo '2>/dev/null'
}

_gtb_urlencode() {
  node --eval "console.log(encodeURIComponent(process.argv[1]))" "$*"
}

_gtb_tee1() {
  cat | tee /dev/tty
}

_gtb_tabularize() {
  if [[ -z "$*" ]]; then
    cat | column -s'|' -t
  else
    cat | column -s'|' -t | sed $'1s:^:\\\n'"==> $1"$'\\\n:'
  fi
}

_gtb_table() {
  _gtb_table_format "$@"
}

_gtb_table_format() {
  while (("$#")); do
    case "$1" in
    --raw)
      GTB_RAW="true"
      shift
      ;;
    -N | --no-line-numbers)
      GTB_LINE_NUMBERS="false"
      shift
      ;;
    -s)
      if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
        GTB_TABLE_FORMAT_SEPARATOR="$2"
        shift 2
      else
        fail "Error: separator specified by '$1' is missing"
      fi
      ;;
    --start-num)
      if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
        GTB_START_NUM="$2"
        shift 2
      else
        fail "Error: index start number specified by '$1' is missing"
      fi
      ;;
    *)
      shift
      ;;
    esac
  done

  if [[ "$GTB_RAW" == "true" ]]; then
    cat
    return
  fi

  if [[ "$GTB_LINE_NUMBERS" != "true" ]]; then
    cat | column -s"$GTB_TABLE_FORMAT_SEPARATOR" -t
    return
  fi

  cat | _gtb_nl -s "$GTB_TABLE_FORMAT_SEPARATOR" | column -s"$GTB_TABLE_FORMAT_SEPARATOR" -t
}

_gtb_tr_symbols() {
  cat | sed -E \
    -e "s/(^| )(OK)( |$)/\1$SYMBOL_OK\3/" \
    -e "s/(^| )(ER)( |$)/\1$SYMBOL_ERROR\3/"
}

_gtb_highlight() {
  local result="$(cat)"

  if [[ "$GTB_RAW" == "true" ]]; then
    echo "$result"
    return
  fi

  while [[ $# -ge 2 ]]; do
    result=$(echo "$result" | sed -E "s/(^| )($1)( |$)/\1$($2 $1)\3/g")
    shift 2
  done

  echo "$result"
}

_gtb_auto_notify() {
  if ! which slack >/dev/null; then
    cat
    return
  fi

  if [[ "$GTB_NOTIFY" != "true" ]]; then
    cat
    return
  fi

  local result="$(cat)"
  local result_to_notify=$(echo "$result" | tail -n10)
  if [[ "$GTB_DEBUG" == "true" ]]; then
    slack chat send --channel '#gtb' --text "$result_to_notify"
  else
    slack chat send --channel '#gtb' --text "$result_to_notify" 1>/dev/null
  fi
  echo "$result"
}

_current_datetime() {
  date "+%Y%m%d-%H%M%S"
}

_gtb_time_format_for_display() {
  local TIMESTAMP=${1:?timestamp is required!}
  date -jf '%s' "$TIMESTAMP" '+%Y-%m-%d %A %H:%M:%S'
}

_gtb_time_format_for_api() {
  local TIMESTAMP=${1:?timestamp is required!}
  date -jf '%s' "$TIMESTAMP" '+%Y-%m-%dT%H:%M:%S%z' | sed -E 's/(..)$/:\1/'
}

_gtb_time_format_convert_time_zone() {
  local DATETIME=${1:?Datetime is required!}

  date -jf '%Y-%m-%dT%H:%M:%S%z' \
    "$(echo $DATETIME | sed -E 's/(.*)Z$/\1+0000/g')" \
    '+%Y-%m-%d %H:%M:%S %a' |
    tr ' ' '_'
}

_gtb_print_in_columns() {
  cat | pr -${1:-3} -t -w $(tput cols)
}

_gtb_pv() {
  cat | pv -tbelSs $1 -i 0.3 -N "total is: $1 current is"
}

_gtb_unformat() {
  cat | tr '\t' ' ' | tr -s ' ' | sed 's/^ //'
}

_gtb_cuts() {
  cut -d"${2:- }" -f "${1:-$GTB_FIELDS}" <(cat)
}

_gtb_count() {
  GTB_FIELDS="${1:-1-}"

  local input="$(cat | _gtb_cuts)"
  local lines_count=$(_gtb_count_lines "$input")
  {
    echo "$input" | sort | uniq -c | sed -E 's/^ +//g' | _gtb_sort "${GTB_SORT_ORDER:-2}"
    echo -e "$lines_count TOTAL"
  } | column -t
}

_gtb_timestamp() {
  local DATETIME="${1:? Datetime string is required!}"
  shift

  if [[ "$DATETIME" == "now" ]]; then
    DATETIME="$(date '+%Y-%m-%d_%H:%M:%S_%a')"
  fi

  DATETIME=$(echo $DATETIME | sed -E 's/[^0-9]//g' | cut -c1-14)
  DATETIME="${DATETIME}${GTB_EPOCH_DATETIME:${#DATETIME}}"

  # date -v4m -v16d -v9H -v0M -v0S '+%Y-%m-%dT%H:%M:%S%z' | sed -E 's/(..)$/:\1/'
  # 2021-04-16T09:00:00+08:00
  local TS=$(date \
    -v$(echo $DATETIME | cut -c1-4)y \
    -v$(echo $DATETIME | cut -c5-6)m \
    -v$(echo $DATETIME | cut -c7-8)d \
    -v$(echo $DATETIME | cut -c9-10)H \
    -v$(echo $DATETIME | cut -c11-12)M \
    -v$(echo $DATETIME | cut -c13-14)S \
    '+%s')

  for OFFSET in "$@"; do
    OFFSET=$(echo $OFFSET | tr 'Dhms' 'dHMS')
    TS=$(date -v${OFFSET} -jf '%s' "$TS" '+%s')
  done

  date -jf '%s' "$TS" '+%s'
}

_gtb_date() {
  date -jf "%s" $(_gtb_timestamp "$@") '+%Y-%m-%d_%H:%M:%S_%a'
}

_gtb_quotes_line() {
  local QUOTE="${1:-\"}"
  cat | sed -E "s/^/$QUOTE/;s/$/$QUOTE/"
}

_gtb_join_lines() {
  local SEPARATOR="${1:-,}"
  cat | paste -s -d"$SEPARATOR" - | tr -d '\n'
}

_gtb_nl() {
  while (("$#")); do
    case "$1" in
    -s)
      if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
        GTB_TABLE_FORMAT_SEPARATOR="$2"
        shift 2
      else
        fail "Error: separator specified by '$1' is missing"
      fi
      ;;
    *)
      shift
      ;;
    esac
  done

  cat | nl -v "${GTB_START_NUM}" -s "${GTB_TABLE_FORMAT_SEPARATOR:- }" | _gtb_unformat
}

_gtb_default_repo_dir() {
  local REPO_NAME=${1:?Repo name is required!}
  echo "$GTB_DEFAULT_REPO_ROOT/$REPO_NAME"
}

_gtb_run_subcommand() {
  COMMAND=${1:?Command is required! (e.g. repo, student.)}
  shift
  SUBCOMMAND=${1:?Subcommand is required! (e.g. list, add, remove.)}
  shift

  local subcommand_function="_gtb_${COMMAND}_${SUBCOMMAND}"

  if [[ "$(type -t $subcommand_function)" != 'function' ]]; then
    fail "error: Unknown subcommand: $SUBCOMMAND"
  fi

  $subcommand_function "$@"
}

_gtb_filter() {
  _gtb_filter_file <(cat -) '' "$@"
}

_gtb_filter_file() {
  local -r FILENAME=${1:?filename is required!}
  # CN column indices is required, you can pass an empty string or comma separated index string! (e.g. 2,7)
  local -r CN_COL_INDICES=${2}
  shift 2

  local FILTER

  if [[ -z "$*" ]]; then
    cat "${FILENAME}" | _gtb_split
    return 0
  fi

  {
    local PATTERN=''
    for FILTER in "$@"; do
      PATTERN="${PATTERN}|(^| )${FILTER}( |$)"
    done
    PATTERN="${PATTERN#|}"

    $GTB_GREP -E --color=never "${PATTERN}" $FILENAME

    if [[ "$OSTYPE" == "darwin"* ]]; then
      for FILTER in "$@"; do
        if echo "$FILTER" | $GTB_GREP --silent -P '[\p{Han}]'; then
          awk -v CN_COL_INDICES="$CN_COL_INDICES" -v CN_NAME="$FILTER" '{
                        n = split(CN_COL_INDICES, indices, ",");
                        for (i in indices) {
                            if ($indices[i] == CN_NAME) { print }
                        }
                    }' $FILENAME
        fi
      done
    fi
  } | LC_ALL=C sort -u |
    _gtb_split
}

_gtb_filter-file() {
  _gtb_filter_file "$@"
}

_gtb_filter_students() {
  _gtb_filter_file "$GTB_STUDENTS_FILE" "7" "$@"
}

_gtb_filter_buddies() {
  _gtb_filter_file "$GTB_BUDDIES_FILE" "2,4,8" "$@" | grep -v '^FULLNAME'
}

_gtb_filter_trainers() {
  _gtb_filter_file "$GTB_TRAINERS_FILE" "4" "$@" | grep -v '^FULLNAME'
}

_gtb_filter_asgmt_submissions() {
  _gtb_filter_file "$GTB_ASGMT_SUB_FILE" '' "$@" | grep -v '^ORG_NAME'
}

_gtb_filter_buddies_mapping() {
  if [[ $# -le 1 ]]; then
    cat "${GTB_BUDDIES_MAPPING_FILE}"
    return
  fi

  local -r FILTER_BY="${1:?please specify filtery-by using 1 for buddy, 2 for buddee!}"
  shift

  local -r KEYWORDS="$(echo $* | tr ' ' '|')"
  local PATTERN

  if [[ "1" == "${FILTER_BY}" ]]; then
    PATTERN="^${KEYWORDS} "
  else
    PATTERN=" ${KEYWORDS}$"
  fi
  $GTB_GREP -E --color=never "${PATTERN}" "${GTB_BUDDIES_MAPPING_FILE}"
}

_gtb_field_index() {
  local -r FILENAME="${1:?filename is required!}"
  local -r FIELD="${2:?field name is required!}"

  local -r FIELDS="$(head -n1 "$FILENAME")"

  if ! $GTB_GREP --silent "\<$FIELD\>" <(echo "$FIELDS"); then
    fail "error: cannot find '$FIELD' in '$FIELDS' from file '$FILENAME'!"
  fi

  echo "$FIELDS" | tr ' ' '\n' | nl -n ln | $GTB_GREP "$FIELD" | _gtb_cuts 1
}

_gtb_split() {
  if [[ -n "$1" ]]; then
    GTB_CHUNK="$1"
  fi

  if [[ -z "${GTB_CHUNK}" ]]; then
    cat
    return 0
  fi

  cat | gsplit -n "r/${GTB_CHUNK}"
}

gh_check_user() {
  local USERNAME=${1:?username is required!}
  local result=$(run "gh api '/users/$USERNAME' $(_gtb_mute_stderr)" |
    jq -r 'if .login then "OK" else "ER" end')
  if [[ -z "$result" ]]; then
    result='ER'
  fi
  echo "$result $*"
}

gh_user_id() {
  local USERNAME=${1:?username is required!}
  run "gh api /users/${USERNAME} 2>/dev/null" | jsonpp |
    grep '"\(id\)"' |
    tr -d ' ,' |
    cut -d':' -f2
}

gh_invite_user_to_org() {
  local ORG=${1:?org is required!}
  local USERNAME=${2:?username is required!}
  local ROLE=${3:-direct_member}
  local result=$(gh_create_invitation $ORG $(gh_user_id $USERNAME) $ROLE |
    jq -r 'if .created_at or .errors[0].message == "Invitee is already a part of this org" then "OK" else "ER" end')
  if [[ -z "$result" ]]; then
    result='ER'
  fi
  echo "$result $*"
}

gh_check_user_not_in_org() {
  local student_lines=$(_gtb_filter_students "$@")
  local students_count=$(_gtb_count_lines "$student_lines")
  assert_not_empty "error: cannot find any students with filters: '$@'!" "$student_lines"

  local ORG=$(echo "$student_lines" | _gtb_cuts 2)
  local USERNAME=$(echo "$student_lines" | _gtb_cuts 4)

  local result=$(run "gh api -X GET /orgs/${ORG}/members")
  if [[ $(echo $result | jq -r '.message?') != "Not Found" ]]; then
    result=$(echo $result | jq -r --arg u "$USERNAME" \
      'if any(.[]; .login ==$u) == true then "ER" else "OK" end')
  else
    result="OK"
  fi

  echo "$result $*"
  [[ "$result" != "OK" ]] && fail "error: user $USERNAME still in org $ORG"
}

gh_remove_user_from_org() {
  local ORG=${1:?org is required!}
  local USERNAME=${2:?username is required!}
  run "gh api -X DELETE /orgs/${ORG}/members/$USERNAME 1>/dev/null 2>&1"
}

gh_invite_user_to_team() {
  local ORG=${1:?org is required!}
  local TEAM=${2:?team is required!}
  local USERNAME=${3:?username is required!}
  local result=$(run "gh api -X PUT '/orgs/${ORG}/teams/${TEAM}/memberships/${USERNAME}' $(_gtb_mute_stderr)" |
    jq -r 'if .role then "OK" else "ER" end')
  if [[ -z "$result" ]]; then
    result='ER'
  fi
  echo "$result $*"
}

gh_find_org() {
  local ORG=${1:?org is required!}

  if run "gh api /orgs/$ORG $(_gtb_mute_stderr)" | jsonpp | grep --silent "\"login\": \"$ORG\""; then
    echo "created" "$@"
  else
    echo "not_found" "$@"
  fi
}

gh_membership() {
  local ORG=${1:?org is required!}
  local CN_NAME=${2:?CN name is required!}
  local USERNAME=${3:?username is required!}
  run "gh api '/orgs/${ORG}/memberships/${USERNAME}' $(_gtb_mute_stderr)" |
    jq -jr --arg ORG $ORG --arg USERNAME $USERNAME --arg CN_NAME $CN_NAME \
      'if .role then
            .user.login, " ", .organization.login, " ", $CN_NAME, " ", .role, " ", .state, "\n"
        else
            $USERNAME, " ", $ORG, " ", $CN_NAME, " ", "not_a_member", " ", "404", "\n"
        end'
}

gh_set_org_membership() {
  local ORG=${1:?org is required!}
  local USERNAME=${2:?username is required!}
  local ROLE=${3:?role is required!(admin|member)}

  run "gh api -X PUT '/orgs/${ORG}/memberships/${USERNAME}' -F role='$ROLE' $(_gtb_mute_stderr)" |
    jq -jr '.role // "not_found", " ", .state // "404", "\n"' |
    sed "s/^/$USERNAME $ORG /"
}

gh_create_invitation() {
  local ORG=${1:?Org is required!}
  local INVITEE_ID=${2:?Invitee ID is required!}
  local ROLE=${3:-direct_member}
  run "gh api /orgs/${ORG}/invitations -F role=$ROLE -F invitee_id=$INVITEE_ID $(_gtb_mute_stderr)"
}

gh_list_org_teams() {
  local ORG=${1:-$GTB_ORG}
  local ENDPOINT="/orgs/$ORG/teams"

  run "gh api --paginate $ENDPOINT 2>/dev/null" | jsonpp |
    grep '    "name":' |
    tr -d '" ,' |
    cut -d':' -f2 |
    sort
}

gh_list_org_team_members() {
  local ORG=${1:?Organization is required!}
  local TEAM=${2:?Team is required!}
  local ENDPOINT="/orgs/${ORG}/teams/${TEAM}/members?per_page=100"

  run "gh api --paginate $ENDPOINT 2>/dev/null" | jsonpp |
    grep '    "login":' |
    tr -d '" ,' |
    cut -d':' -f2 |
    sort
}

gh_list_org_members() {
  local ORG=${1:?Organization is required!}
  local ENDPOINT="/orgs/${ORG}/members?per_page=$GTB_PER_PAGE"

  run "gh api --paginate '${ENDPOINT}' $(_gtb_mute_stderr)" |
    jq -r '.[] | .login' |
    sort
}

gh_list_org_repos() {
  local ORG=${1:-$GTB_ORG}
  local TEAM=${GTB_ORG_TEAM}

  local ENDPOINT="/orgs/$ORG/repos?per_page=${GTB_PER_PAGE}"
  if [[ -n "$TEAM" ]]; then
    ENDPOINT="/orgs/$ORG/teams/$TEAM/repos?per_page=${GTB_PER_PAGE}"
  fi

  run "gh api --paginate '${ENDPOINT}' $(_gtb_mute_stderr)" |
    jq -jr 'if type == "array" then .[] | .owner.login, " ", .name, " ", .private, " ", .created_at, "\n" else "\n" end' |
    grep -v '^$' |
    sed 's/ true / private /;s/ false / public /'
}

gh_show_org_repo_commit() {
  local ORG=${1:?Org is required!}
  local REPO_NAME=${2:?Repo name is required!}
  local COMMIT_REF=${3:?Commit ref is required!}

  local ENDPOINT="/repos/$ORG/$REPO_NAME/commits/$COMMIT_REF"

  local -ir RETRY=3
  local -ir RETRY_INTERVAL=3
  local RESULT
  local OUTPUT

  for i in $(seq 1 "$RETRY"); do
    if [[ $i -gt 1 ]]; then
      sleep "$RETRY_INTERVAL"
    fi

    run "gh api $ENDPOINT 1>/dev/null $(_gtb_mute_stderr)"
    RESULT=$?

    if [[ $RESULT -eq 0 ]]; then
      echo "OK" $ORG
      return 0
    fi
  done

  echo "ERROR" $ORG
  return $RESULT
}

gh_show_org_repo() {
  local ORG=${1:?Org is required!}
  local REPO_NAME=${2:?Repo name is required!}

  local ENDPOINT="/repos/$ORG/$REPO_NAME"
  local OUTPUT="$ORG $REPO_NAME"

  run "gh api $ENDPOINT 1>/dev/null $(_gtb_mute_stderr)"

  local result=$?
  if [[ $result -eq 0 ]]; then
    echo "$ORG" "$REPO_NAME" "$STATUS_FOUND"
  else
    echo "$ORG" "$REPO_NAME" "$STATUS_NOT_FOUND"
  fi

  return $result
}

gh_create_org_repo() {
  local ORG=${1:?Org is required!}
  local REPO_NAME=${2:?Repo name is required!}

  local response=$(run "gh api -X POST /orgs/$ORG/repos -F private=true -F name=$REPO_NAME" | jsonpp)

  if echo $response | grep --silent "\"full_name\": \"$ORG/$REPO_NAME\""; then
    return 0
  fi

  if echo $response | grep --silent '"message": "name already exists on this account"'; then
    return 0
  fi

  error $response
  return 1
}

gh_list_org_invitations() {
  local ORG=${1:?Org is required!}

  run "gh api --paginate '/orgs/$ORG/invitations?per_page=${GTB_PER_PAGE}' $(_gtb_mute_stderr)" |
    jq -jr 'if type == "array" then .[] | .login, " __ORG__  ", .id, " ", .role, " ", .created_at, "\n" else "\n" end' |
    grep -v '^$' |
    sed "s/__ORG__/$ORG/"
}

gh_cancel_org_invitations() {
  local ORG=${1:?Org is required!}

  while read -r LOGIN ORG ID REST; do
    run "gh api -X DELETE /orgs/$ORG/invitations/$ID 2>/dev/null"
    [[ $? -eq 0 ]] && status='✅' || status="❌"
    echo $status $ORG $ID $LOGIN
  done < <(gh_list_org_invitations $ORG)
}

gh_delete_repo() {
  local ORG=${1:?ORG is required!}
  local REPO_NAME=${2:?Repo name is required!}

  local response=$(run "gh api -X DELETE /repos/$ORG/$REPO_NAME 2>/dev/null")

  if [[ "$response" == "" ]]; then
    echo $ORG $REPO_NAME
    return 0
  fi

  if echo $response | grep --silent '"message":"Not Found"'; then
    echo $ORG $REPO_NAME
    return 0
  fi

  error $response
  return 1
}

gh_clone_repo() {
  local ORG=${1:?ORG is required!}
  local REPO_NAME=${2:?Repo name is required!}
  local DIR=${3:?Director is required!}

  run "git clone git@github.com:$ORG/$REPO_NAME $DIR"
}

clone_repo() {
  local repo_name=$1
  local username=$2
  local fullname=$3
  local term_name=$4
  local HOMEWORK_ROOT="$GTB_ROOT/$GTB_TERMS_DIR/$term_name/$repo_name"
  local STUDENT_HOMEWORK_PATH="$HOMEWORK_ROOT/$fullname"
  local STUDENT_HOMEWORK_URL="git@github.com:${username}/${repo_name}.git"

  [[ -d $HOMEWORK_ROOT ]] || run "mkdir -p $HOMEWORK_ROOT"

  run "git clone $STUDENT_HOMEWORK_URL $STUDENT_HOMEWORK_PATH"

  if (($?)); then
    error "Failed to clone repo ${repo_name}.git for student $fullname!"
  fi
}

update_repo() {
  local student_homework_path=$1

  run "cd $student_homework_path"
  run "git checkout master"
  run "git pull --rebase"

  if (($?)); then
    error "Failed to update repo ${student_homework_path}!"
  fi
}

clone_or_update_repo() {
  local repo_name=$1
  local fullname=$3
  local term_name=$4
  local HOMEWORK_ROOT="$GTB_ROOT/$GTB_TERMS_DIR/$term_name/$repo_name"
  local STUDENT_HOMEWORK_PATH="$HOMEWORK_ROOT/$fullname"

  if [[ -d $STUDENT_HOMEWORK_PATH ]] && [[ "$AUTO_UPDATE" == "true" ]]; then
    update_repo $STUDENT_HOMEWORK_PATH
  elif [[ -d $STUDENT_HOMEWORK_PATH ]] && [[ "$AUTO_UPDATE" != "true" ]]; then
    info "Repo ${repo_name} for student $fullname has already been downloaded."
  else
    clone_repo "$@"
  fi
}

clone_or_update_repos() {
  local student_lines=$(_gtb_filter_students "$@")
  local students_count=$(_gtb_count_lines "$student_lines")
  assert_not_empty "error: cannot find any students with filters: '$@'!" "$student_lines"

  echo "$student_lines" |
    _gtb_cuts 1-4 |
    env_parallel \
      --tagstring "$REPO_NAME {1}" \
      --linebuffer \
      --jobs $JOBS \
      --colsep ' ' \
      $GTB_PARALLEL_OPT_PROGRESS_BAR \
      clone_or_update_repo $REPO_NAME "{2}" "{1}" "{3}"
}

assert_not_empty() {
  if [[ -z "$2" ]]; then
    fail "$1"
  fi
}

assert_assignment_submissions_file_exists() {
  if [[ ! -f $GTB_ASGMT_SUB_FILE ]]; then
    error "Cannot find file: '$GTB_ASGMT_SUB_FILE'."
    exit 1
  fi
}

assert_trainers_file_exists() {
  if [[ ! -f $GTB_TRAINERS_FILE ]]; then
    error "Cannot find trainers file: '$GTB_TRAINERS_FILE'."
    error "If you upgrade from the old versions, please run \`gtb init\` to clone config repo."
    exit 1
  fi
}

assert_buddies_file_exists() {
  if [[ ! -f $GTB_BUDDIES_FILE ]]; then
    error "Cannot find buddies file: '$GTB_BUDDIES_FILE'."
    error "If you upgrade from the old versions, please run \`gtb init\` to clone config repo."
    exit 1
  fi
}

assert_students_file_exists() {
  if [[ ! -f $GTB_STUDENTS_FILE ]]; then
    error "Cannot find students file: '$GTB_STUDENTS_FILE'."
    error "If you upgrade from the old versions, please run \`gtb init\` to clone config repo."
    exit 1
  fi
}

assert_eot_feedback_submission_file_exists() {
  if [[ ! -f $GTB_EOT_FEEDBACK_SUBMISSIONS_FILE ]]; then
    error "Cannot find EOT feedbacks file: '$GTB_EOT_FEEDBACK_SUBMISSIONS_FILE'."
    error "If you upgrade from the old versions, please run \`gtb init\` to clone config repo."
    exit 1
  fi
}

assert_value_exists_in_file() {
  local -r FILENAME="${1:? filename is required!}"
  local -r FIELD="${2:?1-based field number is required!}"
  local -r VALUE="${3:?value is required!}"

  if [[ -z "$(awk -v FIELD="$FIELD" -v VALUE="$VALUE" '$FIELD == VALUE' $FILENAME)" ]]; then
    fail "error: value '$VALUE' not found on field '$FIELD' in file '$(basename $FILENAME)'!"
  fi
}

assert_value_is_uniq_in_file() {
  local -r FILENAME="${1:? filename is required!}"
  local -r FIELD="${2:?1-based field number is required!}"
  local -r VALUE="${3:?value is required!}"

  if [[ -n "$(awk -v FIELD="$FIELD" -v VALUE="$VALUE" '$FIELD == VALUE' $FILENAME)" ]]; then
    fail "error: value '$VALUE' already exists on field '$FIELD' in file '$(basename $FILENAME)'!"
  fi
}

_gtb_trainer_username() {
  local -r FILTER=${1:?Filter is required! (e.g. zhang.san, li.si, etc.)}
  local -r FLAG_RAW="$GTB_RAW"
  local -r FLAG_LINE_NUMBERS="$GTB_LINE_NUMBERS"

  GTB_RAW="true"
  GTB_LINE_NUMBERS="false"
  _gtb_trainer_show "$FILTER" | sed -n '2p'
  GTB_RAW="$FLAG_RAW"
  GTB_LINE_NUMBERS="$FLAG_LINE_NUMBERS"
}

_gtb_trainer_show() {
  local -r FILTER=${1:?filter is required! (e.g. zhang.san, li.si, etc.)}

  local -r FILTERED_LINES=$(_gtb_filter_trainers "${FILTER}")
  local -r COUNT=$(_gtb_count_lines "$FILTERED_LINES")
  if [[ 1 -ne $COUNT ]]; then
    error "error: $COUNT lines filtered with filter: '${FILTER}', should match exactly one line!"
    return 1
  fi

  echo "$FILTERED_LINES" |
    tr ' ' '\n' |
    _gtb_table_format
}

_gtb_trainer_list() {
  _gtb_filter_trainers "$@" |
    _gtb_sort "${GTB_SORT_ORDER:-1,1}" |
    _gtb_cuts "${GTB_FIELDS:-1-}" |
    _gtb_table_format
}

_gtb_trainer() {
  assert_trainers_file_exists

  _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_report() {
  assert_students_file_exists
  assert_assignment_submissions_file_exists

  source "gtbreport"
  _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_rp() {
  _gtb_report "$@"
}

_gtb_assignment() {
  assert_students_file_exists
  assert_assignment_submissions_file_exists

  source "gtbassignment"
  source "gtbtrello"

  _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_assign() {
  _gtb_assignment "$@"
}

_gtb_asgmt() {
  _gtb_assignment "$@"
}

_gtb_as() {
  _gtb_assignment "$@"
}

_gtb_buddy() {
  source "gtbbuddy"

  _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_feedback() {
  assert_students_file_exists
  assert_eot_feedback_submission_file_exists

  source "gtbfeedback"

  _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_bu() {
  _gtb_buddy "$@"
}

_gtb_b() {
  _gtb_buddy "$@"
}

_gtb_fd() {
  _gtb_feedback "$@"
}

_gtb_buddy_field() {
  source "gtbbuddy"

  _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_buddy_f() {
  _gtb_buddy_field "$@"
}

_git_list_all_branches_of_remote() {
  local REMOTE_NAME=${1:?Remote name is required!}
  local BRANCH_NAMES=$(run "git branch -r --no-color --list '${REMOTE_NAME}/*' $(_gtb_mute_stderr) | grep -wv 'HEAD' | tr -d '\t ' | cut -d'/' -f2")
  # ensure master/main branch is the first branch in list
  echo "$BRANCH_NAMES" | grep --color=never -wE 'master|main' | sort -r
  echo "$BRANCH_NAMES" | grep --color=never -vwE 'master|main' | sort
}

_gtb_git_verify_refs() {
  local REPO_NAME=${1:?Repo name is required!}
  local GTB_REFS=${2:-}

  if [[ -z "$GTB_REFS" ]]; then
    return
  fi

  _gtb_clone_default_repo $REPO_NAME

  run "cd $(_gtb_default_repo_dir $REPO_NAME)"

  local REFS=$(echo "$GTB_REFS" | tr ',' ' ' | tr -s ' ')
  local commits_to_pick=''

  for ref in $REFS; do
    if _gtb_is_valid_git_ref $ref; then
      commits_to_pick="$commits_to_pick $ref"
    fi
  done

  if [[ -z "$commits_to_pick" ]]; then
    return
  fi

  echo "$commits_to_pick" | sed -E 's/^ +//g'
}

_gtb_is_valid_git_ref() {
  local REF=${1:?Ref is required!}

  run "git cat-file -t $REF 1>/dev/null 2>&1"
}

_format_repo_time_fields() {
  if [[ "$GTB_LOCAL" != "true" ]]; then
    cat
    return
  fi

  while read -r f1 f2 f3 created_at rest; do
    echo "$f1 $f2 $f3 $(_gtb_time_format_convert_time_zone $created_at)"
  done
}

_gtb_sort() {
  local DEFAULT_SORT_ORDER="${1:?default sort keys are required! (e.g. '9,9nr;2,2')}"
  local FIELD_SEPARATOR="${2}"

  GTB_SORT_ORDER=${GTB_SORT_ORDER:-$DEFAULT_SORT_ORDER}

  local SORT_KEYS=""
  for KEY in $(echo $GTB_SORT_ORDER | tr ';%' ' '); do
    SORT_KEYS="$SORT_KEYS -k${KEY}"
  done

  if [[ -z "$FIELD_SEPARATOR" ]]; then
    cat | LC_ALL=C sort $SORT_KEYS
  else
    cat | LC_ALL=C sort -t"$FIELD_SEPARATOR" $SORT_KEYS
  fi
}

_gtb_count_lines() {
  if [[ -z "$*" ]]; then
    echo 0
    return
  fi
  echo "$*" | wc -l | tr -d ' '
}

_gtb_student() {
  assert_students_file_exists

  source "gtbstudent"
  source "gtbbuddy"
  source "gtbassignment"
  source "gtbtrello"

  _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_stu() {
  _gtb_student "$@"
}

_gtb_st() {
  _gtb_student "$@"
}

remove_repo_from_team() {
  local ORG=$1
  local TEAM=$2
  local REPO=$3
  local ENDPOINT="/orgs/$ORG/teams/$TEAM/repos/$ORG/$REPO"

  run "gh api --silent -X DELETE $ENDPOINT"

  [[ $? -eq 0 ]] && info "DONE" || error "FAILED"
}

_gtb_actions_url() {
  local ORG=${1:?Org is required!}
  local REPO_NAME=${2:?Repo name is required!}

  echo "https://github.com/$ORG/$REPO_NAME/actions"
}

_gtb_push_to_student_repo() {
  local ORG=${1:?Org is required!}
  local REPO_NAME=${2:?Repo name is required!}
  local DST_BRANCH
  local OPTION_FORCE

  cd $(_gtb_default_repo_dir $REPO_NAME)

  local BRANCHES=$(_git_list_all_branches_of_remote 'origin')
  for BRANCH in ${BRANCHES}; do
    if [[ "$GTB_ALL_BRANCHES" == "true" ]] || [[ "${BRANCH}" == "master" ]]; then
      if [[ "$GTB_FORCE" == "true" ]]; then
        DST_BRANCH="_${BRANCH}"
        OPTION_FORCE='--force'
      else
        DST_BRANCH="${BRANCH}"
        OPTION_FORCE=''
      fi
      run "git push $OPTION_FORCE $ORG origin/${BRANCH}:refs/heads/${DST_BRANCH} $(_gtb_mute_stderr)"
    fi
  done

  echo $*
}

_gtb_last_commit_of_branch() {
  local REPO_NAME=${1:?Repo name is required!}
  local BRANCH=${2:?Branch name is required!}
  local REPO_DIR=$(_gtb_default_repo_dir $REPO_NAME)

  [[ -d $REPO_DIR ]] || fail "Cannot find local directory for repo '$REPO_NAME'!"

  cd $REPO_DIR

  if ! git remote | grep --silent "$ORG"; then
    return 0
  fi

  run "git rev-parse $BRANCH"
}

_gtb_remove_remote_student_repo() {
  local REPO_NAME=${1:?Repo name is required!}
  local REPO_DIR=$(_gtb_default_repo_dir $REPO_NAME)

  if [[ ! -d $REPO_DIR ]]; then
    warn 'skip repo that not found in default repo dir.'
    cat | sed "s/$/ $REPO_NAME/"
    return 0
  fi

  run "cd $REPO_DIR"

  while read -r ORG; do
    run "git remote remove $ORG 2>/dev/null"
    echo $ORG $REPO_NAME
  done
}

_gtb_add_student_repo_as_remote() {
  local ORG=${1:?org name is required!}
  local REPO_NAME=${2:?Repo name is required!}

  local REPO_DIR=$(_gtb_default_repo_dir $REPO_NAME)
  [[ -d $REPO_DIR ]] || fail "Cannot find local directory for repo '$REPO_NAME'!"

  run "cd $REPO_DIR"

  local REMOTES=$(run "git remote")

  if ! echo "$REMOTES" | grep --silent "$ORG"; then
    local repo_url="git@github.com:$ORG/${REPO_NAME}.git"
    run "git remote add $ORG $repo_url" >&2
  fi

  if [[ $? -eq 0 ]]; then
    echo "$* $SYMBOL_OK"
  else
    echo "$* $SYMBOL_ERROR"
  fi
}

_gtb_fetch_remote() {
  local REPO_NAME=${1:?Repo name is required!}
  local ORG=${2:?org name is required!}

  local REPO_DIR=$(_gtb_default_repo_dir $REPO_NAME)
  [[ -d $REPO_DIR ]] || fail "Cannot find local directory for repo '$REPO_NAME'!"

  run "cd $REPO_DIR"
  run "git fetch $ORG" >&2

  if [[ $? -eq 0 ]]; then
    echo "$SYMBOL_OK $ORG"
  else
    echo "$SYMBOL_ERROR $ORG"
  fi
}

_gtb_create_local_branch() {
  local REPO_NAME=${1:?Repo name is required!}
  local ORG=${2:?org name is required!}

  local REPO_DIR=$(_gtb_default_repo_dir $REPO_NAME)
  [[ -d $REPO_DIR ]] || fail "Cannot find local directory for repo '$REPO_NAME'!"

  run "cd $REPO_DIR"
  run "git checkout -b $ORG $ORG/master" >&2

  if [[ $? -eq 0 ]]; then
    echo "$SYMBOL_OK $ORG"
  else
    echo "$SYMBOL_ERROR $ORG"
  fi
}

_gtb_pick_refs() {
  local REPO_NAME=${1:?Repo name is required!}
  local ORG=${2:?org name is required!}

  shift 2

  local REPO_DIR=$(_gtb_default_repo_dir $REPO_NAME)
  [[ -d $REPO_DIR ]] || fail "Cannot find local directory for repo '$REPO_NAME'!"

  run "cd $REPO_DIR"
  run "git cherry-pick --abort" >&2
  run "git checkout $ORG" >&2 &&
    run "git cherry-pick --ff --allow-empty --keep-redundant-commits $*" >&2

  if [[ $? -eq 0 ]]; then
    echo "$SYMBOL_OK $ORG"
  else
    run "git cherry-pick --abort" >&2
    echo "$SYMBOL_ERROR $ORG"
  fi
}

_gtb_push_master() {
  local REPO_NAME=${1:?Repo name is required!}
  local ORG=${2:?org name is required!}

  local REPO_DIR=$(_gtb_default_repo_dir $REPO_NAME)
  [[ -d $REPO_DIR ]] || fail "Cannot find local directory for repo '$REPO_NAME'!"

  run "cd $REPO_DIR"
  run "git push $ORG $ORG:master" >&2

  if [[ -n $BRANCH_NAME ]]; then
    run "git push --force $ORG ${ORG}:refs/heads/${BRANCH_NAME}" >&2
  fi

  if [[ $? -eq 0 ]]; then
    echo "$SYMBOL_OK $ORG"
  else
    echo "$SYMBOL_ERROR $ORG"
  fi
}

_gtb_delete_existing_remote() {
  local REPO_NAME=${1:?Repo name is required!}
  local REPO_DIR=$(_gtb_default_repo_dir $REPO_NAME)
  [[ -d $REPO_DIR ]] || fail "Cannot find local directory for repo '$REPO_NAME'!"

  run "cd $REPO_DIR"

  while read -r FULLNAME ORG TERM_NAME; do
    run "git remote remove $ORG 2>/dev/null"
    echo $ORG $REPO_NAME $TERM_NAME $FULLNAME
  done
}

_gtb_create_repo_in_student_org() {
  local ORG=${1:?Org is required!}
  local REPO_NAME=${2:?Repo name is required!}

  gh_create_org_repo $ORG $REPO_NAME
  local result=$?
  if [[ $result -ne 0 ]]; then
    error "Failed to create repo '$REPO_NAME' in '$ORG'."
    return $result
  fi

  echo $*
}

_gtb_clone_default_repo() {
  local REPO_NAME=${1:?Repo name is required!}
  local repo_dir=$(_gtb_default_repo_dir $REPO_NAME)

  [[ -d $repo_dir ]] && run "rm -rf '$repo_dir'"

  gh_clone_repo $GTB_ORG $REPO_NAME $repo_dir

  if [[ $? -ne 0 ]]; then
    fail "Failed to clone repo $REPO_NAME to $repo_dir"
  fi
}

_gtb_update_default_repo() {
  local REPO_NAME=${1:?Repo name is required!}
  local repo_dir=$(_gtb_default_repo_dir $REPO_NAME)

  run "cd $repo_dir"
  run "git fetch origin --prune --prune-tags"
}

_gtb_repo_pick() {
  local REPO_NAME=${GTB_REPO:?repo name should be provided using --repo option.}

  local student_lines=$(_gtb_filter_students "$@")
  local students_count=$(_gtb_count_lines "$student_lines")
  assert_not_empty "error: cannot find any students with filters: '$@'!" "$student_lines"

  header "Verifying refs '$GTB_REFS'..."
  local commits_to_pick=$(_gtb_git_verify_refs "$REPO_NAME" "$GTB_REFS")
  if [[ -z "$commits_to_pick" ]]; then
    fail 'error: no valid commits is to be picked not provided. (e.g. gtb student repo pick --refs "origin/extended-tests" ...)'
  fi

  echo "$student_lines" | _gtb_cuts 3,2,1,7,8,9 | _gtb_table_format
  echo
  echo "$commits_to_pick" | tr ' ' '\n' | _gtb_nl

  if [[ "false" == "$GTB_YES" ]]; then
    read -p "about to pick these refs to above $(red $students_count) students? (y|n) " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
      return 1
    fi
  fi

  header "Clone repo $REPO_NAME..."
  _gtb_clone_default_repo $REPO_NAME

  header "Filter students..."
  local student_lines=$(_gtb_filter_students "$@")
  local students_count=$(_gtb_count_lines "$student_lines")

  [[ $students_count -eq 0 ]] && fail "error: no students matched by filters: '$@'"

  header "Add students' repo as remote..."
  local result_add_remote=$(echo "$student_lines" |
    _gtb_cuts 1-2 |
    env_parallel --jobs 1 --colsep ' ' $GTB_PARALLEL_OPT_PROGRESS_BAR --linebuffer "_gtb_add_student_repo_as_remote {2} $REPO_NAME $(_gtb_mute_stderr)" |
    sort |
    _gtb_cuts 3)

  header "Fetch all remotes..."
  local result_fetch_remote=$(echo "$student_lines" |
    _gtb_cuts 1-2 |
    env_parallel --jobs $JOBS --colsep ' ' $GTB_PARALLEL_OPT_PROGRESS_BAR --linebuffer "_gtb_fetch_remote $REPO_NAME {2} $(_gtb_mute_stderr)" |
    sort -k2 |
    _gtb_cuts 1)

  header "Create local branches..."
  local result_create_branch=$(echo "$student_lines" |
    _gtb_cuts 1-2 |
    env_parallel --jobs 1 --colsep ' ' $GTB_PARALLEL_OPT_PROGRESS_BAR --linebuffer "_gtb_create_local_branch $REPO_NAME {2} $(_gtb_mute_stderr)" |
    sort -k2 |
    _gtb_cuts 1)

  header "Pick refs..."
  local result_pick_ref=$(echo "$student_lines" |
    _gtb_cuts 1-2 |
    env_parallel --jobs 1 --colsep ' ' $GTB_PARALLEL_OPT_PROGRESS_BAR --linebuffer "_gtb_pick_refs $REPO_NAME {2} $commits_to_pick $(_gtb_mute_stderr)" |
    sort -k2 |
    _gtb_cuts 1)

  header "Push to remotes..."
  local result_push_to_remote=$(echo "$student_lines" |
    _gtb_cuts 1-2 |
    env_parallel --jobs $JOBS --colsep ' ' $GTB_PARALLEL_OPT_PROGRESS_BAR --linebuffer "_gtb_push_master $REPO_NAME {2} $(_gtb_mute_stderr)" |
    sort -k2 |
    _gtb_cuts 1)

  {
    echo "ID ORG ADD FETCH BRANCH PICK PUSH"
    pr -m -t -s' ' \
      <(echo "$student_lines" | _gtb_cuts 2 | sort) \
      <(echo "$result_add_remote") \
      <(echo "$result_fetch_remote") \
      <(echo "$result_create_branch") \
      <(echo "$result_pick_ref") \
      <(echo "$result_push_to_remote") |
      _gtb_nl
  } | _gtb_table_format -N |
    _gtb_auto_notify
}

_gtb_repo_publish() {
  local REPO_NAME=$1
  shift

  local student_lines=$(_gtb_filter_students "$@")
  local students_count=$(_gtb_count_lines "$student_lines")
  assert_not_empty "error: cannot find any students with filters: '$@'!" "$student_lines"

  echo "$student_lines" | _gtb_cuts 3,2,1,7,8,9 | _gtb_table_format

  if [[ "false" == "$GTB_YES" ]]; then
    read -p "about to publish repo '$(red $REPO_NAME)' to above $(red $students_count) students? (y|n) " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
      return 1
    fi
  fi

  header "Clone repo $REPO_NAME..."
  _gtb_clone_default_repo $REPO_NAME

  local MAX_JOBS=$JOBS
  if [[ $MAX_JOBS -gt 20 ]]; then
    MAX_JOBS=20
  fi

  header "Create repo $REPO_NAME in student's org..."
  echo "$student_lines" | cut -d' ' -f1-3 |
    env_parallel --jobs $JOBS --colsep ' ' $GTB_PARALLEL_OPT_PROGRESS_BAR --linebuffer "_gtb_create_repo_in_student_org {2} $REPO_NAME $(_gtb_mute_stderr) 1>&2"

  header "Add student's repo as remote..."
  echo "$student_lines" | cut -d' ' -f1-3 |
    env_parallel --jobs 1 --colsep ' ' $GTB_PARALLEL_OPT_PROGRESS_BAR --linebuffer "_gtb_add_student_repo_as_remote {2} $REPO_NAME $(_gtb_mute_stderr) 1>&2"

  header "Push commits to student's repo..."
  local result_push=$(echo "$student_lines" | cut -d' ' -f1-3 |
    env_parallel --jobs $JOBS --colsep ' ' $GTB_PARALLEL_OPT_PROGRESS_BAR --linebuffer "_gtb_push_to_student_repo {2} $REPO_NAME $(_gtb_mute_stderr)")

  local RAW="$GTB_RAW"
  GTB_RAW="true"
  header "Check commits of student's repo..."
  local result_of_repo_check=$(_gtb_student_repo_check $REPO_NAME "$@" | sort -k2 | _gtb_cuts 1)
  GTB_RAW="$RAW"

  {
    echo 'No. Student LastCommit'
    pr -m -t -s' ' \
      <(echo "$student_lines" | _gtb_cuts 2 | sort) \
      <(echo "$result_of_repo_check") |
      _gtb_sort "${GTB_SORT_ORDER:-2,2r;1,1}" |
      _gtb_nl
  } | _gtb_table_format -N |
    _gtb_highlight \
      'OK' green \
      'ERROR' red |
    _gtb_auto_notify
}

_gtb_repo_remove() {
  local ORG=${1:?Organization is required!}
  shift
  local TEAM=${1:?Team is required!}
  shift

  if [[ -p /dev/stdin ]]; then
    while read line; do
      for repo in $line; do
        remove_repo_from_team $ORG $TEAM $repo
      done
    done
  fi

  for repo in "$@"; do
    remove_repo_from_team $ORG $TEAM $repo
  done
}

add_repo_to_team() {
  local ORG=$1
  local TEAM=$2
  local REPO=$3
  local ENDPOINT="/orgs/$ORG/teams/$TEAM/repos/$ORG/$REPO"

  run "gh api --silent -X PUT $ENDPOINT -F permission='pull'"

  [[ $? -eq 0 ]] && info "DONE" || error "FAILED"
}

_gtb_repo_add() {
  local TEAM=${1:?Team is required!}
  shift

  if [[ -p /dev/stdin ]]; then
    while read line; do
      for repo in $line; do
        add_repo_to_team $GTB_ORG $TEAM $repo
      done
    done
  fi

  for repo in "$@"; do
    add_repo_to_team $GTB_ORG $TEAM $repo
  done
}

_gtb_repo_list() {
  gh_list_org_repos |
    sort -k2,2 |
    _format_repo_time_fields |
    _gtb_sort '3,3;1,2' |
    _gtb_table_format |
    _gtb_highlight \
      'public' red
}

_gtb_repo_check() {
  local REPO_NAME="${1:?Repo name is required!}"

  gh_show_org_repo "${GTB_ORG}" "${REPO_NAME}" |
    _gtb_highlight \
      "${STATUS_NOT_FOUND}" red
}

_gtb_repo() {
  source "gtbstudent"
  _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_org_team_open() {
  run "open https://github.com/orgs/${GTB_ORG}/teams/${GTB_TERM}/members"
}

_gtb_org_team_invite() {
  GTB_ORG_TEAM="gtb-buddy"

  if [[ "true" == "$GTB_FROM_BUDDIES" ]]; then
    local buddy_lines=$(_gtb_filter_buddies "$@")
    local buddies_count=$(_gtb_count_lines "$buddy_lines")
    assert_not_empty "error: cannot find any buddies with filters: '$@'!" "$buddy_lines"

    echo "$buddy_lines" |
      env_parallel \
        --linebuffer \
        --jobs $JOBS \
        --colsep ' ' \
        $GTB_PARALLEL_OPT_PROGRESS_BAR \
        gh_invite_user_to_team "$GTB_ORG" "$GTB_ORG_TEAM" "{5}" "{2}" |
      _gtb_sort '1,1r;4,4' |
      _gtb_table_format |
      _gtb_tr_symbols
  else
    local student_lines=$(_gtb_filter_students "$@")
    local students_count=$(_gtb_count_lines "$student_lines")
    assert_not_empty "error: cannot find any students with filters: '$@'!" "$student_lines"

    echo "$student_lines" |
      env_parallel \
        --linebuffer \
        --jobs $JOBS \
        --colsep ' ' \
        $GTB_PARALLEL_OPT_PROGRESS_BAR \
        gh_invite_user_to_team "$GTB_ORG" "$GTB_ORG_TEAM" "{4}" "{2}" "{7}" |
      _gtb_sort '1,1r;4,4' |
      _gtb_table_format |
      _gtb_tr_symbols
  fi
}

_gtb_org_team_members() {
  (
    echo 'No. Config Github Student'
    join -1 5 -2 2 -a 1 -a 2 -o '1.1,2.1,0,1.3,1.2,1.6,1.7' -e 'NO' \
      <(_gtb_filter_students | sort -k4 | sed 's/^/YES /') \
      <(gh_list_org_team_members $GTB_ORG $GTB_TERM | sort | sed 's/^/YES /') |
      sort -k1,2 -r |
      _gtb_nl
  ) | _gtb_table_format -N
}

_gtb_org_team_list() {
  local ORG=${1:-$GTB_ORG}
  gh_list_org_teams $ORG
}

_gtb_org_team() {
  if ! echo $1 | grep --silent '^\(list\|open\|invite\|members\)$'; then
    set -- open "$@"
  fi

  _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_org_user() {
  if ! echo $1 | grep --silent '^\(check\)$'; then
    set -- open "$@"
  fi

  _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_org_remove() {
  local student_lines=$(_gtb_filter_students "$@")
  local students_count=$(_gtb_count_lines "$student_lines")

  echo "$student_lines" |
    _gtb_cuts 2,4,7 |
    sort |
    column -t |
    cat -n

  if [[ "false" == "$GTB_YES" ]]; then
    read -p "about to DELETE ${students_count} students from $GTB_ORG? (y|n) " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
      return 1
    fi
  fi

  echo "$student_lines" |
    _gtb_cuts 2,4 |
    env_parallel \
      $GTB_PARALLEL_OPT_PROGRESS_BAR \
      --colsep ' ' \
      --linebuffer \
      --jobs $JOBS \
      gh_remove_user_from_org $GTB_ORG {2}
}

_gtb_org_invite() {
  if [[ "true" == "$GTB_FROM_BUDDIES" ]]; then
    local buddy_lines=$(_gtb_filter_buddies "$@")
    local buddies_count=$(_gtb_count_lines "$buddy_lines")
    assert_not_empty "error: cannot find any buddies with filters: '$@'!" "$buddy_lines"

    echo "$buddy_lines" |
      env_parallel \
        --linebuffer \
        --jobs $JOBS \
        --colsep ' ' \
        $GTB_PARALLEL_OPT_PROGRESS_BAR \
        gh_invite_user_to_org "$GTB_ORG" "{5}" 'direct_member' "{1}" "{2}" |
      _gtb_sort '1,1r;5,5' |
      _gtb_table_format |
      _gtb_tr_symbols
  else
    local student_lines=$(_gtb_filter_students "$@")
    local students_count=$(_gtb_count_lines "$student_lines")
    assert_not_empty "error: cannot find any students with filters: '$@'!" "$student_lines"

    echo "$student_lines" |
      env_parallel \
        --linebuffer \
        --jobs $JOBS \
        --colsep ' ' \
        $GTB_PARALLEL_OPT_PROGRESS_BAR \
        gh_invite_user_to_org "$GTB_ORG" "{4}" 'direct_member' "{1}" "{7}" |
      _gtb_sort '1,1r;5,5' |
      _gtb_table_format |
      _gtb_tr_symbols
  fi
}

_gtb_org_members() {
  (
    echo 'No. Config Github Student'
    join -1 5 -2 2 -a 1 -o '1.1,2.1,0,1.3,1.2,1.6,1.7' -e 'NO' \
      <(_gtb_filter_students | sort -k4 | sed 's/^/YES /') \
      <(gh_list_org_members $GTB_ORG | sort | sed 's/^/YES /') |
      sort -k1,2 -r |
      _gtb_nl
  ) | _gtb_table_format -N
}

_gtb_org_open() {
  local ORG=${1:-$GTB_ORG}
  run "open https://github.com/${ORG}"
}

_gtb_org() {
  assert_students_file_exists

  if ! echo $1 | grep --silent '^\(open\|invite\|remove\|team\|members\|user\)$'; then
    set -- open "$@"
  fi

  _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_feishu() {
  GTB_FEISHU_API='https://open.feishu.cn/open-apis'
  GTB_FEISHU_TOKEN_ENDPOINT='/auth/v3/tenant_access_token/internal'
  GTB_FEISHU_TENANT_ACCESS_TOKEN_FILE="$GTB_USER_CACHE_DIR/.tenant_access_token"

  source "gtbfeishu"

  _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_trello() {
  GTB_TRELLO_API='https://api.trello.com/1'
  GTB_TRELLO_API_KEY="${GTB_TRELLO_API_KEY:?Trello API Key should be set! 'https://trello.com/app-key'}"
  GTB_TRELLO_TOKEN="${GTB_TRELLO_TOKEN:?Trello token should be set! 'https://trello.com/app-key'}"
  GTB_TRELLO_AUTH="&key=$GTB_TRELLO_API_KEY&token=$GTB_TRELLO_TOKEN"
  GTB_TRELLO_USERNAME="${GTB_TRELLO_USERNAME:?Trello username should be set! 'Avatar -> Profile and visibility -> About -> Username'}"

  source "gtbtrello"
  source "gtbcache"

  _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_tr() {
  _gtb_trello "$@"
}

_gtb_fs() {
  _gtb_feishu "$@"
}

_gtb_github() {
  source "gtbgithub"
  _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_gh() {
  _gtb_github "$@"
}

_gtb_cache() {
  source "gtbcache"
  _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_tag_stat() {
  local POSITION=${1:?Tag position, starts from 1, is required!}
  shift

  local total_fields=$(head -n1 $GTB_STUDENTS_FILE | wc -w)

  if [[ "$POSITION" -lt 1 ]] || [[ "$POSITION" -gt $total_fields ]]; then
    fail "error: position '$POSITION' is out of range."
  fi

  GTB_RAW="true"

  _gtb_student_list "$@" | _gtb_count "$POSITION"
}

_gtb_tag_remove() {
  local POSITION=${1:?Tag position, starts from 1, is required!}

  local total_fields=$(head -n1 $GTB_STUDENTS_FILE | wc -w)

  if [[ "$POSITION" -lt 1 ]] || [[ "$POSITION" -gt $total_fields ]]; then
    fail "error: position '$POSITION' is out of range."
  fi

  local BACKUP_FILE="/tmp/${GTB_STUDENTS_FILE##*/}"
  run "cp $GTB_STUDENTS_FILE $BACKUP_FILE"

  [[ -f "$BACKUP_FILE" ]] || fail "error: cannot backup students file to '$BACKUP_FILE'."

  local fields=$(seq 1 $total_fields | tr '\n' ',' | sed "s/${POSITION},//" | sed 's/,$//')
  run "cat $BACKUP_FILE | cut -d' ' -f${fields} > $GTB_STUDENTS_FILE"

  _gtb_config_diff "$GTB_STUDENTS_FILE"
}

_gtb_tag_replace() {
  local FROM_TAG=${1:?Source tag is required!}
  local TO_TAG=${2:?Target tag is required!}
  shift 2

  local student_lines=$(_gtb_filter_students "$@")

  if ! grep -w --color --silent "$FROM_TAG" <(echo "$student_lines") 1>&2; then
    fail 'error: source tag not found, please make sure you are using the correct value.'
  fi

  if grep -w --color "$TO_TAG" <(echo "$student_lines") 1>&2; then
    fail 'error: new tag conficts with existing entires shown as above, please change a new one.'
  fi

  echo "$student_lines" |
    _gtb_cuts 1 |
    env_parallel --linebuffer --jobs 1 $GTB_PARALLEL_OPT_PROGRESS_BAR "sed -i.bak -E '/{}/s/[[:<:]]$FROM_TAG[[:>:]]/$TO_TAG/g' $GTB_STUDENTS_FILE"

  _gtb_config_diff "$GTB_STUDENTS_FILE"
}

_gtb_tag_add() {
  local TAG=${1:?Tag is required!}

  if grep -w --color "$TAG" "$GTB_STUDENTS_FILE" 1>&2; then
    fail 'error: new tag conficts with existing entires shown as above, please change a new one.'
  fi

  local total_fields=$(head -n1 $GTB_STUDENTS_FILE | wc -w)
  local POSITION=${GTB_POSITION:-$((total_fields + 1))}

  if [[ "$POSITION" -le 1 ]]; then
    run "sed -i.bak 's/^/$TAG /g' $GTB_STUDENTS_FILE"
  elif [[ "$POSITION" -gt $total_fields ]]; then
    run "sed -i.bak 's/$/ $TAG/g' $GTB_STUDENTS_FILE"
  else
    local BACKUP_FILE="/tmp/${GTB_STUDENTS_FILE##*/}"
    run "cp $GTB_STUDENTS_FILE $BACKUP_FILE"

    [[ -f "$BACKUP_FILE" ]] || fail "error: cannot backup students file to '$BACKUP_FILE'."

    paste -d ' ' \
      <(cat $BACKUP_FILE | _gtb_cuts "1-$((POSITION - 1))") \
      <(jot -n -b "$TAG" $(wc -l $BACKUP_FILE)) \
      <(cat $BACKUP_FILE | _gtb_cuts "$((POSITION))-") \
      >$GTB_STUDENTS_FILE
  fi

  _gtb_config_diff "$GTB_STUDENTS_FILE"
}

_gtb_tag_index() {
  head -n1 $GTB_STUDENTS_FILE | _gtb_student_show_format
}

_gtb_tag() {
  assert_students_file_exists

  if ! echo $1 | grep --silent '^\(index\|add\|replace\|remove\|stat\)$'; then
    set -- index "$@"
  fi
  source "gtbstudent"
  _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_config_pull() {
  run "git -C '$GTB_CONFIG_DIR' pull --rebase --autostash"
}

_gtb_config_push() {
  run "cd '$GTB_CONFIG_DIR'"
  run "git pull --rebase --autostash"
  run "git push"
}

_gtb_config_commit() {
  _gtb_config_add
  run "git -C ${GTB_CONFIG_DIR} commit --allow-empty -m '$*'"
}

_gtb_config_add() {
  run "git -C ${GTB_CONFIG_DIR} add students-*.txt trainers.txt buddies-*.txt assignment-*.txt eot-*.txt feedbacks-${GTB_TERM}"
}

_gtb_config_show() {
  local TERM_NAME=${1:-$GTB_TERM}
  less -N "$GTB_CONFIG_DIR/students-${TERM_NAME}.txt"
}

_gtb_config_edit() {
  local TERM_NAME=${1:-$GTB_TERM}
  vim "$GTB_CONFIG_DIR/students-${TERM_NAME}.txt"
}

_gtb_config_checkout() {
  run "git -C ${GTB_CONFIG_DIR} checkout ."
}

_gtb_config_status() {
  run "git -C ${GTB_CONFIG_DIR} status"
}

_gtb_config_diff() {
  local FILES="${1:-.}"
  run "cd '$GTB_CONFIG_DIR'"
  run "git --no-pager diff --stat $FILES"
  run "git --no-pager diff --color-words $FILES"
}

_gtb_config_diffcheck() {
  run "cd '$GTB_CONFIG_DIR'"
  run "git --no-pager diff --exit-code"
}

_gtb_config_list() {
  run "cd '$GTB_CONFIG_DIR'"
  run 'ls -l students*.txt'
}

_gtb_config_dir() {
  echo "$GTB_CONFIG_DIR"
}

_gtb_config() {
  [[ -d $GTB_CONFIG_DIR ]] || fail 'Cannot find config directory `$GTB_CONFIG_DIR`. Please run `gtb init`.'

  _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_colors() {
  # for bg_color in {0..$(tput colors)}; do
  for bg_color in $(seq 0 $(tput colors)); do
    tput setaf 231
    tput setab $bg_color
    printf "  %3d  " $bg_color
    if [[ $(($bg_color % 8)) -eq 0 ]]; then
      tput sgr0
      printf "\n"
    fi
  done
}

_gtb_upgrade() {
  if [[ "false" == "$GTB_YES" ]]; then
    read -p "Are you SURE to upgrade to lastest version? (y|n) " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
      return 1
    fi
  fi

  run "brew update && brew install --ignore-dependencies GTB-training/gtb/util"
}

_gtb_update() {
  _gtb_config_pull "$@"
}

_gtb_init() {
  mkdir -p $GTB_ROOT/$GTB_REPOS_DIR
  mkdir -p $GTB_ROOT/$GTB_TERMS_DIR
  mkdir -p $GTB_ROOT/$GTB_FEEDBACKS_DIR
  mkdir -p $GTB_USER_CACHE_DIR

  if [[ -d $GTB_CONFIG_DIR ]]; then
    warn "warn: '$GTB_CONFIG_DIR' already exists!"
    return
  fi

  gh_clone_repo $GTB_ORG $GTB_CONFIG_REPO $GTB_CONFIG_DIR
}

_gtb_term() {
  echo $GTB_TERM
}

_gtb_version() {
  echo "gtb $VERSION"
  exit 0
}

_gtb_help() {
  echo "Please refer to the README doc:"
  info "https://github.com/GTB-training/util/blob/master/README.md"
  exit 0
}

OPTIND=1

JOBS=${GTB_DEFAULT_JOBS:-30}
AUTO_UPDATE="false"
AUTO_BUILD="false"
AUTO_ACCEPT="true"
AUTO_TEST="false"
CHECK_ROLE_ONLY="false"

shopt -s extglob

declare -a PARAMS

while (("$#")); do
  case "$1" in
  --jobs)
    if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
      JOBS=$2
      shift 2
    else
      fail "Error: Argument for $1 is missing"
    fi
    ;;
  --branch)
    if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
      BRANCH_NAME=$2
      shift 2
    else
      fail "Error: branch name specified by '$1' is missing"
    fi
    ;;
  --username)
    if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
      GTB_TRELLO_USERNAME=$2
      GTB_USERNAME=$2
      shift 2
    else
      fail "Error: Username specified by '$1' is missing"
    fi
    ;;
  --board)
    if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
      GTB_TRELLO_BOARD_NAME=$2
      shift 2
    else
      fail "Error: Trello board name specified by '$1' is missing"
    fi
    ;;
  --list)
    if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
      GTB_TRELLO_LIST_NAME=$2
      shift 2
    else
      fail "Error: Trello list name specified by '$1' is missing"
    fi
    ;;
  --card-id)
    if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
      GTB_TRELLO_CARD_ID=$2
      shift 2
    else
      fail "Error: Trello card ID specified by '$1' is missing"
    fi
    ;;
  --card-name)
    if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
      GTB_TRELLO_CARD_NAME=$2
      shift 2
    else
      fail "Error: Trello card name specified by '$1' is missing"
    fi
    ;;
  --name)
    if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
      GTB_TRELLO_CARD_NAME=$2
      shift 2
    else
      fail "Error: Trello card name specified by '$1' is missing"
    fi
    ;;
  --desc)
    if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
      GTB_TRELLO_CARD_DESC=$2
      shift 2
    else
      fail "Error: Trello card description specified by '$1' is missing"
    fi
    ;;
  --members)
    if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
      GTB_TRELLO_CARD_MEMBERS=$2
      shift 2
    else
      fail "Error: Trello card members specified by '$1' is missing"
    fi
    ;;
  --due-in-days)
    if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
      GTB_TRELLO_CARD_DUE_IN_DAYS=$2
      shift 2
    else
      fail "Error: Trello card due in days specified by '$1' is missing"
    fi
    ;;
  --type)
    if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
      GTB_TRELLO_MEMBER_TYPE=$2
      shift 2
    else
      fail "Error: Trello member type specified by '$1' is missing"
    fi
    ;;
  -f | --fields)
    if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
      GTB_FIELDS=$2
      shift 2
    else
      fail "Error: Fields to display specified by '$1' is missing"
    fi
    ;;
  --position)
    if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
      GTB_POSITION=$2
      shift 2
    else
      fail "Error: Position of new tag specified by '$1' is missing"
    fi
    ;;
  --pk)
    if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
      GTB_PK=$2
      shift 2
    else
      fail "Error: primary key specified by '$1' is missing"
    fi
    ;;
  --step)
    if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
      GTB_STEP=$2
      shift 2
    else
      fail "Error: step name specified by '$1' is missing"
    fi
    ;;
  --org)
    if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
      GTB_ORG_NAME=$2
      shift 2
    else
      fail "Error: GitHub org name specified by '$1' is missing"
    fi
    ;;
  --repo)
    if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
      GTB_REPO=$2
      shift 2
    else
      fail "Error: repository name specified by '$1' is missing"
    fi
    ;;
  --refs)
    if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
      GTB_REFS=$2
      shift 2
    else
      fail "Error: refs to pick specified by '$1' is missing, comma separated, e.g. origin/extended-tests,origin/fix"
    fi
    ;;
  --start)
    if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
      GTB_START_AT=$2
      shift 2
    else
      fail "Error: evaluation start_at time specified by '$1' is missing, e.g. 2021041609"
    fi
    ;;
  --basic)
    if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
      GTB_DURATION_BASIC=$2
      shift 2
    else
      fail "Error: evaluation basic part duration specified by '$1' is missing, e.g. 8h, 10h, 7d, 14d"
    fi
    ;;
  --refactor)
    if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
      GTB_DURATION_REFACTOR=$2
      shift 2
    else
      fail "Error: evaluation refactor part duration specified by '$1' is missing, e.g. 14d, 21d, 8h, 10h"
    fi
    ;;
  --sort)
    if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
      GTB_SORT_ORDER=$2
      shift 2
    else
      fail "Error: column to sort with specified by '$1' is missing, e.g. total, evaluation, homework, performance, '1,1nr;2,2'"
    fi
    ;;
  --team)
    if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
      GTB_ORG_TEAM="$2"
      shift 2
    else
      fail "Error: GitHub org's team name specified by '$1' is missing"
    fi
    ;;
  --trainer)
    if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
      GTB_TRAINER_FILTER="$2"
      shift 2
    else
      fail "Error: trainer filter specified by '$1' is missing"
    fi
    ;;
  --buddy)
    if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
      GTB_BUDDY_FILTER="$2"
      shift 2
    else
      fail "Error: buddy filter specified by '$1' is missing"
    fi
    ;;
  -s)
    if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
      GTB_TABLE_FORMAT_SEPARATOR="$2"
      shift 2
    else
      fail "Error: separator specified by '$1' is missing"
    fi
    ;;
  --print)
    if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
      GTB_HTTP_PRINT="$2"
      shift 2
    else
      fail "Error: httpie --print WHAT specified by '$1' is missing, e.g. HBhb"
    fi
    ;;
  --method)
    if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
      GTB_HTTP_METHOD="$2"
      shift 2
    else
      fail "Error: HTTP method specified by '$1' is missing"
    fi
    ;;
  --start-num)
    if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
      GTB_START_NUM="$2"
      shift 2
    else
      fail "Error: index start number specified by '$1' is missing"
    fi
    ;;
  --chunk)
    if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
      GTB_CHUNK="$2"
      shift 2
    else
      fail "Error: CHUNK specified by '$1' is missing, e.g. 1/10, 3/24"
    fi
    ;;
  --from-stdin)
    GTB_FROM_STDIN="true"
    shift
    ;;
  --from-students)
    GTB_FROM_STUDENTS="true"
    shift
    ;;
  --from-buddies)
    GTB_FROM_BUDDIES="true"
    shift
    ;;
  --from-trainers)
    GTB_FROM_TRAINERS="true"
    shift
    ;;
  --by-buddy)
    GTB_LIST_BY_BUDDY="true"
    shift
    ;;
  --by-buddee)
    GTB_LIST_BY_BUDDEE="true"
    shift
    ;;
  --all)
    GTB_ALL_BRANCHES="true"
    shift
    ;;
  --local)
    GTB_LOCAL="true"
    shift
    ;;
  --notify)
    GTB_NOTIFY="true"
    shift
    ;;
  --yes)
    GTB_YES="true"
    shift
    ;;
  --quit-employee)
    GTB_QUIT_EMPLOYEE="true"
    shift
    ;;
  --raw)
    GTB_RAW="true"
    shift
    ;;
  --force)
    GTB_FORCE="true"
    shift
    ;;
  -N | --no-line-numbers)
    GTB_LINE_NUMBERS="false"
    shift
    ;;
  -D | --debug)
    GTB_DEBUG="true"
    shift
    ;;
  -u | --update)
    AUTO_UPDATE="true"
    shift
    ;;
  -b | --build)
    AUTO_BUILD="true"
    shift
    ;;
  -l | --list)
    AUTO_ACCEPT="false"
    shift
    ;;
  -t | --test)
    AUTO_TEST="true"
    shift
    ;;
  --role)
    CHECK_ROLE_ONLY="true"
    shift
    ;;
  -+([0-9])[dHMS])
    PARAMS+=("$1")
    shift
    ;;
  -* | --*=)
    fail "Unsupported flag $1"
    shift
    ;;
  *)
    PARAMS+=("$1")
    shift
    ;;
  esac
done

set -- "${PARAMS[@]}"

source $(which env_parallel.bash)

SUBCOMMAND=${1:?Subcommand is required! (e.g. init, clone, build, update, join, test, up, down, check, show, help.)}
shift

# main method starts from here...
if [[ "$(type -t ${SUBCMD_PREFIX}_$SUBCOMMAND)" != 'function' ]]; then
  error "Subcommand \`$SUBCOMMAND\` is INVALID!"
  exit 2
fi

${SUBCMD_PREFIX}_${SUBCOMMAND} "$@"
