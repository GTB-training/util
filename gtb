#!/bin/bash

GTB_ROOT="${GTB_ROOT:-$HOME/code/gtb}"
GTB_TERM="${GTB_TERM:?GTB_TERM should be set! (term01, term02, etc.)}"
GTB_CONFIG_REPO=config
GTB_CONFIG_DIR="$GTB_ROOT/$GTB_CONFIG_REPO"
GTB_TRAINERS_FILE="${GTB_TRAINERS_FILE:-$GTB_CONFIG_DIR/trainers.txt}"
GTB_STUDENTS_FILE_DEFAULT="${GTB_CONFIG_DIR}/students.txt"
GTB_STUDENTS_FILE_TERM="${GTB_CONFIG_DIR}/students-${GTB_TERM}.txt"

if [[ -f $GTB_STUDENTS_FILE ]]; then
    GTB_STUDENTS_FILE=$GTB_STUDENTS_FILE
elif [[ -f $GTB_STUDENTS_FILE_TERM ]]; then
    GTB_STUDENTS_FILE=$GTB_STUDENTS_FILE_TERM
elif [[ -f $GTB_STUDENTS_FILE_DEFAULT ]]; then
    GTB_STUDENTS_FILE=$GTB_STUDENTS_FILE_DEFAULT
fi

GTB_MAX_RETRY_TIMES_REPO_PICK="${GTB_MAX_RETRY_TIMES_REPO_PICK:-3}"
GTB_DASHBOARD_ADDRESS="${GTB_DASHBOARD_ADDRESS:?Please set env GTB_DASHBOARD_ADDRESS correctly! (P.S. Ask ZHANG Zhe)}"
GTB_SONAR_ADDRESS="${GTB_SONAR_ADDRESS:?Please set env GTB_SONAR_ADDRESS correctly! (P.S. Ask ZHANG Zhe)}"
GTB_SONAR_TOKEN="${GTB_SONAR_TOKEN:?Please set env GTB_SONAR_TOKEN correctly! (P.S. Ask ZHANG Zhe)}"
GTB_RANDOM_LIST_FILE="/tmp/gtb_random_list.txt"
GTB_EXCLUDE_DIRS=( --exclude-dir '.git' --exclude-dir 'build' --exclude-dir 'gradle' --exclude-dir 'node_modules' --exclude-dir 'dist' --exclude-dir '.cache' )
GTB_REPOS_DIR="repos"
GTB_TERMS_DIR="terms"
SUBCMD_PREFIX='_gtb'
GTB_DEFAULT_REPO_ROOT="${GTB_DEFAULT_REPO_ROOT:-$GTB_ROOT/$GTB_REPOS_DIR/default}"
GTB_PER_PAGE=100

GTB_ORG=tws-graduate-program

GTB_TRELLO_API='https://api.trello.com/1'

SUBCOMMAND=${1:?Subcommand is required! (e.g. init, clone, build, update, join, test, up, down, check, show, help.)}
shift

cuts() {
    cat | cut -d' ' "$@"
}

info() {
    echo "$(tput setaf 4)$(tput bold)$*$(tput sgr 0)"
}

warn() {
    echo "$(tput setaf 3)$(tput bold)$*$(tput sgr 0)"
}

error() {
    echo "$(tput setaf 1)$(tput bold)$*$(tput sgr 0)" >&2
}

debug() {
    echo "$(tput setaf 5)$(tput bold)$*$(tput sgr 0)"
}

run() {
    echo "$(tput setaf 22)$*$(tput sgr 0)" 1>&2
    eval $*
}

header() {
    tput setaf 15
    tput setab 8
    printf "%-80s" "$*" 1>&2
    tput sgr0
    printf "\n" 1>&2
}

logt() {
    local fg_color=$1
    local bg_color=$2
    shift 2
    echo "$(tput setab $bg_color)$(tput setaf $fg_color)$*$(tput sgr 0)"
}

logtf() {
    local fg_color=$1
    shift
    echo "$(tput setaf $fg_color)$*$(tput sgr 0)"
}

logtb() {
    local bg_color=$1
    shift
    echo "$(tput setab $bg_color)$*$(tput sgr 0)"
}

logtn() {
    local fg_color=$1
    local bg_color=$2
    shift 2
    echo -n "$(tput setab $bg_color)$(tput setaf $fg_color)$*$(tput sgr 0)"
}

fail() {
    error $*
    exit 1
}

strip_colors() {
    while read -r line
    do
        echo "$line" | \
            sed $'s,\x1b\\[[0-9;]*[a-zA-Z],,g'
    done
}

_gtb_urlencode() {
    node --eval "console.log(encodeURIComponent(process.argv[1]))" "$*"
}

_gtb_tee1() {
    cat | tee /dev/tty
}

_gtb_tabularize() {
    if [[ -z "$*" ]]; then
        cat | column -s'|' -t
    else
        cat | column -s'|' -t | sed $'1s:^:\\\n'"==> $1"$'\\\n:'
    fi
}

_gtb_pv() {
    cat | pv -tbelSs $1 -i 0.3 -N "total is: $1 current is"
}

_gtb_default_repo_dir() {
    local REPO_NAME=${1:?Repo name is required!}
    echo "$GTB_DEFAULT_REPO_ROOT/$REPO_NAME"
}

_gtb_run_subcommand() {
    COMMAND=${1:?Command is required! (e.g. repo, student.)}
    shift
    SUBCOMMAND=${1:?Subcommand is required! (e.g. list, add, remove.)}
    shift

    local subcommand_function="_gtb_${COMMAND}_${SUBCOMMAND}"

    if [[ "$(type -t $subcommand_function)" != 'function' ]]; then
        fail "error: Unknown subcommand: $SUBCOMMAND"
    fi

    $subcommand_function "$@"
}

gh_user_id() {
    local USERNAME=${1:?username is required!}
    run "gh api /users/${USERNAME} 2>/dev/null" | jsonpp | \
        grep '"\(id\)"' | \
        tr -d ' ,' | \
        cut -d':' -f2
}

gh_invite_user_to_org() {
    local ORG=${1:?org is required!}
    local USERNAME=${2:?username is required!}
    local ROLE=${3:-direct_member}
    gh_create_invitation $ORG $(gh_user_id $USERNAME) $ROLE
}

gh_invite_user_to_team() {
    local ORG=${1:?org is required!}
    local TEAM=${2:?team is required!}
    local USERNAME=${3:?username is required!}
    gh api -X PUT "/orgs/${ORG}/teams/${TEAM}/memberships/${USERNAME}" 2>/dev/null
}

gh_membership() {
    local ORG=${1:?org is required!}
    local USERNAME=${2:?username is required!}
    run "gh api '/orgs/${ORG}/memberships/${USERNAME}' 2>/dev/null" | jsonpp
}

gh_set_org_membership() {
    local ORG=${1:?org is required!}
    local USERNAME=${2:?username is required!}
    local ROLE=${3:?role is required!(admin|member)}

    run "gh api -X PUT '/orgs/${ORG}/memberships/${USERNAME}' -F role='$ROLE' 2>/dev/null" \
        | jsonpp \
        | grep '^  "\(state\|role\)":' \
        | tr -d '" ,' \
        | sed 's/:/|/' \
        | cut -d'|' -f2 \
        | paste -d ' ' - - \
        | sed "s/^/$ORG $USERNAME /"
}

gh_is_pending() {
    cat | grep --silent '"state": "pending"'
}

gh_is_active() {
    cat | grep --silent '"state": "active"'
}

gh_is_active_admin() {
    cat | grep -A1 '"state": "active"' | grep --silent '"role": "admin"'
}

gh_is_active_member() {
    cat | grep -A1 '"state": "active"' | grep --silent '"role": "member"'
}

gh_is_pending_admin() {
    cat | grep -A1 '"state": "pending"' | grep --silent '"role": "admin"'
}

gh_is_pending_member() {
    cat | grep -A1 '"state": "pending"' | grep --silent '"role": "member"'
}

gh_is_invitation_created() {
    cat | grep --silent '"created_at":'
}

gh_is_already_part_of_this_org() {
    cat | grep --silent 'Invitee is already a part of this org'
}

gh_is_team_member_invited() {
    cat | grep --silent '"role":'
}

gh_create_invitation() {
    local ORG=${1:?Org is required!}
    local INVITEE_ID=${2:?Invitee ID is required!}
    local ROLE=${3:-direct_member}
    run "gh api /orgs/${ORG}/invitations -F role=$ROLE -F invitee_id=$INVITEE_ID 2>/dev/null"
}

gh_list_org_teams() {
    local ORG=${1:-$GTB_ORG}
    local ENDPOINT="/orgs/$ORG/teams"

    gh api $ENDPOINT 2>/dev/null | jsonpp | \
        grep '    "name":' | \
        tr -d '" ,' | \
        cut -d':' -f2 | \
        sort
}

gh_list_org_team_members() {
    local ORG=${1:?Organization is required!}
    local TEAM=${2:?Team is required!}
    local ENDPOINT="/orgs/${ORG}/teams/${TEAM}/members?per_page=100"

    run "gh api $ENDPOINT 2>/dev/null" | jsonpp | \
        grep '    "login":' | \
        tr -d '" ,' | \
        cut -d':' -f2 | \
        sort
}

gh_list_org_members() {
    local ORG=${1:?Organization is required!}
    local ENDPOINT="/orgs/${ORG}/members?per_page=$GTB_PER_PAGE&page="

    for page in $(seq 1 10)
    do
        local res=$(run "gh api '${ENDPOINT}${page}' 2>/dev/null" | jsonpp | grep '    "login":')
        local lines_count=$(_gtb_count_lines "$res")
        if [[ $lines_count -gt 0 ]]
        then
            echo "$res"
        fi
        if [[ $lines_count -lt $GTB_PER_PAGE ]]
        then
            break
        fi
    done \
        | tr -d '" ,' \
        | cut -d':' -f2 \
        | sort
}

gh_list_org_repos() {
    local ORG=${1:-$GTB_ORG}
    local TEAM=${2}

    local ENDPOINT="/orgs/$ORG/repos?per_page=100"
    if [[ -n "$TEAM" ]]
    then
        ENDPOINT="/orgs/$ORG/teams/$TEAM/repos?per_page=100"
    fi

    run "gh api $ENDPOINT 2>/dev/null" | jsonpp | \
        grep '    "name":\|    "private":' | \
        tr -d '", ' | \
        cut -d':' -f2 | \
        paste -d' ' - - | \
        sort | \
        sed -e 's/ true$//' -e 's/false$/üü¢/'
}

gh_show_org_repo() {
    local ORG=${1:?Org is required!}
    local REPO_NAME=${2:?Repo name is required!}

    local ENDPOINT="/repos/$ORG/$REPO_NAME"
    local OUTPUT="$ORG $REPO_NAME"

    gh api $ENDPOINT 1>/dev/null 2>&1

    local result=$?
    if [[ $result -eq 0 ]]; then
        echo $OUTPUT
    else
        error $OUTPUT
    fi

    return $result
}

gh_secret_list() {
    local ORG=${1:?Org is required!}
    local REPO_NAME=${2:?Repo name is required!}

    gh secret list -R $ORG/$REPO_NAME 2>/dev/null
}

gh_list_repo_workflow_runs() {
    local ORG=${1:?Org is required!}
    local REPO_NAME=${2:?Repo name is required!}
    local WORKFLOW_FILENAME=${3:?Workflow filename is required!}

    run "gh api /repos/$ORG/$REPO_NAME/actions/workflows/$WORKFLOW_FILENAME/runs?per_page=10 2>/dev/null" | \
        jsonpp | \
        sed -e 's/: "//' -e 's/",//' | \
        sed -e 's/": /"/' -e 's/,$//' | \
        grep '^      "\(run_number\|name\|status\|conclusion\|created_at\|updated_at\)"' | \
        cut -d'"' -f3 | \
        paste -d'|' - - - - - - | \
        column -s'|' -t
}

gh_run_repo_workflow() {
    local ORG=${1:?Org is required!}
    local REPO_NAME=${2:?Repo name is required!}
    local WORKFLOW_FILENAME=${3:?Workflow filename is required!}
    local ENDPOINT="/repos/$ORG/$REPO_NAME/actions/workflows/$WORKFLOW_FILENAME/dispatches"

    (run "gh api -X POST $ENDPOINT -F ref=master 2>/dev/null" || logtf 32 $(_gtb_actions_url $ORG $REPO_NAME) >&2) | jsonpp
}

gh_workflow_list() {
    local ORG=${1:?Org is required!}
    local REPO_NAME=${2:?Repo name is required!}

    run "gh api /repos/$ORG/$REPO_NAME/actions/workflows 2>/dev/null" | jsonpp | \
        grep '^      "\(name\|path\|state\)":' | \
        cut -d'"' -f4 | \
        paste -d'|' - - - | \
        column -s'|' -t | \
        sort
}

gh_remove_repo_secret() {
    local ORG=${1:?Org is required!}
    local REPO_NAME=${2:?Repo name is required!}
    local NAME=${3:?Secret name is required!}

    local response=$(gh secret -R $ORG/$REPO_NAME remove $NAME 2>&1)

    if echo $response | grep --silent "Removed secret ${NAME} from"; then
        echo "‚úì Removed secret $NAME from $ORG/$REPO_NAME"
        return 0
    fi

    if echo $response | grep --silent "failed to delete secret ${NAME}: HTTP 404"; then
        echo "‚úì Removed secret $NAME from $ORG/$REPO_NAME"
        return 0
    fi

    error $response
    return 1
}

gh_set_repo_secret() {
    local ORG=${1:?Org is required!}
    local REPO_NAME=${2:?Repo name is required!}
    local NAME=${3:?Secret name is required!}
    local VALUE=${4:?Secret value is required!}

    echo $ORG $REPO_NAME $NAME $VALUE \
        | parallel --jobs 1 --verbose --retries 3 --colsep ' ' "gh secret -R {1}/{2} set {3} -b{4}"
}

gh_init_repo_secrets() {
    local ORG=${1:?Org is required!}
    local REPO_NAME=${2:?Repo name is required!}
    local TERM=${3:?Term is required!}
    local FULLNAME=${4:?Fullname is required!}

    local secrets=$(gh_secret_list $ORG $REPO_NAME | cut -f1)

    if ! echo $secrets | grep --silent DASHBOARD_ADDRESS; then
        gh_set_repo_secret $ORG $REPO_NAME DASHBOARD_ADDRESS $GTB_DASHBOARD_ADDRESS
    fi
    if ! echo $secrets | grep --silent SONAR_ADDRESS; then
        gh_set_repo_secret $ORG $REPO_NAME SONAR_ADDRESS $GTB_SONAR_ADDRESS
    fi
    if ! echo $secrets | grep --silent SONAR_TOKEN; then
        gh_set_repo_secret $ORG $REPO_NAME SONAR_TOKEN $GTB_SONAR_TOKEN
    fi
    if ! echo $secrets | grep --silent STUDENT_TERM; then
        gh_set_repo_secret $ORG $REPO_NAME STUDENT_TERM $TERM
    fi
    if ! echo $secrets | grep --silent STUDENT_NAME; then
        gh_set_repo_secret $ORG $REPO_NAME STUDENT_NAME $FULLNAME
    fi
}

gh_create_org_repo() {
    local ORG=${1:?Org is required!}
    local REPO_NAME=${2:?Repo name is required!}

    local response=$(run "gh api -X POST /orgs/$ORG/repos -F private=true -F name=$REPO_NAME 2>/dev/null" | jsonpp)

    if echo $response | grep --silent "\"full_name\": \"$ORG/$REPO_NAME\""; then
        return 0
    fi

    if echo $response | grep --silent '"message": "name already exists on this account"'; then
        return 0
    fi

    error $response
    return 1
}

gh_list_org_invitations() {
    local ORG=${1:?Org is required!}

    run "gh api /orgs/$ORG/invitations 2>/dev/null" | jsonpp | \
        grep '^    "\(id\|login\|role\|created_at\)":' | \
        tr -d '" ,' | \
        sed 's/:/|/' | \
        cut -d'|' -f2 | \
        paste -d ' ' - - - - | \
        sed "s/^/$ORG /" | \
        awk '{ print $3, $1, $2, $4, $5}'
}

gh_cancel_org_invitations() {
    local ORG=${1:?Org is required!}

    while read -r LOGIN ORG ID REST
    do
        run "gh api -X DELETE /orgs/$ORG/invitations/$ID 2>/dev/null"
        [[ $? -eq 0 ]] && status='‚úÖ' || status="‚ùå"
        echo $status $ORG $ID $LOGIN
    done < <(gh_list_org_invitations $ORG)
}

gh_delete_repo() {
    local OWNER=${1:?Owner is required!}
    local REPO_NAME=${2:?Repo name is required!}

    local response=$(run "gh api -X DELETE /repos/$OWNER/$REPO_NAME 2>/dev/null")

    if [[ "$response" == "" ]]; then
        return 0
    fi

    if echo $response | grep --silent '"message":"Not Found"'; then
        return 0
    fi

    error $response
    return 1
}

gh_clone_repo() {
    local OWNER=${1:?Owner is required!}
    local REPO_NAME=${2:?Repo name is required!}
    local DIR=${3:?Director is required!}

    run "git clone git@github.com:$OWNER/$REPO_NAME $DIR"
}

build_repo() {
    local repo_name=$1
    local fullname=$2
    local term_name=$3
    local HOMEWORK_ROOT="$GTB_ROOT/$GTB_TERMS_DIR/$term_name/$repo_name"
    local STUDENT_HOMEWORK_PATH="$HOMEWORK_ROOT/$fullname"

    if [[ ! -d $STUDENT_HOMEWORK_PATH ]]
    then
        error "Skip building repo \`$STUDENT_HOMEWORK_PATH\` due to folder is not exist!"
        return
    fi

    run "cd $STUDENT_HOMEWORK_PATH"

    if [[ -f "package.json" ]]; then
        run "yarn"
    elif [[ -f "build.gradle" ]]; then
        run "./gradlew build </dev/null"
    else
        error "Failed to build project due to unknown build tool!"
    fi
}

clone_repo() {
    local repo_name=$1
    local username=$2
    local fullname=$3
    local term_name=$4
    local HOMEWORK_ROOT="$GTB_ROOT/$GTB_TERMS_DIR/$term_name/$repo_name"
    local STUDENT_HOMEWORK_PATH="$HOMEWORK_ROOT/$fullname"
    local STUDENT_HOMEWORK_URL="git@github.com:${username}/${repo_name}.git"

    [[ -d $HOMEWORK_ROOT ]] || run "mkdir -p $HOMEWORK_ROOT"

    run "git clone $STUDENT_HOMEWORK_URL $STUDENT_HOMEWORK_PATH"

    if (($?))
    then
        error "Failed to clone repo ${repo_name}.git for student $fullname!"
    fi
}

update_repo() {
    local student_homework_path=$1

    run "cd $student_homework_path"
    run "git checkout master"
    run "git pull --rebase"

    if (($?))
    then
        error "Failed to update repo ${student_homework_path}!"
    fi
}

clone_or_update_repo() {
    local repo_name=$1
    local fullname=$3
    local term_name=$4
    local HOMEWORK_ROOT="$GTB_ROOT/$GTB_TERMS_DIR/$term_name/$repo_name"
    local STUDENT_HOMEWORK_PATH="$HOMEWORK_ROOT/$fullname"

    if [[ -d $STUDENT_HOMEWORK_PATH ]] && [[ "$AUTO_UPDATE" == "true" ]]
    then
        update_repo $STUDENT_HOMEWORK_PATH
    elif [[ -d $STUDENT_HOMEWORK_PATH ]] && [[ "$AUTO_UPDATE" != "true" ]]
    then
        info "Repo ${repo_name} for student $fullname has already been downloaded."
    else
        clone_repo $@
    fi
}

join_repos() {
    readonly INVITATIONS_FILE="/tmp/gtb_invatations_${REPO_NAME}.txt"

    gh api '/user/repository_invitations?per_page=100' | jsonpp | \
        grep --color=never '^    "id":\|^      "name":\|^        "login":' | \
        paste -d' ' - - - | \
        tr -d ', :' | tr -s '"' | tr '"' ' ' | \
        grep --color=never "${REPO_NAME}" > $INVITATIONS_FILE

    readonly login_list_size=$(cat $INVITATIONS_FILE | wc -l | tr -d ' ')

    if [[ 0 -eq $login_list_size ]]
    then
        info "Found $login_list_size invitations for repo ${REPO_NAME}."
        return
    fi

    info "Found $login_list_size invitations for repo ${REPO_NAME} from following users:"
    cat $INVITATIONS_FILE | cut -d' ' -f7 | \
        xargs -I % grep '\<%\>' $GTB_STUDENTS_FILE | \
        cut -d' ' -f1-2 | sort | cat -n

    if [[ "$AUTO_ACCEPT" == "false" ]]
    then
        return
    fi

    while read -r cid id cname name clogin login
    do
        info "about to accept invitation from user ${login}..."
        run "gh api -X PATCH --silent /user/repository_invitations/${id}"

        [[ $? -eq 0 ]] && info "DONE" || error "FAILED"
    done < $INVITATIONS_FILE
}

build_repos() {
    if [[ "$AUTO_BUILD" != "true" ]]
    then
        return
    fi

    while read -r FULLNAME USERNAME TERM_NAME TAGS
    do
        if echo "$TERM_NAME" | grep --silent "$GTB_TERM"
        then
            if [[ -z "$*" ]] || echo "$@" | grep --silent "\<${FULLNAME}\>" || echo "$TAGS" | grep --silent "\<$1\>"
            then
                build_repo $REPO_NAME $FULLNAME $TERM_NAME
            fi
        fi
    done < $GTB_STUDENTS_FILE
}

clone_or_update_repos() {
    while read -r FULLNAME USERNAME TERM_NAME TAGS
    do
        if echo "$TERM_NAME" | grep --silent "$GTB_TERM"
        then
            if [[ -z "$*" ]] || echo "$@" | grep --silent "\<${FULLNAME}\>" || echo "$TAGS" | grep --silent "\<$1\>"
            then
                clone_or_update_repo $REPO_NAME $USERNAME $FULLNAME $TERM_NAME
            fi
        fi
    done < $GTB_STUDENTS_FILE
}

assert_not_empty() {
    if [[ -z "$2" ]]
    then
        fail "$1"
    fi
}

assert_trainers_file_exists() {
    if [[ ! -f $GTB_TRAINERS_FILE ]]
    then
        error "Cannot find trainers file: '$GTB_TRAINERS_FILE'."
        error "If you upgrade from the old versions, please run \`gtb init\` to clone config repo."
        exit 1
    fi
}

assert_students_file_exists() {
    if [[ ! -f $GTB_STUDENTS_FILE ]]
    then
        error "Cannot find students file: '$GTB_STUDENTS_FILE'."
        error "If you upgrade from the old versions, please run \`gtb init\` to clone config repo."
        exit 1
    fi
}

extract_comment_context() {
    while read -r line
    do
        echo "$line" | \
            sed 's:^.*TODO ::' | \
            sed 's: \{0,\}-->$::' | \
            sed 's: \{0,\}\*/}$::' | \
            sed 's: \{0,\}\*/$::' | \
            cut -d' ' -f2-
    done
}

extract_summary_comments_for_dimension() {
    local DIMENSION=${1:?dimension code is required!}
    grep "TODO GTB-\(${DIMENSION}\): \*" -R ${GTB_EXCLUDE_DIRS[@]} * | \
        extract_comment_context
}

extract_detail_comments_for_dimension() {
    local DIMENSION=${1:?dimension code is required!}
    local SYMBOL=${2:?symbol is required!}

    grep "TODO GTB-\(${DIMENSION}\): ${SYMBOL}" -R ${GTB_EXCLUDE_DIRS[@]} * | \
        extract_comment_context | \
        sed "s:^:${SYMBOL} \\\\:"
}

prepare_run_context() {
    local HOMEWORK_ROOT=${1:?homework root is required!}
    local HOMEWORK_TESTS_ROOT=${2:?homework tests root is required!}
    local REPO_NAME=${3:?repository name is required!}

    info "Start preparing run context..."
    cd "$HOMEWORK_ROOT"
    cp ${HOMEWORK_TESTS_ROOT}/docker/* .
    cp settings.gradle settings.gradle.backup
    echo "rootProject.name = '${REPO_NAME}'" > settings.gradle
}

clear_run_context() {
    local HOMEWORK_ROOT=${1:?homework root is required!}

    info "Start clearing run context..."
    cd "$HOMEWORK_ROOT"
    for f in `echo ${HOMEWORK_TESTS_ROOT}/docker/*`; do
        rm `basename $f`
    done
    mv settings.gradle.backup settings.gradle
}

ensure_application_is_ready() {
    local TIMEOUT=${1:?timeout is required!}

    timeout ${TIMEOUT}s bash << "EOF"
while :; do
    sleep 1; curl http://localhost:8080 > /dev/null 2>&1
    [[ "$?" -eq 0 ]] && break
done
EOF

    return $?
}

strip_blank_details_block() {
    cat $1 | \
        tr '\n' '\t' | \
        sed 's/__Details:__		/__Details:__	/g' | \
        sed 's/__Details:__			//g' | \
        sed 's/	\{3,\}/		/g' | \
        tr '\t' '\n'
}

extract_and_format_comments() {
    cat <<-EOF
### ÂÆåÊàêÂ∫¶Ôºö
$(extract_summary_comments_for_dimension '1\|ÂÆåÊàêÂ∫¶')
$([ -f ./gtb-test-results.md ] && echo '* ÂÖ∑‰ΩìÈ™åÊî∂ÊµãËØïÁªìÊûúËØ¶ËßÅÔºö`gtb-test-results.md`')

__Details:__
$(extract_detail_comments_for_dimension '1\|ÂÆåÊàêÂ∫¶' '+')
$(extract_detail_comments_for_dimension '1\|ÂÆåÊàêÂ∫¶' '-')

### ÊµãËØïÔºö
$(extract_summary_comments_for_dimension '2\|ÊµãËØï')

__Details:__
$(extract_detail_comments_for_dimension '2\|ÊµãËØï' '+')
$(extract_detail_comments_for_dimension '2\|ÊµãËØï' '-')

### Áü•ËØÜÁÇπÔºö
$(extract_summary_comments_for_dimension '3\|Áü•ËØÜÁÇπ')

__Details:__
$(extract_detail_comments_for_dimension '3\|Áü•ËØÜÁÇπ' '+')
$(extract_detail_comments_for_dimension '3\|Áü•ËØÜÁÇπ' '-')

### Â∑•Á®ãÂÆûË∑µÔºö
$(extract_summary_comments_for_dimension '4\|Â∑•Á®ãÂÆûË∑µ')

__Details:__
$(extract_detail_comments_for_dimension '4\|Â∑•Á®ãÂÆûË∑µ' '+')
$(extract_detail_comments_for_dimension '4\|Â∑•Á®ãÂÆûË∑µ' '-')

### ÁªºÂêàÔºö
$(extract_summary_comments_for_dimension '0\|ÁªºÂêà')

__Details:__
$(extract_detail_comments_for_dimension '0\|ÁªºÂêà' '+')
$(extract_detail_comments_for_dimension '0\|ÁªºÂêà' '-')

EOF
}

_gtb_is_a_trainer() {
    if [[ -z "$*" ]]; then
        return 1
    fi

    while read -r FULLNAME USERNAME ID TAGS
    do
        if echo "$*" | grep --silent "\<${FULLNAME}\>" || echo "$*" | grep --silent "\<${USERNAME}\>" || echo "$TAGS" | grep --silent "\<$1\>"
        then
            return 0
        fi
    done < $GTB_TRAINERS_FILE

    return 2
}

_gtb_trainer_id() {
    while read -r FULLNAME USERNAME ID TAGS
    do
        if [[ -z "$*" ]] || echo "$*" | grep --silent "\<${FULLNAME}\>" || echo "$*" | grep --silent "\<${USERNAME}\>" || echo "$TAGS" | grep --silent "\<$1\>"
        then
            echo "$ID"
        fi
    done < $GTB_TRAINERS_FILE
}

_gtb_trainer_username() {
    while read -r FULLNAME USERNAME ID TAGS
    do
        if [[ -z "$*" ]] || echo "$*" | grep --silent "\<${FULLNAME}\>" || echo "$*" | grep --silent "\<${USERNAME}\>" || echo "$TAGS" | grep --silent "\<$1\>"
        then
            echo "$USERNAME"
        fi
    done < $GTB_TRAINERS_FILE
}

_gtb_trainer_fullname() {
    while read -r FULLNAME USERNAME ID TAGS
    do
        if [[ -z "$*" ]] || echo "$*" | grep --silent "\<${FULLNAME}\>" || echo "$*" | grep --silent "\<${USERNAME}\>" || echo "$TAGS" | grep --silent "\<$1\>"
        then
            echo "$FULLNAME"
        fi
    done < $GTB_TRAINERS_FILE
}

_gtb_trainer_list() {
    while read -r FULLNAME USERNAME ID TAGS
    do
        if [[ -z "$*" ]] || echo "$*" | grep --silent "\<${FULLNAME}\>" || echo "$*" | grep --silent "\<${USERNAME}\>" || echo "$TAGS" | grep --silent "\<$1\>"
        then
            echo "$FULLNAME $USERNAME $ID $TAGS"
        fi
    done < $GTB_TRAINERS_FILE
}

_gtb_trainer() {
    assert_trainers_file_exists

    if ! echo $1 | grep --silent '^\(list\|fullname\|username\|id\)$'; then
        set -- list "$@"
    fi

    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_is_valid_git_ref() {
    local REF=${1:?Ref is required!}

    run "git cat-file -t $REF 1>/dev/null 2>&1"
}

_gtb_student_random_clear() {
    _gtb_student_random_reset
}

_gtb_student_random_reset() {
    echo -n > $GTB_RANDOM_LIST_FILE
}

_gtb_student_random_show() {
    cat $GTB_RANDOM_LIST_FILE
}

_gtb_student_random_next() {
    if [[ ! -s $GTB_RANDOM_LIST_FILE ]]
    then
        fail 'error: Please run `gtb student random` to generate random list first.'
    fi

    local next=$(head -n1 $GTB_RANDOM_LIST_FILE)
    local rest=$(tail -n +2 $GTB_RANDOM_LIST_FILE)

    echo "$rest" > $GTB_RANDOM_LIST_FILE
    echo "$next" >> $GTB_RANDOM_LIST_FILE

    echo $next
}

_gtb_student_random_generate() {
    _gtb_filter_students "$@" | \
        shuf | \
        cut -d' ' -f2 | \
        cat -n > $GTB_RANDOM_LIST_FILE
}

_gtb_student_random() {
    if ! echo $1 | grep --silent '^\(next\|show\|reset\|generate\|clear\)$'; then
        set -- generate "$@"
    fi

    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_student_org_invite_cancel() {
    local student_lines
    local students_count
    student_lines=$(_gtb_filter_students "$@")
    students_count=$(_gtb_count_lines "$student_lines")

    echo "$student_lines" | while read -r FULLNAME ORG TERM_NAME USERNAME TAGS
    do
        echo $(gh_cancel_org_invitations $ORG | tr '\n' '|')
    done | _gtb_pv $students_count \
        | _gtb_tee1 \
        | sed 's/|$//' \
        | tr '|' '\n' \
        | tr ' ' '|' \
        | sort \
        | _gtb_tabularize 'List of All Pending Student Org Invitations'
}

_gtb_student_org_invite_create() {
    assert_trainers_file_exists

    local TRAINER_FULLNAME=${1:?Trainer fullname is required! (e.g. qu.hang wang.xiaofeng)}
    shift 1

    local TRAINER_USERNAME=$(_gtb_trainer_username $TRAINER_FULLNAME)
    assert_not_empty "Cannot find '$TRAINER_FULLNAME' in ${GTB_TRAINERS_FILE}!" "$TRAINER_USERNAME"

    while read -r FULLNAME ORG TERM_NAME TAGS
    do
        if echo "$TERM_NAME" | grep --silent "$GTB_TERM"
        then
            if [[ -z "$*" ]] || echo "$*" | grep --silent "\<${FULLNAME}\>" || echo "$*" | grep --silent "\<${ORG}\>" || echo "$TAGS" | grep --silent "\<$1\>"
            then
                local response=$(gh_invite_user_to_org $ORG $TRAINER_USERNAME admin)
                if echo $response | gh_is_invitation_created; then
                    info "$ORG $TRAINER_FULLNAME"
                else
                    error "$ORG $TRAINER_FULLNAME"
                    echo $response | jsonpp 1>&2
                fi
            fi
        fi
    done < $GTB_STUDENTS_FILE
}

_gtb_student_org_invite_list() {
    local student_lines
    local students_count
    student_lines=$(_gtb_filter_students "$@")
    students_count=$(_gtb_count_lines "$student_lines")

    echo "$student_lines" | while read -r FULLNAME ORG TERM_NAME USERNAME TAGS
    do
        echo $(gh_list_org_invitations $ORG | tr '\n' '|')
    done | _gtb_pv $students_count \
        | _gtb_tee1 \
        | sed 's/|$//' \
        | tr '|' '\n' \
        | tr ' ' '|' \
        | sort \
        | _gtb_tabularize "List of All Pending Invitations of Student Org"
}

_gtb_student_org_invite() {
    if ! echo $1 | grep --silent '^\(list\|create\|cancel\)$'; then
        set -- list "$@"
    fi

    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_student_org_membership_role() {
    assert_trainers_file_exists

    local ROLE=${1:?Role is required!(admin|member)}
    shift 1
    local TRAINER_FULLNAME=${1:?Trainer fullname is required! (e.g. qu.hang wang.xiaofeng)}
    shift 1

    local TRAINER_USERNAME=$(_gtb_trainer_username $TRAINER_FULLNAME)
    assert_not_empty "Cannot find '$TRAINER_FULLNAME' in ${GTB_TRAINERS_FILE}!" "$TRAINER_USERNAME"

    local student_lines
    local students_count
    student_lines=$(_gtb_filter_students "$@")
    students_count=$(_gtb_count_lines "$student_lines")

    echo "$student_lines" | while read -r FULLNAME ORG TERM_NAME USERNAME TAGS
    do
        echo $(gh_set_org_membership $ORG $TRAINER_USERNAME $ROLE | tr '\n' '|')
    done | _gtb_pv $students_count \
        | _gtb_tee1 \
        | sed 's/|$//' \
        | tr '|' '\n' \
        | tr ' ' '|' \
        | sort \
        | _gtb_tabularize "Set Membership for Student Org"
}

_gtb_student_org_membership() {
    if ! echo $1 | grep --silent '^\(role\)$'; then
        set -- role "$@"
    fi

    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_student_org_join() {
    local TRAINER_FULLNAME=${1:?Trainer fullname is required! (e.g. zhang.zhe, wang.ke)}
    shift

    local trainer_username=$(_gtb_trainer_username $TRAINER_FULLNAME)
    assert_not_empty "Cannot find '$TRAINER_FULLNAME' in ${GTB_TRAINERS_FILE}!" "$trainer_username"

    while read -r FULLNAME ORG TERM_NAME TAGS
    do
        if echo "$TERM_NAME" | grep --silent "$GTB_TERM"
        then
            if [[ -z "$*" ]] || echo "$*" | grep --silent "\<${FULLNAME}\>" || echo "$*" | grep --silent "\<${ORG}\>" || echo "$TAGS" | grep --silent "\<$1\>"
            then
                if gh_membership $ORG $trainer_username | gh_is_pending_admin; then
                    run "open https://github.com/orgs/${ORG}/invitation"
                    sleep .5
                fi
            fi
        fi
    done < $GTB_STUDENTS_FILE
}

_gtb_check_student_org_for_presence() {
    if _gtb_is_a_trainer $1; then
        shift
    fi

    header "Checking student org for presence..."

    local student_lines
    local students_count
    student_lines=$(_gtb_filter_students "$@")
    students_count=$(_gtb_count_lines "$student_lines")

    echo "$student_lines" | while read -r FULLNAME ORG TERM_NAME TAGS
    do
        if run "gh api /orgs/$ORG 2>/dev/null" | jsonpp | grep --silent "\"login\": \"$ORG\""
        then
            logtf 28 "$TERM_NAME $FULLNAME $ORG $TAGS"
        else
            logtf 161 "$TERM_NAME $FULLNAME $ORG $TAGS"
        fi
    done | _gtb_pv $students_count | _gtb_tee1 | tr ' ' '|' | sort | _gtb_tabularize 'SUMMARY'
}

_gtb_check_student_org_for_trainer_role() {
    assert_trainers_file_exists

    header "Checking student org for trainer's role which should be admin..."

    local TRAINER_FULLNAME=${1:?Trainer fullname is required! (e.g. zhang.zhe, wang.ke)}
    shift

    local trainer_username=$(_gtb_trainer_username $TRAINER_FULLNAME)
    assert_not_empty "Cannot find '$TRAINER_FULLNAME' in ${GTB_TRAINERS_FILE}!" "$trainer_username"

    local student_lines
    local students_count
    student_lines=$(_gtb_filter_students "$@")
    students_count=$(_gtb_count_lines "$student_lines")

    echo "$student_lines" | while read -r FULLNAME ORG TERM_NAME TAGS
    do
        local membership=$(gh_membership $ORG $trainer_username)
        if echo $membership | gh_is_active_admin; then
            logtf 28 "$ORG|active admin"
        elif echo $membership | gh_is_pending_admin; then
            logtf 32 "$ORG|pending admin"
        elif echo $membership | gh_is_pending_member; then
            logtf 220 "$ORG|pending member"
        elif echo $membership | gh_is_active_member; then
            logtf 13 "$ORG|active member"
        else
            logtf 161 "$ORG|no invitation"
        fi
    done | _gtb_pv $students_count | _gtb_tee1 | tr ' ' '|' | sort | _gtb_tabularize 'SUMMARY'
}

_gtb_student_org_check() {
    if [[ "$CHECK_ROLE_ONLY" == "false" ]]; then
        _gtb_check_student_org_for_presence "$@"
    fi

    assert_trainers_file_exists
    if ! _gtb_is_a_trainer $1; then
        return 0
    fi

    echo

    _gtb_check_student_org_for_trainer_role "$@"
}

_gtb_student_org_open() {
    if [[ $# -eq 0 ]]; then
        fail 'At least one filter is required to match student with name, term, or tags, etc. (e.g. gtb student org open zhang.san)'
    fi

    while read -r FULLNAME ORG TERM_NAME TAGS
    do
        if echo "$TERM_NAME" | grep --silent "$GTB_TERM"
        then
            if echo "$*" | grep --silent "\<${FULLNAME}\>" || echo "$*" | grep --silent "\<${ORG}\>" || echo "$TAGS" | grep --silent "\<$1\>"
            then
                open "https://github.com/$ORG"
            fi
        fi
    done < $GTB_STUDENTS_FILE
}

_gtb_student_org() {
    if ! echo $1 | grep --silent '^\(open\|check\|invite\|join\|membership\)$'; then
        set -- check "$@"
    fi

    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_student_user_check() {
    local student_lines
    local students_count
    student_lines=$(_gtb_filter_students "$@")
    students_count=$(_gtb_count_lines "$student_lines")

    echo "$student_lines" | while read -r FULLNAME ORG TERM_NAME USERNAME TAGS
    do
        if gh api "/users/$USERNAME" | jsonpp | grep --silent "\"login\": \"$USERNAME\""
        then
            logtf 28 "$ORG $FULLNAME $USERNAME $TAGS"
        else
            logtf 161 "$ORG $FULLNAME $USERNAME $TAGS"
        fi
    done | _gtb_pv $students_count | _gtb_tee1 | tr ' ' '|' | sort | _gtb_tabularize 'SUMMARY'
}

_gtb_student_user() {
    if ! echo $1 | grep --silent '^\(check\)$'; then
        set -- check "$@"
    fi

    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_student_workflow_runs() {
    local REPO_NAME=${1:?Repo name is required!}
    local WORKFLOW_FILENAME=${2:?Workflow filename is required!}
    shift 2

    while read -r FULLNAME ORG TERM_NAME TAGS
    do
        if ! echo "$TERM_NAME" | grep --silent "$GTB_TERM"
        then
            continue
        fi

        if [[ -z "$*" ]] || echo "$*" | grep --silent "\<${FULLNAME}\>" || echo "$*" | grep --silent "\<${ORG}\>" || echo "$TAGS" | grep --silent "\<$1\>"
        then
            header "Runs of workflow $WORKFLOW_FILENAME from repository $ORG/$REPO_NAME..."
            gh_list_repo_workflow_runs $ORG $REPO_NAME $WORKFLOW_FILENAME
        fi
    done < $GTB_STUDENTS_FILE
}

_gtb_student_workflow_run() {
    local REPO_NAME=${1:?Repo name is required!}
    local WORKFLOW_FILENAME=${2:?Workflow filename is required!}
    shift 2

    while read -r FULLNAME ORG TERM_NAME TAGS
    do
        if echo "$TERM_NAME" | grep --silent "$GTB_TERM"
        then
            if [[ -z "$*" ]] || echo "$*" | grep --silent "\<${FULLNAME}\>" || echo "$*" | grep --silent "\<${ORG}\>" || echo "$TAGS" | grep --silent "\<$1\>"
            then
                header "Run repository workflow $WORKFLOW_FILENAME from $ORG/$REPO_NAME..."
                gh_run_repo_workflow $ORG $REPO_NAME $WORKFLOW_FILENAME
            fi
        fi
    done < $GTB_STUDENTS_FILE
}

_gtb_student_workflow_list() {
    local REPO_NAME=${1:?Repo name is required!}
    shift

    while read -r FULLNAME ORG TERM_NAME TAGS
    do
        if echo "$TERM_NAME" | grep --silent "$GTB_TERM"
        then
            if [[ -z "$*" ]] || echo "$*" | grep --silent "\<${FULLNAME}\>" || echo "$*" | grep --silent "\<${ORG}\>" || echo "$TAGS" | grep --silent "\<$1\>"
            then
                header "List repository workflows from $ORG/$REPO_NAME..."
                gh_workflow_list $ORG $REPO_NAME
            fi
        fi
    done < $GTB_STUDENTS_FILE
}

_gtb_student_workflow() {
    if ! echo $1 | grep --silent '^\(list\|run\|runs\)$'; then
        set -- list "$@"
    fi

    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_student_secret_init() {
    local REPO_NAME=${1:?Repo name is required!}
    shift

    while read -r FULLNAME ORG TERM_NAME TAGS
    do
        if echo "$TERM_NAME" | grep --silent "$GTB_TERM"
        then
            if [[ -z "$*" ]] || echo "$*" | grep --silent "\<${FULLNAME}\>" || echo "$*" | grep --silent "\<${ORG}\>" || echo "$TAGS" | grep --silent "\<$1\>"
            then
                logt 15 27 "Initialize default repository secrets for $ORG/$REPO_NAME..." 1>&2
                gh_init_repo_secrets $ORG $REPO_NAME $TERM_NAME $FULLNAME
            fi
        fi
    done < $GTB_STUDENTS_FILE
}

_gtb_student_secret_remove() {
    local REPO_NAME=${1:?Repo name is required!}
    local NAME=${2:?Secret name is required!}
    shift 2

    while read -r FULLNAME ORG TERM_NAME TAGS
    do
        if ! echo "$TERM_NAME" | grep --silent "$GTB_TERM"
        then
            continue
        fi

        if [[ -z "$*" ]] || echo "$*" | grep --silent "\<${FULLNAME}\>" || echo "$*" | grep --silent "\<${ORG}\>" || echo "$TAGS" | grep --silent "\<$1\>"
        then
            gh_remove_repo_secret $ORG $REPO_NAME $NAME
        fi
    done < $GTB_STUDENTS_FILE
}

_gtb_student_secret_set() {
    local REPO_NAME=${1:?Repo name is required!}
    local NAME=${2:?Secret name is required!}
    local VALUE=${3:?Secret value is required!}
    shift 3

    while read -r FULLNAME ORG TERM_NAME TAGS
    do
        if echo "$TERM_NAME" | grep --silent "$GTB_TERM"
        then
            if [[ -z "$*" ]] || echo "$*" | grep --silent "\<${FULLNAME}\>" || echo "$*" | grep --silent "\<${ORG}\>" || echo "$TAGS" | grep --silent "\<$1\>"
            then
                logt 15 27 "Set repository secret for $ORG/$REPO_NAME..." 1>&2
                gh_set_repo_secret $ORG $REPO_NAME $NAME $VALUE
            fi
        fi
    done < $GTB_STUDENTS_FILE
}

_gtb_student_secret_list() {
    local REPO_NAME=${1:?Repo name is required!}
    shift

    while read -r FULLNAME ORG TERM_NAME TAGS
    do
        if echo "$TERM_NAME" | grep --silent "$GTB_TERM"
        then
            if [[ -z "$*" ]] || echo "$*" | grep --silent "\<${FULLNAME}\>" || echo "$*" | grep --silent "\<${ORG}\>" || echo "$TAGS" | grep --silent "\<$1\>"
            then
                logt 15 27 "List repository secrets from $ORG/$REPO_NAME..." 1>&2
                gh_secret_list $ORG $REPO_NAME
            fi
        fi
    done < $GTB_STUDENTS_FILE
}

_gtb_student_secret() {
    if ! echo $1 | grep --silent '^\(list\|set\|remove\|init\)$'; then
        set -- list "$@"
    fi

    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_pick_and_push_commits() {
    local ORG=${1:?Org is required!}
    local REPO_NAME=${2:?Repo name is required!}
    shift 2

    cd $(_gtb_default_repo_dir $REPO_NAME)

    if ! run "git remote | grep --silent $ORG"; then
        echo "remote not found, you may need to publish this repo first."
        return 1
    fi
    run "git cherry-pick --abort 1>/dev/null 2>&1"
    run "git fetch $ORG" >&2
    run "git checkout master" >&2
    run "git branch -D $ORG 1>/dev/null 2>&1"
    if ! run "git checkout -b $ORG $ORG/master 1>&2"; then
        echo "failed to create student branch."
        return 2
    fi
    for commit in $commits_to_pick; do
        if ! run "git cherry-pick $commit" >&2; then
            run "git cherry-pick --abort 1>/dev/null 2>&1"
            echo "failed to pick ${commit}."
            return 3
        fi
    done
    if ! run "git push $ORG $ORG:master" >&2; then
        echo "failed to push."
        return 101
    fi
    run "git checkout master" >&2
    echo "done"
}

_gtb_student_repo_pick() {
    local WORKFLOW_FILENAME

    PARAMS=""
    while (( "$#" )); do
        case "$1" in
            --workflow)
                if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
                    WORKFLOW_FILENAME=$2
                    shift 2
                else
                    fail "Error: Argument for $1 is missing"
                fi
                ;;
            -*|--*=) # unsupported flags
                warn "Unsupported flag $1"
                shift
                ;;
            *) # preserve positional arguments
                PARAMS="$PARAMS $1"
                shift
                ;;
        esac
    done

    eval set -- "$PARAMS"

    local REPO_NAME=${1:?Repo name is required!}
    shift

    if [[ 0 -eq $# ]]; then
        fail 'error: refs to pick is not provided. (e.g. gtb student repo pick bronze-java-level-1 extended-tests)'
    fi

    # introduce --filters a,b,c so we can skip updating local repo while no students matched the filters
    _gtb_update_default_repo $REPO_NAME

    run "cd $(_gtb_default_repo_dir $REPO_NAME)"

    local commits_to_pick=''
    while [[ $# -gt 0 ]]; do
        local ref=$1

        if ! _gtb_is_valid_git_ref $ref; then
            break;
        fi

        commits_to_pick="$commits_to_pick $ref"
        shift
    done

    if [[ -z "$commits_to_pick" ]]; then
        fail 'error: commits to be picked is not provided. (e.g. gtb student repo pick bronze-java-level-1 extended-tests)'
    fi

    local student_lines
    local students_count
    student_lines=$(_gtb_filter_students "$@")
    students_count=$(_gtb_count_lines "$student_lines")

    [[ $students_count -eq 0 ]] && fail "error: no students matched by filters: '$@'"

    echo "$student_lines" | while read -r FULLNAME ORG TERM_NAME TAGS
    do
        local retry_times=$GTB_MAX_RETRY_TIMES_REPO_PICK
        local result=110

        while [[ $retry_times -gt 0 && $result -gt 100 ]]; do
            msg=$(_gtb_pick_and_push_commits $ORG $REPO_NAME $commits_to_pick)
            result=$?
            (( retry_times-- ))
        done

        if [[ $result -eq 0 && -n $WORKFLOW_FILENAME ]]
        then
            gh_run_repo_workflow $ORG $REPO_NAME $WORKFLOW_FILENAME
        fi

        [[ $result -eq 0 ]] && font_color=28 || font_color=161
        logtf $font_color "$FULLNAME|$msg"
    done | _gtb_pv $students_count | _gtb_tee1 | sort | _gtb_tabularize 'SUMMARY'
}

_gtb_student_repo_delete() {
    local REPO_NAME=${1:?Repo name is required!}
    shift

    read -p "Are you SURE to delete repo '$REPO_NAME' from students' organizaion? (y|n) " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]
    then
        return 1
    fi

    while read -r FULLNAME ORG TERM_NAME TAGS
    do
        if echo "$TERM_NAME" | grep --silent "$GTB_TERM"
        then
            if [[ -z "$*" ]] || echo "$*" | grep --silent "\<${FULLNAME}\>" || echo "$*" | grep --silent "\<${ORG}\>" || echo "$TAGS" | grep --silent "\<$1\>"
            then
                gh_delete_repo $ORG $REPO_NAME
                _gtb_remove_remote_student_repo $ORG $REPO_NAME
            fi
        fi
    done < $GTB_STUDENTS_FILE
}

_gtb_student_repo_create() {
    local REPO_NAME=${1:?Repo name is required!}
    shift

    while read -r FULLNAME ORG TERM_NAME TAGS
    do
        if echo "$TERM_NAME" | grep --silent "$GTB_TERM"
        then
            if [[ -z "$*" ]] || echo "$*" | grep --silent "\<${FULLNAME}\>" || echo "$*" | grep --silent "\<${ORG}\>" || echo "$TAGS" | grep --silent "\<$1\>"
            then
                gh_create_org_repo $ORG $REPO_NAME
            fi
        fi
    done < $GTB_STUDENTS_FILE
}

_gtb_student_repo_list() {
    while read -r FULLNAME ORG TERM_NAME TAGS
    do
        if echo "$TERM_NAME" | grep --silent "$GTB_TERM"
        then
            if [[ -z "$*" ]] || echo "$*" | grep --silent "\<${FULLNAME}\>" || echo "$*" | grep --silent "\<${ORG}\>" || echo "$TAGS" | grep --silent "\<$1\>"
            then
                gh_list_org_repos $ORG
            fi
        fi
    done < $GTB_STUDENTS_FILE
}

_gtb_student_repo_show() {
    local REPO_NAME=${1:?Repo name is required!}
    shift

    while read -r FULLNAME ORG TERM_NAME TAGS
    do
        if echo "$TERM_NAME" | grep --silent "$GTB_TERM"
        then
            if [[ -z "$*" ]] || echo "$*" | grep --silent "\<${FULLNAME}\>" || echo "$*" | grep --silent "\<${ORG}\>" || echo "$TAGS" | grep --silent "\<$1\>"
            then
                gh_show_org_repo $ORG $REPO_NAME
            fi
        fi
    done < $GTB_STUDENTS_FILE
}

_gtb_student_repo_open() {
    local REPO_NAME=${1:?Repo name is required!}
    shift

    if [[ $# -eq 0 ]]; then
        fail 'At least one filter is required to match student with name, term, or tags, etc. (e.g. gtb student repo open bronze-java-level-1 zhang.san)'
    fi

    while read -r FULLNAME ORG TERM_NAME TAGS
    do
        if echo "$TERM_NAME" | grep --silent "$GTB_TERM"
        then
            if echo "$*" | grep --silent "\<${FULLNAME}\>" || echo "$*" | grep --silent "\<${ORG}\>" || echo "$TAGS" | grep --silent "\<$1\>"
            then
                open "https://github.com/$ORG/$REPO_NAME"
            fi
        fi
    done < $GTB_STUDENTS_FILE
}

_gtb_student_repo() {
    if ! echo $1 | grep --silent '^\(show\|list\|create\|delete\|open\|pick\)$'; then
        set -- list "$@"
    fi

    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_student_group() {
    local GROUPS_COUNT=${1:?error: <GROUPS_COUNT> is required!}
    shift

    _gtb_filter_students "$@" | \
        shuf | \
        cut -d' ' -f2 | \
        xargs -n$GROUPS_COUNT echo | \
        datamash transpose --no-strict -t' ' | \
        sed 's: N/A::' | \
        cat -n | \
        column -t
}

_gtb_filter_students() {
    while read -r FULLNAME ORG TERM_NAME USERNAME TAGS
    do
        if echo "$TERM_NAME" | grep --silent "\<$GTB_TERM\>"
        then
            if [[ -z "$*" ]] || echo "$*" | grep --silent "\<${FULLNAME}\>" || echo "$*" | grep --silent "\<${USERNAME}\>" || echo "$*" | grep --silent "\<${ORG}\>" || echo "$TAGS" | grep --silent "\<$1\>"
            then
                printf "%s\n" "$FULLNAME $ORG $TERM_NAME $USERNAME $TAGS"
            fi
        fi
    done < $GTB_STUDENTS_FILE
}

_gtb_count_lines() {
    if [[ -z "$*" ]]; then
        echo 0
        return
    fi
    echo "$*" | wc -l | tr -d ' '
}

_gtb_student_list() {
    local students
    _gtb_filter_students "$@" | while read -r FULLNAME ORG TERM_NAME USERNAME TAGS; do
        printf "%s\n" "$TERM_NAME $FULLNAME $ORG $USERNAME $TAGS"
    done | tr ' ' '|' | sort | _gtb_tabularize | cat -n
}

_gtb_student_show() {
    local STUDENT_FULLNAME=${1:?Trainee fullname is required! (e.g. zhang.san, li.si, etc.)}

    while read -r FULLNAME ORG TERM_NAME USERNAME TAGS
    do
        if echo "$TERM_NAME" | grep --silent "$GTB_TERM"
        then
            if [[ "$FULLNAME" == "$STUDENT_FULLNAME" ]]
            then
                echo "$TERM_NAME $FULLNAME $ORG $USERNAME $TAGS"
                return 0
            fi
        fi
    done < $GTB_STUDENTS_FILE

    return 1
}

_gtb_student() {
    assert_students_file_exists

    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

remove_repo_from_team() {
    local ORG=$1
    local TEAM=$2
    local REPO=$3
    local ENDPOINT="/orgs/$ORG/teams/$TEAM/repos/$ORG/$REPO"

    run "gh api --silent -X DELETE $ENDPOINT"

    [[ $? -eq 0 ]] && info "DONE" || error "FAILED"
}

_gtb_actions_url() {
    local ORG=${1:?Org is required!}
    local REPO_NAME=${2:?Repo name is required!}

    echo "https://github.com/$ORG/$REPO_NAME/actions"
}

_gtb_push_to_student_repo() {
    local ORG=${1:?Org is required!}
    local REPO_NAME=${2:?Repo name is required!}

    cd $(_gtb_default_repo_dir $REPO_NAME)

    run "git push $ORG origin/master:refs/heads/master"
    run "git push --force $ORG origin/master:refs/heads/latest"
}

_gtb_remove_remote_student_repo() {
    local ORG=${1:?Org is required!}
    local REPO_NAME=${2:?Repo name is required!}
    local REPO_DIR=$(_gtb_default_repo_dir $REPO_NAME)

    [[ -d $REPO_DIR ]] || return 0

    cd $REPO_DIR

    if ! git remote | grep --silent "$ORG"; then
        return 0
    fi

    run "git remote remove $ORG 2>/dev/null"
}

_gtb_add_student_repo_as_remote() {
    local ORG=${1:?Org is required!}
    local REPO_NAME=${2:?Repo name is required!}

    cd $(_gtb_default_repo_dir $REPO_NAME)

    if git remote | grep --silent "$ORG"; then
        return 0
    fi

    local repo_url="git@github.com:$ORG/${REPO_NAME}.git"
    run "git remote add $ORG $repo_url"
}

_gtb_create_repo_in_student_org() {
    local ORG=${1:?Org is required!}
    local REPO_NAME=${2:?Repo name is required!}

    cd $(_gtb_default_repo_dir $REPO_NAME)

    if git remote | grep --silent "$ORG"; then
        return 0
    fi

    gh_create_org_repo $ORG $REPO_NAME
    local result=$?
    if [[ $result -ne 0 ]]; then
        error "Failed to create repo '$REPO_NAME' in '$ORG'."
        return $result
    fi

    _gtb_add_student_repo_as_remote $ORG $REPO_NAME
}

_gtb_clone_default_repo() {
    local REPO_NAME=${1:?Repo name is required!}
    local repo_dir=$(_gtb_default_repo_dir $REPO_NAME)

    [[ -d $repo_dir ]] || gh_clone_repo $GTB_ORG $REPO_NAME $repo_dir
}

_gtb_update_default_repo() {
    local REPO_NAME=${1:?Repo name is required!}
    local repo_dir=$(_gtb_default_repo_dir $REPO_NAME)

    run "cd $repo_dir"
    run "git fetch origin --prune --prune-tags"
}

_gtb_repo_publishjob() {
    set -- $*

    local REPO_NAME=${1:?Repo name is required!}
    local FULLNAME=${2:?Fullname is required!}
    local ORG=${3:?Student org is required!}
    local TERM_NAME=${4:?Term name is required!}

    header "Publish repo $REPO_NAME to $ORG..."
    _gtb_create_repo_in_student_org $ORG $REPO_NAME || return 1
    gh_init_repo_secrets $ORG $REPO_NAME $TERM_NAME $FULLNAME
    _gtb_push_to_student_repo $ORG $REPO_NAME
}

_gtb_repo_publish() {
    local JOBS=1

    PARAMS=""
    while (( "$#" )); do
        case "$1" in
            --jobs)
                if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
                    JOBS=$2
                    shift 2
                else
                    fail "Error: Argument for $1 is missing"
                fi
                ;;
            -*|--*=) # unsupported flags
                warn "Unsupported flag $1"
                shift
                ;;
            *) # preserve positional arguments
                PARAMS="$PARAMS $1"
                shift
                ;;
        esac
    done

    eval set -- "$PARAMS"

    local REPO_NAME=$1
    shift

    header "Preparing local default repo $REPO_NAME..."

    _gtb_clone_default_repo $REPO_NAME
    if [[ $? -ne 0 ]]; then
        fail "Failed to clone default repo '$REPO_NAME'."
    fi

    _gtb_update_default_repo $REPO_NAME
    if [[ $? -ne 0 ]]; then
        fail "Failed to update default repo '$REPO_NAME'."
    fi

    local student_lines
    local students_count
    student_lines=$(_gtb_filter_students "$@")
    students_count=$(_gtb_count_lines "$student_lines")

    echo "$student_lines" \
        | cut -d' ' -f1-3 \
        | parallel --jobs $JOBS --colsep ' ' --tagstring {2} --bar --verbose --linebuffer gtb repo publishjob $REPO_NAME {}
}

_gtb_repo_remove() {
    local ORG=${1:?Organization is required!}
    shift
    local TEAM=${1:?Team is required!}
    shift

    if [[ -p /dev/stdin ]]
    then
        while read line
        do
            for repo in $line
            do
                remove_repo_from_team $ORG $TEAM $repo
            done
        done
    fi


    for repo in $@
    do
        remove_repo_from_team $ORG $TEAM $repo
    done
}

add_repo_to_team() {
    local ORG=$1
    local TEAM=$2
    local REPO=$3
    local ENDPOINT="/orgs/$ORG/teams/$TEAM/repos/$ORG/$REPO"

    run "gh api --silent -X PUT $ENDPOINT -F permission='pull'"

    [[ $? -eq 0 ]] && info "DONE" || error "FAILED"
}

_gtb_repo_add() {
    local ORG=${1:?Organization is required!}
    shift
    local TEAM=${1:?Team is required!}
    shift

    if [[ -p /dev/stdin ]]
    then
        while read line
        do
            for repo in $line
            do
                add_repo_to_team $ORG $TEAM $repo
            done
        done
    fi


    for repo in $@
    do
        add_repo_to_team $ORG $TEAM $repo
    done
}

_gtb_repo_list() {
    gh_list_org_repos "$@"
}

_gtb_repo() {
    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_org_team_open() {
    run "open https://github.com/orgs/${GTB_ORG}/teams/${GTB_TERM}/members"
}

_gtb_org_team_invite() {
    local student_lines
    local students_count
    student_lines=$(_gtb_filter_students "$@")
    students_count=$(_gtb_count_lines "$student_lines")

    echo "$student_lines" | while read -r FULLNAME ORG TERM_NAME USERNAME TAGS
    do
        local response=$(gh_invite_user_to_team $GTB_ORG $GTB_TERM $USERNAME)
        if echo $response | gh_is_team_member_invited; then
            logtf 28 "$ORG $FULLNAME $USERNAME $TAGS"
        else
            logtf 161 "$ORG $FULLNAME $USERNAME $TAGS"
            echo $response | jsonpp 1>&2
        fi
    done | _gtb_pv $students_count | _gtb_tee1 | tr ' ' '|' | sort | _gtb_tabularize 'SUMMARY'
}

_gtb_org_team_members() {
    (
    echo 'No.|Config|Github|Student'
    join -1 5 -2 2 -a 1 -a 2 -o '1.1,2.1,0,1.3,1.2,1.6,1.7' -e 'NO' \
        <(_gtb_filter_students | sort -k4 | sed 's/^/YES /') \
        <(gh_list_org_team_members $GTB_ORG $GTB_TERM | sort | sed 's/^/YES /') \
        | sort -k1,2 -r \
        | cat -n | tr '\t' ' ' | tr -s ' ' | sed 's/^ //' \
        | tr ' ' '|'
    ) | _gtb_tabularize "Members of ${GTB_ORG}/${GTB_TERM}"
}

_gtb_org_team_list() {
    local ORG=${1:-$GTB_ORG}
    gh_list_org_teams $ORG
}

_gtb_org_team() {
    if ! echo $1 | grep --silent '^\(list\|open\|invite\|members\)$'; then
        set -- open "$@"
    fi

    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_org_invite() {
    local student_lines
    local students_count
    student_lines=$(_gtb_filter_students "$@")
    students_count=$(_gtb_count_lines "$student_lines")

    echo "$student_lines" | while read -r FULLNAME ORG TERM_NAME USERNAME TAGS
    do
        local response=$(gh_invite_user_to_org $GTB_ORG $USERNAME)
        if echo $response | gh_is_already_part_of_this_org; then
            logtf 28 "$ORG $FULLNAME $USERNAME $TAGS"
        elif echo $response | gh_is_invitation_created; then
            logtf 32 "$ORG $FULLNAME $USERNAME $TAGS"
        else
            logtf 161 "$ORG $FULLNAME $USERNAME $TAGS"
            echo $response | jsonpp 1>&2
        fi
    done | _gtb_pv $students_count | _gtb_tee1 | tr ' ' '|' | sort | _gtb_tabularize 'SUMMARY'
}

_gtb_org_members() {
    (
    echo 'No.|Config|Github|Student'
    join -1 5 -2 2 -a 1 -o '1.1,2.1,0,1.3,1.2,1.6,1.7' -e 'NO' \
        <(_gtb_filter_students | sort -k4 | sed 's/^/YES /') \
        <(gh_list_org_members $GTB_ORG | sort | sed 's/^/YES /') \
        | sort -k1,2 -r \
        | cat -n | tr '\t' ' ' | tr -s ' ' | sed 's/^ //' \
        | tr ' ' '|'
    ) | _gtb_tabularize "Members of $GTB_ORG"
}

_gtb_org_open() {
    local ORG=${1:-$GTB_ORG}
    run "open https://github.com/${ORG}"
}

_gtb_org() {
    assert_students_file_exists

    if ! echo $1 | grep --silent '^\(open\|invite\|team\|members\)$'; then
        set -- open "$@"
    fi

    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_trello_cards_create() {
    if [[ $# -lt 2 ]]
    then
        fail 'Card name is required!'
    fi

    local LIST_ID=${1:?Trello list ID is required!}
    shift
    local CARD_NAME=$(_gtb_urlencode "$*")

    http POST "$GTB_TRELLO_API/cards?idList=${LIST_ID}&pos=top&name=$CARD_NAME&key=$GTB_TRELLO_API_KEY&token=$GTB_TRELLO_TOKEN" \
        | jsonpp \
        | grep '^  "\(name\|idShort\|shortUrl\)": ' \
        | sed -e 's/^  "name": "//' -e 's/^  "idShort": //' -e 's/^  "shortUrl": "//' -e 's/",$//' -e 's/,$//' \
        | paste -d '^' - - - \
        | column -s'^' -t | cat -n
}

_gtb_trello_cards_list() {
    local LIST_ID=${1:?Trello list ID is required!}

    http "$GTB_TRELLO_API/lists/${LIST_ID}/cards?key=$GTB_TRELLO_API_KEY&token=$GTB_TRELLO_TOKEN" \
        | jsonpp \
        | grep '^    "\(name\|id\)": ' \
        | sed -e 's/^    "name": "//' -e 's/^    "id": "//' -e 's/",$//' \
        | paste -d '^' - - \
        | column -s'^' -t | cat -n
}

_gtb_trello_cards() {
    if ! echo $1 | grep --silent '^\(list\|create\)$'; then
        set -- "$@"
    fi

    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_trello_lists_list() {
    local BOARD_ID=${1:?Trello board ID is required!}

    http "$GTB_TRELLO_API/boards/${BOARD_ID}/lists?key=$GTB_TRELLO_API_KEY&token=$GTB_TRELLO_TOKEN" \
        | jsonpp \
        | grep '^    "\(name\|id\)": ' \
        | sed -e 's/^    "name": "//' -e 's/^    "id": "//' -e 's/",$//' \
        | paste -d '^' - - \
        | column -s'^' -t | cat -n
}

_gtb_trello_lists() {
    if ! echo $1 | grep --silent '^\(list\)$'; then
        set -- list "$@"
    fi

    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_trello_boards() {
    http "$GTB_TRELLO_API/members/panda1010/boards?key=$GTB_TRELLO_API_KEY&token=$GTB_TRELLO_TOKEN" \
        | jsonpp \
        | grep '^    "\(name\|id\)": ' \
        | sed -e 's/^    "name": "//' -e 's/^    "id": "//' -e 's/",$//' \
        | paste -d '^' - - \
        | sort | column -s'^' -t | cat -n
}

_gtb_trello() {
    GTB_TRELLO_USERNAME="${GTB_TRELLO_USERNAME:?Trello username should be set! 'https://trello.com/'}"
    GTB_TRELLO_API_KEY="${GTB_TRELLO_API_KEY:?Trello API Key should be set! 'https://trello.com/app-key'}"
    GTB_TRELLO_TOKEN="${GTB_TRELLO_TOKEN:?Trello token should be set! 'https://trello.com/app-key'}"

    if ! echo $1 | grep --silent '^\(boards\|lists\|cards\)$'; then
        set -- boards "$@"
    fi

    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_dashboard() {
    run "open ${GTB_DASHBOARD_ADDRESS%/api}?term=${GTB_TERM}"
}

_gtb_comments() {
    local GTB_TMP_COMMENTS_FILE="/tmp/gtb-comments.md"
    local GTB_COMMENTS_FILE="gtb-comments.md"

    extract_and_format_comments > $GTB_TMP_COMMENTS_FILE
    strip_blank_details_block $GTB_TMP_COMMENTS_FILE | tee $GTB_COMMENTS_FILE | tee /dev/tty | pbcopy
}

_gtb_check() {
    assert_students_file_exists

    while read -r FULLNAME USERNAME TERM_NAME TAGS
    do
        if echo "$TERM_NAME" | grep --silent "$GTB_TERM"
        then
            if [[ -z "$*" ]] || echo "$@" | grep --silent "\<${FULLNAME}\>" || echo "$TAGS" | grep --silent "\<$1\>"
            then
                if gh api "/users/$USERNAME" | jsonpp | grep --silent "\"login\": \"$USERNAME\""
                then
                    info "$TERM_NAME $FULLNAME $USERNAME"
                else
                    error "$TERM_NAME $FULLNAME $USERNAME"
                fi
            fi
        fi
    done < $GTB_STUDENTS_FILE
}

_gtb_up() {
    local REPO_NAME=${1:?Repo name is required! (e.g. B-spring-config-homework, F-jest-homework, etc.)}
    local FULLNAME=${2:?Trainee name is required! (e.g. zhang.san, li.si, etc.)}
    local HOMEWORK_ROOT="$GTB_ROOT/$GTB_TERMS_DIR/$GTB_TERM/$REPO_NAME/$FULLNAME"
    local HOMEWORK_TESTS_ROOT="$GTB_ROOT/${REPO_NAME}-ac"
    local DOCKER_ERROR_LOG_FILE='/tmp/docker_error.log'

    [[ -d $HOMEWORK_ROOT ]] || fail "Cannot find homework: $HOMEWORK_ROOT"
    [[ -d $HOMEWORK_TESTS_ROOT ]] || fail "Cannot find homework tests: $HOMEWORK_TESTS_ROOT"

    prepare_run_context "$HOMEWORK_ROOT" "$HOMEWORK_TESTS_ROOT" "$REPO_NAME"

    info "Start starting up..."
    cd "$HOMEWORK_ROOT"
    run "./gradlew build -x test && docker-compose up -d --build --remove-orphans"
    if [[ "$?" -ne 0 ]]; then
        error "Application startup failed!"
        clear_run_context "$HOMEWORK_ROOT"
        exit 1
    fi

    info "Start waiting application ready..."
    ensure_application_is_ready 60
    if [[ $? -ne 0 ]]; then
        docker-compose logs -f app > "$DOCKER_ERROR_LOG_FILE"
        error "Application fail to be ready! See the error log at file: ${DOCKER_ERROR_LOG_FILE}"
        clear_run_context "$HOMEWORK_ROOT"

        _gtb_down "$@"
        exit 1
    fi

    info "Application is ready!"
    clear_run_context "$HOMEWORK_ROOT"

    if [[ "$AUTO_TEST" == "true" ]]; then
        _gtb_test "$@"
        _gtb_down "$@"
    fi
}

_gtb_down() {
    local REPO_NAME=${1:?Repo name is required! (e.g. B-spring-config-homework, F-jest-homework, etc.)}
    local FULLNAME=${2:?Trainee name is required! (e.g. zhang.san, li.si, etc.)}
    local HOMEWORK_ROOT="$GTB_ROOT/$GTB_TERMS_DIR/$GTB_TERM/$REPO_NAME/$FULLNAME"
    local HOMEWORK_TESTS_ROOT="$GTB_ROOT/${REPO_NAME}-ac"

    [[ -d $HOMEWORK_ROOT ]] || fail "Cannot find homework: $HOMEWORK_ROOT"
    [[ -d $HOMEWORK_TESTS_ROOT ]] || fail "Cannot find homework tests: $HOMEWORK_TESTS_ROOT"

    prepare_run_context "$HOMEWORK_ROOT" "$HOMEWORK_TESTS_ROOT" "$REPO_NAME"

    info "Start shutting down..."
    cd "$HOMEWORK_ROOT"
    if [[ `docker-compose ps -q | wc -l` -ne 0 ]]; then
        run "docker-compose down --rmi local"
    else
        error "Application not startup yet!"
    fi

    clear_run_context "$HOMEWORK_ROOT"
}

_gtb_test() {
    local REPO_NAME=${1:?Repo name is required! (e.g. B-spring-config-homework, F-jest-homework, etc.)}
    local FULLNAME=${2:?Trainee name is required! (e.g. zhang.san, li.si, etc.)}
    local HOMEWORK_ROOT="$GTB_ROOT/$GTB_TERMS_DIR/$GTB_TERM/$REPO_NAME/$FULLNAME"
    local HOMEWORK_TESTS_ROOT="$GTB_ROOT/${REPO_NAME}-ac"
    local TEST_OUTPUT_FILE='/tmp/gtb_gradle_test_output.log'

    [[ -d $HOMEWORK_ROOT ]] || fail "Cannot find homework: $HOMEWORK_ROOT"
    [[ -d $HOMEWORK_TESTS_ROOT ]] || fail "Cannot find homework tests: $HOMEWORK_TESTS_ROOT"

    info "Start running acceptance tests..."
    ( cd $HOMEWORK_TESTS_ROOT && \
        run "./gradlew --rerun-tasks test < /dev/null" | \
        tee /dev/tty | \
        strip_colors > $TEST_OUTPUT_FILE )

    echo
    info "Start generating test results..."
    for f in $(cat $TEST_OUTPUT_FILE | grep 'Test _'  | cut -d'_' -f2 | sort -u)
    do
        echo $f
        echo '======='
        cat $TEST_OUTPUT_FILE | grep $f | cut -d'_' -f3 | sed -e 's/^/* /' -e 's/ PASSED//'
        echo
    done | tee $HOMEWORK_ROOT/gtb-test-results.md | grep --color -E 'FAILED|$'
}

_gtb_join() {
    assert_students_file_exists

    REPO_NAME=${1:?Repo name is required! (e.g. B-spring-config-homework, F-jest-homework, etc.)}
    shift

    join_repos $@
}

_gtb_build() {
    assert_students_file_exists

    AUTO_BUILD="true"
    REPO_NAME=${1:?Repo name is required! (e.g. B-spring-config-homework, F-jest-homework, etc.)}
    shift

    build_repos $@
}

_gtb_update() {
    assert_students_file_exists

    AUTO_UPDATE="true"
    REPO_NAME=${1:?Repo name is required! (e.g. B-spring-config-homework, F-jest-homework, etc.)}
    shift

    clone_or_update_repos $@
    build_repos $@
}

_gtb_clone() {
    assert_students_file_exists

    REPO_NAME=${1:?Repo name is required! (e.g. B-spring-config-homework, F-jest-homework, etc.)}
    shift

    clone_or_update_repos $@
    build_repos $@
}

_gtb_show() {
    assert_students_file_exists

    REPO_NAME=${1:?Repo name is required! (e.g. B-spring-config-homework, F-jest-homework, etc.)}
    shift

    while read -r FULLNAME USERNAME TERM_NAME TAGS
    do
        if echo "$TERM_NAME" | grep --silent "$GTB_TERM"
        then
            if [[ -z "$*" ]] || echo "$@" | grep --silent "\<${FULLNAME}\>" || echo "$TAGS" | grep --silent "\<$1\>"
            then
                if gh api /repos/$USERNAME/$REPO_NAME 1>/dev/null 2>&1
                then
                    info "$TERM_NAME $FULLNAME $USERNAME"
                else
                    error "$TERM_NAME $FULLNAME $USERNAME"
                fi
            fi
        fi
    done < $GTB_STUDENTS_FILE
}

_gtb_colors() {
  # for bg_color in {0..$(tput colors)}; do
  for bg_color in $(seq 0 $(tput colors)); do
    tput setaf 231
    tput setab $bg_color
    printf "  %3d  " $bg_color
    if [[ $(( $bg_color % 8 )) -eq 0 ]]; then
        tput sgr0
        printf "\n"
    fi;
  done;
}

_gtb_upgrade() {
    read -p "Are you SURE to upgrade to lastest version? (y|n) " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]
    then
        return 1
    fi

    run "brew upgrade GTB-training/gtb/util"
}

_gtb_update() {
    [[ -d $GTB_CONFIG_DIR ]] || fail 'Cannot find config directory `$GTB_CONFIG_DIR`. Please run `gtb init` to re-init.'
    update_repo $GTB_CONFIG_DIR
}

_gtb_init() {
    mkdir -p $GTB_ROOT/$GTB_REPOS_DIR
    mkdir -p $GTB_ROOT/$GTB_TERMS_DIR

    [[ -d $GTB_CONFIG_DIR ]] || gh_clone_repo GTB-training $GTB_CONFIG_REPO $GTB_CONFIG_DIR
}

_gtb_help() {
    echo "Please refer to the README doc:"
    info "https://github.com/GTB-training/util/blob/master/README.md"
    exit 0
}

# main method starts from here...
if [[ "$(type -t ${SUBCMD_PREFIX}_$SUBCOMMAND)" != 'function' ]]; then
    error "Subcommand \`$SUBCOMMAND\` is INVALID!"
    exit 2
fi

OPTIND=1

AUTO_UPDATE="false"
AUTO_BUILD="false"
AUTO_ACCEPT="true"
AUTO_TEST="false"
CHECK_ROLE_ONLY="false"

while :; do
    case $1 in
        -u|--update)
            AUTO_UPDATE="true"
            ;;
        -b|--build)
            AUTO_BUILD="true"
            ;;
        -l|--list)
            AUTO_ACCEPT="false"
            ;;
        -t|--test)
            AUTO_TEST="true"
            ;;
        --role)
            CHECK_ROLE_ONLY="true"
            ;;
        --)
            shift
            break
            ;;
        -?*)
            error "WARN: Unknown option (ignored): $1"
            ;;
        *)               # Default case: No more options, so break out of the loop.
            break
    esac

    shift
done

${SUBCMD_PREFIX}_${SUBCOMMAND} $@

