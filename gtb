#!/usr/bin/env bash

VERSION=1.250.0

GTB_DEBUG=${GTB_DEBUG:-false}

GTB_ROOT="${GTB_ROOT:-$HOME/code/gtb}"
GTB_TERM="${GTB_TERM:-gtb-404}"
GTB_CONFIG_REPO=config
GTB_CONFIG_DIR="$GTB_ROOT/$GTB_CONFIG_REPO"
GTB_TRAINERS_FILE="${GTB_TRAINERS_FILE:-$GTB_CONFIG_DIR/trainers.txt}"
GTB_BUDDIES_FILE="${GTB_BUDDIES_FILE:-$GTB_CONFIG_DIR/buddies-${GTB_TERM}.txt}"
GTB_BUDDIES_MAPPING_FILE="${GTB_BUDDIES_MAPPING_FILE:-$GTB_CONFIG_DIR/buddies-mapping-${GTB_TERM}.txt}"
GTB_STUDENTS_FILE_DEFAULT="${GTB_CONFIG_DIR}/students.txt"
GTB_STUDENTS_FILE_TERM="${GTB_CONFIG_DIR}/students-${GTB_TERM}.txt"
GTB_ASGMT_SUB_FILE="${GTB_ASGMT_SUB_FILE:-${GTB_CONFIG_DIR}/assignment-submissions-${GTB_TERM}.txt}"
GTB_STEP_ASGMT_FILE="${GTB_STEP_ASGMT_FILE:-${GTB_CONFIG_DIR}/step-assignments-${GTB_TERM}.txt}"
GTB_EOT_FEEDBACK_SUBMISSIONS_FILE="${GTB_EOT_FEEDBACK_SUBMISSIONS_FILE:-$GTB_CONFIG_DIR/eot-feedback-submissions.txt}"

if [[ -f $GTB_STUDENTS_FILE ]]; then
    GTB_STUDENTS_FILE=$GTB_STUDENTS_FILE
elif [[ -f $GTB_STUDENTS_FILE_TERM ]]; then
    GTB_STUDENTS_FILE=$GTB_STUDENTS_FILE_TERM
elif [[ -f $GTB_STUDENTS_FILE_DEFAULT ]]; then
    GTB_STUDENTS_FILE=$GTB_STUDENTS_FILE_DEFAULT
fi

GTB_MAX_RETRY_TIMES_REPO_PICK="${GTB_MAX_RETRY_TIMES_REPO_PICK:-3}"
GTB_RANDOM_LIST_FILE="/tmp/gtb_random_list.txt"
GTB_EXCLUDE_DIRS=( --exclude-dir '.git' --exclude-dir 'build' --exclude-dir 'gradle' --exclude-dir 'node_modules' --exclude-dir 'dist' --exclude-dir '.cache' )
GTB_REPOS_DIR="repos"
GTB_TERMS_DIR="terms"
GTB_FEEDBACKS_DIR="feedbacks"
GTB_USER_CACHE_DIR="$HOME/.cache/gtb"
SUBCMD_PREFIX='_gtb'
GTB_DEFAULT_REPO_ROOT="${GTB_DEFAULT_REPO_ROOT:-$GTB_ROOT/$GTB_REPOS_DIR/default}"
GTB_PER_PAGE=100
GTB_TRAINER_FILTER=''
GTB_BUDDY_FILTER=''
GTB_FROM_STDIN='false'
GTB_FROM_STUDENTS='true'
GTB_FROM_BUDDIES='false'
GTB_FROM_TRAINERS='false'
GTB_LIST_BY_BUDDY='true'
GTB_LIST_BY_BUDDEE='false'
GTB_TRELLO_CARD_DUE_IN_DAYS=3
GTB_HTTP_METHOD='GET'
GTB_HTTP_PRINT=''
GTB_PY_NAME_DEFAULT='~PINYIN_NAME~'

declare -r NULL='-'

if [[ "$(tty)" == 'not a tty' ]]; then
    GTB_PARALLEL_OPT_PROGRESS_BAR=''
else
    GTB_PARALLEL_OPT_PROGRESS_BAR='--bar'
fi

# https://stackoverflow.com/a/8597411
if [[ "$OSTYPE" == "darwin"* ]]; then
    # Mac OSX
    GTB_GREP="ggrep"
    GTB_FIND="gfind"
else
    # Unknown.
    GTB_GREP="grep"
    GTB_FIND="find"
fi

GTB_ORG=tws-graduate-program

GTB_YES="false"
GTB_RAW="false"
GTB_FORCE="false"
GTB_ALL_BRANCHES="false"
GTB_LOCAL="false"
GTB_NOTIFY="false"
GTB_LINE_NUMBERS="true"
GTB_SORT_ORDER=""
GTB_START_NUM='1'
GTB_TABLE_FORMAT_SEPARATOR=' '
GTB_EPOCH_DATETIME='19700101000000'

SYMBOL_OK='✅'
SYMBOL_ERROR='❌'

STATUS_OK='OK'
STATUS_ERROR='Error'
STATUS_FOUND='Found'
STATUS_NOT_FOUND='NotFound'

cuts() {
    cat | cut -d' ' "$@"
}

green() {
    echo -n "$(tput setaf 28)$(tput bold)$*$(tput sgr 0)"
}

blue() {
    echo -n "$(tput setaf 32)$(tput bold)$*$(tput sgr 0)"
}

yellow() {
    echo -n "$(tput setaf 220)$(tput bold)$*$(tput sgr 0)"
}

red() {
    echo -n "$(tput setaf 161)$(tput bold)$*$(tput sgr 0)"
}

info() {
    echo "$(tput setaf 4)$(tput bold)$*$(tput sgr 0)"
}

warn() {
    echo "$(tput setaf 3)$(tput bold)$*$(tput sgr 0)" >&2
}

error() {
    echo "$(tput setaf 1)$(tput bold)$*$(tput sgr 0)" >&2
}

debug() {
    echo "$(tput setaf 5)$(tput bold)$*$(tput sgr 0)"
}

run() {
    [[ "$GTB_DEBUG" == "true" ]] && echo "$(tput setaf 22)$*$(tput sgr 0)" 1>&2
    eval $*
}

header() {
    tput bold
    tput setaf 19
    tput setab 251
    printf "%-$(tput cols)s" "$*" 1>&2
    tput sgr0
    printf "\n" 1>&2
}

logt() {
    local fg_color=$1
    local bg_color=$2
    shift 2
    echo "$(tput setab $bg_color)$(tput setaf $fg_color)$*$(tput sgr 0)"
}

logtf() {
    local fg_color=$1
    shift
    echo "$(tput setaf $fg_color)$*$(tput sgr 0)"
}

logtb() {
    local bg_color=$1
    shift
    echo "$(tput setab $bg_color)$*$(tput sgr 0)"
}

logtn() {
    local fg_color=$1
    local bg_color=$2
    shift 2
    echo -n "$(tput setab $bg_color)$(tput setaf $fg_color)$*$(tput sgr 0)"
}

fail() {
    if [[ $# -ne 0 ]]; then
        error $*
    fi
    exit 1
}

strip_colors() {
    while read -r line
    do
        echo "$line" | \
            sed $'s,\x1b\\[[0-9;]*[a-zA-Z],,g'
    done
}

_gtb_open() {
    [[ $# -lt 1 ]] && fail "Arguments required for open command!"
    run "open ${*}"
}

_gtb_mute_stdout() {
    [[ "$GTB_DEBUG" == "true" ]] && echo '' || echo '1>/dev/null'
}

_gtb_mute_stderr() {
    [[ "$GTB_DEBUG" == "true" ]] && echo '' || echo '2>/dev/null'
}

_gtb_urlencode() {
    node --eval "console.log(encodeURIComponent(process.argv[1]))" "$*"
}

_gtb_tee1() {
    cat | tee /dev/tty
}

_gtb_tabularize() {
    if [[ -z "$*" ]]; then
        cat | column -s'|' -t
    else
        cat | column -s'|' -t | sed $'1s:^:\\\n'"==> $1"$'\\\n:'
    fi
}

_gtb_table() {
    _gtb_table_format "$@"
}

_gtb_table_format() {
    while (( "$#" )); do
        case "$1" in
            --raw)
                GTB_RAW="true"
                shift
                ;;
            -N|--no-line-numbers)
                GTB_LINE_NUMBERS="false"
                shift
                ;;
            -s)
                if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
                    GTB_TABLE_FORMAT_SEPARATOR="$2"
                    shift 2
                else
                    fail "Error: separator specified by '$1' is missing"
                fi
                ;;
            --start-num)
                if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
                    GTB_START_NUM="$2"
                    shift 2
                else
                    fail "Error: index start number specified by '$1' is missing"
                fi
                ;;
            *)
                shift
                ;;
        esac
    done

    if [[ "$GTB_RAW" == "true" ]]
    then
        cat
        return
    fi

    if [[ "$GTB_LINE_NUMBERS" != "true" ]]
    then
        cat | column -s"$GTB_TABLE_FORMAT_SEPARATOR" -t
        return
    fi

    cat | _gtb_nl -s "$GTB_TABLE_FORMAT_SEPARATOR" | column -s"$GTB_TABLE_FORMAT_SEPARATOR" -t
}

_gtb_tr_symbols() {
    cat | sed -E \
        -e "s/(^| )(OK)( |$)/\1$SYMBOL_OK\3/" \
        -e "s/(^| )(ER)( |$)/\1$SYMBOL_ERROR\3/"
}

_gtb_highlight() {
    local result="$(cat)"

    if [[ "$GTB_RAW" == "true" ]]
    then
        echo "$result"
        return
    fi

    while [[ $# -ge 2 ]]
    do
        result=$(echo "$result" | sed -E "s/(^| )($1)( |$)/\1$($2 $1)\3/g")
        shift 2
    done

    echo "$result"
}

_gtb_auto_notify() {
    if ! which slack >/dev/null
    then
        cat
        return
    fi

    if [[ "$GTB_NOTIFY" != "true" ]]
    then
        cat
        return
    fi

    local result="$(cat)"
    local result_to_notify=$(echo "$result" | tail -n10)
    if [[ "$GTB_DEBUG" == "true" ]]
    then
        slack chat send --channel '#gtb' --text "$result_to_notify"
    else
        slack chat send --channel '#gtb' --text "$result_to_notify" 1>/dev/null
    fi
    echo "$result"
}

_current_datetime() {
    date "+%Y%m%d-%H%M%S"
}

_gtb_time_format_for_display() {
    local TIMESTAMP=${1:?timestamp is required!}
    date -jf '%s' "$TIMESTAMP" '+%Y-%m-%d %A %H:%M:%S'
}

_gtb_time_format_for_api() {
    local TIMESTAMP=${1:?timestamp is required!}
    date -jf '%s' "$TIMESTAMP" '+%Y-%m-%dT%H:%M:%S%z' | sed -E 's/(..)$/:\1/'
}

_gtb_time_format_convert_time_zone() {
    local DATETIME=${1:?Datetime is required!}

    date -jf '%Y-%m-%dT%H:%M:%S%z' \
        "$(echo $DATETIME | sed -E 's/(.*)Z$/\1+0000/g')" \
        '+%Y-%m-%d %H:%M:%S %a' \
        | tr ' ' '_'
}

_gtb_print_in_columns() {
    cat | pr -${1:-3} -t -w $(tput cols)
}

_gtb_pv() {
    cat | pv -tbelSs $1 -i 0.3 -N "total is: $1 current is"
}

_gtb_unformat() {
    cat | tr '\t' ' ' | tr -s ' ' | sed 's/^ //'
}

_gtb_cuts() {
    cut -d"${2:- }" -f "${1:-$GTB_FIELDS}" <(cat)
}

_gtb_count() {
    GTB_FIELDS="${1:-1-}"

    local input="$(cat | _gtb_cuts)"
    local lines_count=$(_gtb_count_lines "$input")
    {
        echo "$input" | sort | uniq -c | sed -E 's/^ +//g' | _gtb_sort "${GTB_SORT_ORDER:-2}"
        echo -e "$lines_count TOTAL"
    } | column -t
}

_gtb_timestamp() {
    local DATETIME="${1:? Datetime string is required!}"
    shift

    if [[ "$DATETIME" == "now" ]]
    then
        DATETIME="$(date '+%Y-%m-%d_%H:%M:%S_%a')"
    fi

    DATETIME=$(echo $DATETIME | sed -E 's/[^0-9]//g' | cut -c1-14)
    DATETIME="${DATETIME}${GTB_EPOCH_DATETIME:${#DATETIME}}"

    # date -v4m -v16d -v9H -v0M -v0S '+%Y-%m-%dT%H:%M:%S%z' | sed -E 's/(..)$/:\1/'
    # 2021-04-16T09:00:00+08:00
    local TS=$(date \
        -v$(echo $DATETIME | cut -c1-4)y \
        -v$(echo $DATETIME | cut -c5-6)m \
        -v$(echo $DATETIME | cut -c7-8)d \
        -v$(echo $DATETIME | cut -c9-10)H \
        -v$(echo $DATETIME | cut -c11-12)M \
        -v$(echo $DATETIME | cut -c13-14)S \
        '+%s')

    for OFFSET in "$@"
    do
        OFFSET=$(echo $OFFSET | tr 'Dhms' 'dHMS')
        TS=$(date -v${OFFSET} -jf '%s' "$TS" '+%s')
    done

    date -jf '%s' "$TS" '+%s'
}

_gtb_date() {
    date -jf "%s" $(_gtb_timestamp "$@") '+%Y-%m-%d_%H:%M:%S_%a'
}

_gtb_quotes_line() {
    local QUOTE="${1:-\"}"
    cat | sed -E "s/^/$QUOTE/;s/$/$QUOTE/"
}

_gtb_join_lines() {
    local SEPARATOR="${1:-,}"
    cat | paste -s -d"$SEPARATOR" - | tr -d '\n'
}

_gtb_nl() {
    while (( "$#" )); do
        case "$1" in
            -s)
                if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
                    GTB_TABLE_FORMAT_SEPARATOR="$2"
                    shift 2
                else
                    fail "Error: separator specified by '$1' is missing"
                fi
                ;;
            *)
                shift
                ;;
        esac
    done

    cat | nl -v "${GTB_START_NUM}" -s "${GTB_TABLE_FORMAT_SEPARATOR:- }" | _gtb_unformat
}

_gtb_default_repo_dir() {
    local REPO_NAME=${1:?Repo name is required!}
    echo "$GTB_DEFAULT_REPO_ROOT/$REPO_NAME"
}

_gtb_run_subcommand() {
    COMMAND=${1:?Command is required! (e.g. repo, student.)}
    shift
    SUBCOMMAND=${1:?Subcommand is required! (e.g. list, add, remove.)}
    shift

    local subcommand_function="_gtb_${COMMAND}_${SUBCOMMAND}"

    if [[ "$(type -t $subcommand_function)" != 'function' ]]; then
        fail "error: Unknown subcommand: $SUBCOMMAND"
    fi

    $subcommand_function "$@"
}

_gtb_filter() {
    _gtb_filter_file <(cat -) '' "$@"
}

_gtb_filter_file() {
    local -r FILENAME=${1:?filename is required!}
    # CN column indices is required, you can pass an empty string or comma separated index string! (e.g. 2,7)
    local -r CN_COL_INDICES=${2}
    shift 2

    local FILTER

    if [[ -z "$*" ]]; then
        cat "${FILENAME}" | _gtb_split
        return 0
    fi

    {
        local PATTERN=''
        for FILTER in "$@"; do
            PATTERN="${PATTERN}|(^| )${FILTER}( |$)"
        done
        PATTERN="${PATTERN#|}"

        $GTB_GREP -E --color=never "${PATTERN}" $FILENAME

        if [[ "$OSTYPE" == "darwin"* ]]; then
            for FILTER in "$@"; do
                if echo "$FILTER" | $GTB_GREP --silent -P '[\p{Han}]'; then
                    awk -v CN_COL_INDICES="$CN_COL_INDICES" -v CN_NAME="$FILTER" '{
                        n = split(CN_COL_INDICES, indices, ",");
                        for (i in indices) {
                            if ($indices[i] == CN_NAME) { print }
                        }
                    }' $FILENAME
                fi
            done
        fi
    } | LC_ALL=C sort -u \
        | _gtb_split
}

_gtb_filter-file() {
    _gtb_filter_file "$@"
}

_gtb_filter_students() {
    _gtb_filter_file "$GTB_STUDENTS_FILE" "7" "$@"
}

_gtb_filter_buddies() {
    _gtb_filter_file "$GTB_BUDDIES_FILE" "2,4,8" "$@" | grep -v '^FULLNAME'
}

_gtb_filter_trainers() {
    _gtb_filter_file "$GTB_TRAINERS_FILE" "4" "$@" | grep -v '^FULLNAME'
}

_gtb_filter_asgmt_submissions() {
    _gtb_filter_file "$GTB_ASGMT_SUB_FILE" '' "$@" | grep -v '^ORG_NAME'
}

_gtb_filter_buddies_mapping() {
    if [[ $# -le 1 ]]; then
        cat "${GTB_BUDDIES_MAPPING_FILE}"
        return
    fi

    local -r FILTER_BY="${1:?please specify filtery-by using 1 for buddy, 2 for buddee!}"
    shift

    local -r KEYWORDS="$(echo $* | tr ' ' '|')"
    local PATTERN

    if [[ "1" == "${FILTER_BY}" ]]; then
        PATTERN="^${KEYWORDS} "
    else
        PATTERN=" ${KEYWORDS}$"
    fi
    $GTB_GREP -E --color=never "${PATTERN}" "${GTB_BUDDIES_MAPPING_FILE}"
}

_gtb_field_index() {
    local -r FILENAME="${1:?filename is required!}"
    local -r FIELD="${2:?field name is required!}"

    local -r FIELDS="$(head -n1 "$FILENAME")"

    if ! $GTB_GREP --silent "\<$FIELD\>" <(echo "$FIELDS"); then
        fail "error: cannot find '$FIELD' in '$FIELDS' from file '$FILENAME'!"
    fi

    echo "$FIELDS" | tr ' ' '\n' | nl -n ln | $GTB_GREP "$FIELD" | _gtb_cuts 1
}

_gtb_split() {
    if [[ -n "$1" ]]; then
        GTB_CHUNK="$1"
    fi

    if [[ -z "${GTB_CHUNK}" ]]; then
        cat
        return 0
    fi

    cat | gsplit -n "r/${GTB_CHUNK}"
}

gh_check_user() {
    local USERNAME=${1:?username is required!}
    local result=$(run "gh api '/users/$USERNAME' $(_gtb_mute_stderr)" \
        | jq -r 'if .login then "OK" else "ER" end')
    if [[ -z "$result" ]]
    then
        result='ER'
    fi
    echo "$result $*"
}

gh_user_id() {
    local USERNAME=${1:?username is required!}
    run "gh api /users/${USERNAME} 2>/dev/null" | jsonpp | \
        grep '"\(id\)"' | \
        tr -d ' ,' | \
        cut -d':' -f2
}

gh_invite_user_to_org() {
    local ORG=${1:?org is required!}
    local USERNAME=${2:?username is required!}
    local ROLE=${3:-direct_member}
    local result=$(gh_create_invitation $ORG $(gh_user_id $USERNAME) $ROLE \
        | jq -r 'if .created_at or .errors[0].message == "Invitee is already a part of this org" then "OK" else "ER" end')
    if [[ -z "$result" ]]
    then
        result='ER'
    fi
    echo "$result $*"
}

gh_check_user_not_in_org() {
    local student_lines=$(_gtb_filter_students "$@")
    local students_count=$(_gtb_count_lines "$student_lines")
    assert_not_empty "error: cannot find any students with filters: '$@'!" "$student_lines"

    local ORG=$(echo "$student_lines" | _gtb_cuts 2)
    local USERNAME=$(echo "$student_lines" | _gtb_cuts 4)

    local result=$(run "gh api -X GET /orgs/${ORG}/members")
    if [[ $(echo $result | jq -r '.message?') != "Not Found" ]];then
        result=$(echo $result | jq -r --arg u "$USERNAME" \
            'if any(.[]; .login ==$u) == true then "ER" else "OK" end')
    else
        result="OK"
    fi

    echo "$result $*"
    [[ "$result" != "OK" ]] && fail "error: user $USERNAME still in org $ORG"
}

gh_remove_user_from_org() {
    local ORG=${1:?org is required!}
    local USERNAME=${2:?username is required!}
    run "gh api -X DELETE /orgs/${ORG}/members/$USERNAME 1>/dev/null 2>&1"
}

gh_invite_user_to_team() {
    local ORG=${1:?org is required!}
    local TEAM=${2:?team is required!}
    local USERNAME=${3:?username is required!}
    local result=$(run "gh api -X PUT '/orgs/${ORG}/teams/${TEAM}/memberships/${USERNAME}' $(_gtb_mute_stderr)" \
        | jq -r 'if .role then "OK" else "ER" end')
    if [[ -z "$result" ]]
    then
        result='ER'
    fi
    echo "$result $*"
}

gh_find_org() {
    local ORG=${1:?org is required!}

    if run "gh api /orgs/$ORG $(_gtb_mute_stderr)" | jsonpp | grep --silent "\"login\": \"$ORG\""
    then
        echo "created" "$@"
    else
        echo "not_found" "$@"
    fi
}

gh_membership() {
    local ORG=${1:?org is required!}
    local CN_NAME=${2:?CN name is required!}
    local USERNAME=${3:?username is required!}
    run "gh api '/orgs/${ORG}/memberships/${USERNAME}' $(_gtb_mute_stderr)" \
        | jq -jr --arg ORG $ORG --arg USERNAME $USERNAME --arg CN_NAME $CN_NAME \
        'if .role then
            .user.login, " ", .organization.login, " ", $CN_NAME, " ", .role, " ", .state, "\n"
        else
            $USERNAME, " ", $ORG, " ", $CN_NAME, " ", "not_a_member", " ", "404", "\n"
        end'
}

gh_set_org_membership() {
    local ORG=${1:?org is required!}
    local USERNAME=${2:?username is required!}
    local ROLE=${3:?role is required!(admin|member)}

    run "gh api -X PUT '/orgs/${ORG}/memberships/${USERNAME}' -F role='$ROLE' $(_gtb_mute_stderr)" \
        | jq -jr '.role // "not_found", " ", .state // "404", "\n"' \
        | sed "s/^/$USERNAME $ORG /"
}

gh_create_invitation() {
    local ORG=${1:?Org is required!}
    local INVITEE_ID=${2:?Invitee ID is required!}
    local ROLE=${3:-direct_member}
    run "gh api /orgs/${ORG}/invitations -F role=$ROLE -F invitee_id=$INVITEE_ID $(_gtb_mute_stderr)"
}

gh_list_org_teams() {
    local ORG=${1:-$GTB_ORG}
    local ENDPOINT="/orgs/$ORG/teams"

    run "gh api --paginate $ENDPOINT 2>/dev/null" | jsonpp | \
        grep '    "name":' | \
        tr -d '" ,' | \
        cut -d':' -f2 | \
        sort
}

gh_list_org_team_members() {
    local ORG=${1:?Organization is required!}
    local TEAM=${2:?Team is required!}
    local ENDPOINT="/orgs/${ORG}/teams/${TEAM}/members?per_page=100"

    run "gh api --paginate $ENDPOINT 2>/dev/null" | jsonpp | \
        grep '    "login":' | \
        tr -d '" ,' | \
        cut -d':' -f2 | \
        sort
}

gh_list_org_members() {
    local ORG=${1:?Organization is required!}
    local ENDPOINT="/orgs/${ORG}/members?per_page=$GTB_PER_PAGE"

    run "gh api --paginate '${ENDPOINT}' $(_gtb_mute_stderr)" \
        | jq -r '.[] | .login' \
        | sort
}

gh_list_org_repos() {
    local ORG=${1:-$GTB_ORG}
    local TEAM=${GTB_ORG_TEAM}

    local ENDPOINT="/orgs/$ORG/repos?per_page=${GTB_PER_PAGE}"
    if [[ -n "$TEAM" ]]
    then
        ENDPOINT="/orgs/$ORG/teams/$TEAM/repos?per_page=${GTB_PER_PAGE}"
    fi

    run "gh api --paginate '${ENDPOINT}' $(_gtb_mute_stderr)" \
        | jq -jr 'if type == "array" then .[] | .owner.login, " ", .name, " ", .private, " ", .created_at, "\n" else "\n" end' \
        | grep -v '^$' \
        | sed 's/ true / private /;s/ false / public /'
}

gh_show_org_repo_commit() {
    local ORG=${1:?Org is required!}
    local REPO_NAME=${2:?Repo name is required!}
    local COMMIT_REF=${3:?Commit ref is required!}

    local ENDPOINT="/repos/$ORG/$REPO_NAME/commits/$COMMIT_REF"

    local -ir RETRY=3
    local -ir RETRY_INTERVAL=3
    local RESULT
    local OUTPUT

    for i in  $(seq 1 "$RETRY"); do
        if [[ $i -gt 1 ]]; then
            sleep "$RETRY_INTERVAL"
        fi

        run "gh api $ENDPOINT 1>/dev/null $(_gtb_mute_stderr)"
        RESULT=$?

        if [[ $RESULT -eq 0 ]]; then
            echo "OK" $ORG
            return 0
        fi
    done

    echo "ERROR" $ORG
    return $RESULT
}

gh_show_org_repo() {
    local ORG=${1:?Org is required!}
    local REPO_NAME=${2:?Repo name is required!}

    local ENDPOINT="/repos/$ORG/$REPO_NAME"
    local OUTPUT="$ORG $REPO_NAME"

    run "gh api $ENDPOINT 1>/dev/null $(_gtb_mute_stderr)"

    local result=$?
    if [[ $result -eq 0 ]]; then
        echo "$ORG" "$REPO_NAME" "$STATUS_FOUND"
    else
        echo "$ORG" "$REPO_NAME" "$STATUS_NOT_FOUND"
    fi

    return $result
}

gh_create_org_repo() {
    local ORG=${1:?Org is required!}
    local REPO_NAME=${2:?Repo name is required!}

    local response=$(run "gh api -X POST /orgs/$ORG/repos -F private=true -F name=$REPO_NAME" | jsonpp)

    if echo $response | grep --silent "\"full_name\": \"$ORG/$REPO_NAME\""; then
        return 0
    fi

    if echo $response | grep --silent '"message": "name already exists on this account"'; then
        return 0
    fi

    error $response
    return 1
}

gh_list_org_invitations() {
    local ORG=${1:?Org is required!}

    run "gh api --paginate '/orgs/$ORG/invitations?per_page=${GTB_PER_PAGE}' $(_gtb_mute_stderr)" \
        | jq -jr 'if type == "array" then .[] | .login, " __ORG__  ", .id, " ", .role, " ", .created_at, "\n" else "\n" end' \
        | grep -v '^$' \
        | sed "s/__ORG__/$ORG/"
}

gh_cancel_org_invitations() {
    local ORG=${1:?Org is required!}

    while read -r LOGIN ORG ID REST
    do
        run "gh api -X DELETE /orgs/$ORG/invitations/$ID 2>/dev/null"
        [[ $? -eq 0 ]] && status='✅' || status="❌"
        echo $status $ORG $ID $LOGIN
    done < <(gh_list_org_invitations $ORG)
}

gh_delete_repo() {
    local ORG=${1:?ORG is required!}
    local REPO_NAME=${2:?Repo name is required!}

    local response=$(run "gh api -X DELETE /repos/$ORG/$REPO_NAME 2>/dev/null")

    if [[ "$response" == "" ]]; then
        echo $ORG $REPO_NAME
        return 0
    fi

    if echo $response | grep --silent '"message":"Not Found"'; then
        echo $ORG $REPO_NAME
        return 0
    fi

    error $response
    return 1
}

gh_clone_repo() {
    local ORG=${1:?ORG is required!}
    local REPO_NAME=${2:?Repo name is required!}
    local DIR=${3:?Director is required!}

    run "git clone git@github.com:$ORG/$REPO_NAME $DIR"
}

_gtb_trello_find_board_id() {
    local -r BOARD_NAME=${1:?Board name is required!}
    shift
    local RESULT="$(_gtb_cache_get trello "board-id-${BOARD_NAME}")"

    if [[ -n "$RESULT" ]]; then
        echo "$RESULT"
        return 0
    fi

    RESULT=$(_gtb_trello_api "/search?modelTypes=boards&query=${BOARD_NAME}" \
        | jq -r ".boards[] | select(.name == \"$BOARD_NAME\") | .id" \
        | head -n1)

    if [[ -n "$RESULT" ]]; then
        _gtb_cache_set trello "board-id-${BOARD_NAME}" "$RESULT"
        echo "$RESULT"
        return 0
    fi

    return 1
}

_gtb_trello_check_card_closed() {
    local -r CARD_ID=${1:?Card id is required!}
    local -r URL="/cards/$CARD_ID"

    RESULT=$(_gtb_trello_api "/cards/${CARD_ID}" \
        | jq -r ".closed")

    if [[ "$RESULT" = "true" ]]; then
        echo "$RESULT"
        return 0
    fi

    fail "failed to archive card ${GTB_TRELLO_CARD_ID}!"
}

_gtb_trello_find_card_id() {
    local -r BOARD_NAME=${1:?Board name is required!}
    local -r CARD_NAME=${2:?Card name is required!}

    local -r BOARD_ID=$(_gtb_trello_find_board_id "$BOARD_NAME")
    assert_not_empty "Cannot find board with name '$BOARD_NAME'!" "$BOARD_ID"

    local -r URL="/search?modelTypes=cards&card_fields=name&idBoards=${BOARD_ID}&query=${CARD_NAME}"
    local -r RESULT="$(_gtb_trello_api "$URL" \
        | jq -r ".cards[] | select(.name == \"$CARD_NAME\") | .id" \
        | head -n1)"

    if [[ -n "$RESULT" ]]; then
        echo "$RESULT"
        return 0
    fi

    return 1
}

_gtb_trello_find_list_id() {
    local BOARD_NAME=${1:?Board name is required!}
    local LIST_NAME=${2:?List name is required!}
    shift 2

    local CACHE_KEY="list-id-${BOARD_NAME}-${LIST_NAME}"
    local RESULT="$(_gtb_cache_get trello "$CACHE_KEY")"
    if [[ -n "$RESULT" ]]; then
        echo "$RESULT"
        return 0
    fi

    local BOARD_ID=$(_gtb_trello_find_board_id "$BOARD_NAME")
    assert_not_empty "Cannot find board with name '$GTB_TRELLO_BOARD_NAME'!" "$BOARD_ID"

    RESULT=$(_gtb_trello_api "/boards/${BOARD_ID}/lists" \
        | jq -r ".[] | select(.name == \"$LIST_NAME\") | .id")

    if [[ -n "$RESULT" ]]; then
        _gtb_cache_set trello "$CACHE_KEY" "$RESULT"
        echo "$RESULT"
        return 0
    fi

    return 1
}

_gtb_trello_remove_member_from_board() {
    GTB_TRELLO_BOARD_NAME="${GTB_TRELLO_BOARD_NAME:?Trello board name is required! Specify by --board <NAME>.}"

    local ORG=${1:?Student org is required!}

    local BOARD_ID=$(_gtb_trello_find_board_id "$GTB_TRELLO_BOARD_NAME")
    assert_not_empty "Cannot find board with name '$GTB_TRELLO_BOARD_NAME'!" "$BOARD_ID"

    local username
    local member_id

    if [[ $# -eq 2 ]]; then
        local -r TRELLO_EMAIL=${2:?Trello member email is required!}
        username=$(_gtb_trello_member_username $TRELLO_EMAIL | _gtb_cuts 1 | head -n1)
        member_id=$(trello_member_id $TRELLO_EMAIL | _gtb_cuts 1 | head -n1)
    elif [[ $# -eq 3 ]]; then
        username="${2:?Trello username is required!}"
        member_id="${3:?Trello member id is required!}"
    else
        fail "usage: gtb trello remove_member_from_board --board <BOARD_NAME> <TRELLO_EMAIL|TRELLO_USERNAME TRELLO_MEMBER_ID>"
    fi

    local -r board_json=$(_gtb_trello_api --method 'DELETE' "/boards/${BOARD_ID}/members/${member_id}")

    local -r RESULT="$(jq -jr ".members[] | select(.username==\"$username\") | .username, \" \", .memberType, \" \", .fullName, \"\n\"" <(echo "$JSON"))"

    if [[ -n "$RESULT" ]]; then
        echo "❌ $@ $RESULT"
        fail "failed to remove member ${username} from board ${GTB_TRELLO_BOARD_NAME}"
    fi

    echo "✅ $@"
    return 0
}

_gtb_trello_invite_member_to_board() {
    GTB_TRELLO_BOARD_NAME="${GTB_TRELLO_BOARD_NAME:?Trello board name is required! Specify by --board <NAME>.}"
    GTB_TRELLO_MEMBER_TYPE="${GTB_TRELLO_MEMBER_TYPE:?Trello member type is required! Specify by --type <admin|normal|observer>.}"

    local ORG=${1:?Student org is required!}
    local TRELLO_EMAIL=${2:?Trell member email is required!}

    local BOARD_ID=$(_gtb_trello_find_board_id "$GTB_TRELLO_BOARD_NAME")
    assert_not_empty "Cannot find board with name '$GTB_TRELLO_BOARD_NAME'!" "$BOARD_ID"

    local -r MEMBER_ID=$(trello_member_id "$TRELLO_EMAIL" | _gtb_cuts 1 | head -n1)
    assert_not_empty "Cannot find member with email '$TRELLO_EMAIL'!" "$MEMBER_ID"

    local -r JSON="$(_gtb_trello_api --method 'PUT' "/boards/${BOARD_ID}/members?email=${TRELLO_EMAIL}&type=${GTB_TRELLO_MEMBER_TYPE}")"

    local -r RESULT="$(jq -jr ".memberships[] | select(.idMember==\"$MEMBER_ID\") | .idMember, \" \", .memberType, \" \", .deactivated, \"\n\"" <(echo "$JSON"))"

    if [[ -n "$RESULT" ]]; then
        echo "OK $ORG $TRELLO_EMAIL $RESULT"
        return 0
    fi

    echo "ER $ORG $TRELLO_EMAIL"
    error $response
    return 1
}

clone_repo() {
    local repo_name=$1
    local username=$2
    local fullname=$3
    local term_name=$4
    local HOMEWORK_ROOT="$GTB_ROOT/$GTB_TERMS_DIR/$term_name/$repo_name"
    local STUDENT_HOMEWORK_PATH="$HOMEWORK_ROOT/$fullname"
    local STUDENT_HOMEWORK_URL="git@github.com:${username}/${repo_name}.git"

    [[ -d $HOMEWORK_ROOT ]] || run "mkdir -p $HOMEWORK_ROOT"

    run "git clone $STUDENT_HOMEWORK_URL $STUDENT_HOMEWORK_PATH"

    if (($?))
    then
        error "Failed to clone repo ${repo_name}.git for student $fullname!"
    fi
}

update_repo() {
    local student_homework_path=$1

    run "cd $student_homework_path"
    run "git checkout master"
    run "git pull --rebase"

    if (($?))
    then
        error "Failed to update repo ${student_homework_path}!"
    fi
}

clone_or_update_repo() {
    local repo_name=$1
    local fullname=$3
    local term_name=$4
    local HOMEWORK_ROOT="$GTB_ROOT/$GTB_TERMS_DIR/$term_name/$repo_name"
    local STUDENT_HOMEWORK_PATH="$HOMEWORK_ROOT/$fullname"

    if [[ -d $STUDENT_HOMEWORK_PATH ]] && [[ "$AUTO_UPDATE" == "true" ]]
    then
        update_repo $STUDENT_HOMEWORK_PATH
    elif [[ -d $STUDENT_HOMEWORK_PATH ]] && [[ "$AUTO_UPDATE" != "true" ]]
    then
        info "Repo ${repo_name} for student $fullname has already been downloaded."
    else
        clone_repo "$@"
    fi
}

clone_or_update_repos() {
    local student_lines=$(_gtb_filter_students "$@")
    local students_count=$(_gtb_count_lines "$student_lines")
    assert_not_empty "error: cannot find any students with filters: '$@'!" "$student_lines"

    echo "$student_lines" \
        | _gtb_cuts 1-4 \
        | env_parallel \
            --tagstring "$REPO_NAME {1}" \
            --linebuffer \
            --jobs $JOBS \
            --colsep ' ' \
            $GTB_PARALLEL_OPT_PROGRESS_BAR \
            clone_or_update_repo $REPO_NAME "{2}" "{1}" "{3}"
}

assert_not_empty() {
    if [[ -z "$2" ]]
    then
        fail "$1"
    fi
}

assert_assignment_submissions_file_exists() {
    if [[ ! -f $GTB_ASGMT_SUB_FILE ]]; then
        error "Cannot find file: '$GTB_ASGMT_SUB_FILE'."
        exit 1
    fi
}

assert_trainers_file_exists() {
    if [[ ! -f $GTB_TRAINERS_FILE ]]
    then
        error "Cannot find trainers file: '$GTB_TRAINERS_FILE'."
        error "If you upgrade from the old versions, please run \`gtb init\` to clone config repo."
        exit 1
    fi
}

assert_buddies_file_exists() {
    if [[ ! -f $GTB_BUDDIES_FILE ]]
    then
        error "Cannot find buddies file: '$GTB_BUDDIES_FILE'."
        error "If you upgrade from the old versions, please run \`gtb init\` to clone config repo."
        exit 1
    fi
}

assert_students_file_exists() {
    if [[ ! -f $GTB_STUDENTS_FILE ]]
    then
        error "Cannot find students file: '$GTB_STUDENTS_FILE'."
        error "If you upgrade from the old versions, please run \`gtb init\` to clone config repo."
        exit 1
    fi
}

assert_eot_feedback_submission_file_exists() {
    if [[ ! -f $GTB_EOT_FEEDBACK_SUBMISSIONS_FILE ]]
    then
        error "Cannot find EOT feedbacks file: '$GTB_EOT_FEEDBACK_SUBMISSIONS_FILE'."
        error "If you upgrade from the old versions, please run \`gtb init\` to clone config repo."
        exit 1
    fi
}

assert_value_exists_in_file() {
    local -r FILENAME="${1:? filename is required!}"
    local -r FIELD="${2:?1-based field number is required!}"
    local -r VALUE="${3:?value is required!}"

    if [[ -z "$(awk -v FIELD="$FIELD" -v VALUE="$VALUE" '$FIELD == VALUE' $FILENAME)" ]]; then
        fail "error: value '$VALUE' not found on field '$FIELD' in file '$(basename $FILENAME)'!"
    fi
}

assert_value_is_uniq_in_file() {
    local -r FILENAME="${1:? filename is required!}"
    local -r FIELD="${2:?1-based field number is required!}"
    local -r VALUE="${3:?value is required!}"

    if [[ -n "$(awk -v FIELD="$FIELD" -v VALUE="$VALUE" '$FIELD == VALUE' $FILENAME)" ]]; then
        fail "error: value '$VALUE' already exists on field '$FIELD' in file '$(basename $FILENAME)'!"
    fi
}

_gtb_trainer_username() {
    local -r FILTER=${1:?Filter is required! (e.g. zhang.san, li.si, etc.)}
    local -r FLAG_RAW="$GTB_RAW"
    local -r FLAG_LINE_NUMBERS="$GTB_LINE_NUMBERS"

    GTB_RAW="true"
    GTB_LINE_NUMBERS="false"
    _gtb_trainer_show "$FILTER" | sed -n '2p'
    GTB_RAW="$FLAG_RAW"
    GTB_LINE_NUMBERS="$FLAG_LINE_NUMBERS"
}

_gtb_trainer_show() {
    local -r FILTER=${1:?filter is required! (e.g. zhang.san, li.si, etc.)}

    local -r FILTERED_LINES=$(_gtb_filter_trainers "${FILTER}")
    local -r COUNT=$(_gtb_count_lines "$FILTERED_LINES")
    if [[ 1 -ne $COUNT ]]; then
        error "error: $COUNT lines filtered with filter: '${FILTER}', should match exactly one line!"
        return 1
    fi

    echo "$FILTERED_LINES" \
        | tr ' ' '\n' \
        | _gtb_table_format
}

_gtb_trainer_list() {
    _gtb_filter_trainers "$@" \
        | _gtb_sort "${GTB_SORT_ORDER:-1,1}" \
        | _gtb_cuts "${GTB_FIELDS:-1-}" \
        | _gtb_table_format
}

_gtb_trainer() {
    assert_trainers_file_exists

    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_report() {
    assert_students_file_exists
    assert_assignment_submissions_file_exists

    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_rp() {
    _gtb_report "$@"
}

_gtb_report_assignment() {
    local -r TMP_STUDENTS_FILE="/tmp/gtb-report-assignment-$$"
    _gtb_filter_students "$@" | _gtb_cuts '1,2,7,8,10,12' >"$TMP_STUDENTS_FILE"

    {
        echo "ID Name Background Unit JoinOn" "Step0"{1..8}"-Grade" "Step0"{1..8}"-SubmittedAt"
        {
            paste -d' ' \
                <(cat "$TMP_STUDENTS_FILE" | _gtb_cuts 1,3-) \
                <(extract_asgmt_info 'Step01' '2.4,2.8' "$TMP_STUDENTS_FILE" | parse_assignment_level) \
                <(extract_asgmt_info 'Step02' '2.4,2.8' "$TMP_STUDENTS_FILE" | parse_assignment_level) \
                <(extract_asgmt_info 'Step03' '2.4,2.8' "$TMP_STUDENTS_FILE" | parse_assignment_level) \
                <(extract_asgmt_info 'Step04' '2.4,2.8' "$TMP_STUDENTS_FILE" | parse_assignment_level) \
                <(extract_asgmt_info 'Step05' '2.4,2.8' "$TMP_STUDENTS_FILE" | parse_assignment_level) \
                <(extract_asgmt_info 'Step06' '2.4,2.8' "$TMP_STUDENTS_FILE" | parse_assignment_level) \
                <(extract_asgmt_info 'Step07' '2.4,2.8' "$TMP_STUDENTS_FILE" | parse_assignment_level) \
                <(extract_asgmt_info 'Step08' '2.4,2.8' "$TMP_STUDENTS_FILE" | parse_assignment_level) \
                <(extract_asgmt_info 'Step01' '2.4'     "$TMP_STUDENTS_FILE") \
                <(extract_asgmt_info 'Step02' '2.4'     "$TMP_STUDENTS_FILE") \
                <(extract_asgmt_info 'Step03' '2.4'     "$TMP_STUDENTS_FILE") \
                <(extract_asgmt_info 'Step04' '2.4'     "$TMP_STUDENTS_FILE") \
                <(extract_asgmt_info 'Step05' '2.4'     "$TMP_STUDENTS_FILE") \
                <(extract_asgmt_info 'Step06' '2.4'     "$TMP_STUDENTS_FILE") \
                <(extract_asgmt_info 'Step07' '2.4'     "$TMP_STUDENTS_FILE") \
                <(extract_asgmt_info 'Step08' '2.4'     "$TMP_STUDENTS_FILE")
        } | _gtb_sort "${GTB_SORT_ORDER:-5,5;3,3r;4,4;1,1}"
    } \
        | _gtb_cuts "${GTB_FIELDS:-1-13}" \
        | _gtb_table_format --start-num 0 \
        | _gtb_highlight \
            'Level-0' red \
            'Level-1' yellow \
            'Level-2' blue \
            'Level-3' green
}

extract_asgmt_info() {
    local -r STEP_NAME="${1:?step name is required!}"
    local -r FIELDS="${2:?fields are required! ('2.4', '2.4,2.8', etc)}"
    local -r STUDENTS_FILE="${3:?students file is required!}"
    LC_ALL=C join -1 2 -2 3 -a 1 -e '-' -o "${FIELDS}" "$STUDENTS_FILE" <($GTB_GREP "^${STEP_NAME}" "$GTB_ASGMT_SUB_FILE")
}

parse_assignment_level() {
    cat | awk '{if ($1 == "-" && $2 == "-") {print "-";} else if ($1 != "-" && $2 != "-") {print $2;} else {print "Level-?";}}'
}

_gtb_report_assign() {
    _gtb_report_assignment "$@"
}

_gtb_report_asgmt() {
    _gtb_report_assignment "$@"
}

_gtb_report_as() {
    _gtb_report_assignment "$@"
}

_gtb_assignment() {
    assert_students_file_exists
    assert_assignment_submissions_file_exists

    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_assign() {
    _gtb_assignment "$@"
}

_gtb_asgmt() {
    _gtb_assignment "$@"
}

_gtb_as() {
    _gtb_assignment "$@"
}

_gtb_assignment_list() {
    cat "$GTB_STEP_ASGMT_FILE" \
        | _gtb_table_format
}

_gtb_assignment_check() {
    local -r STEP_NAME="${1:?step name is required!}"
    local -r ASGMT_NAME="${2:?assignment name is required!}"

    $GTB_GREP --silent "^${STEP_NAME} ${ASGMT_NAME}$" "$GTB_STEP_ASGMT_FILE" \
        || fail "error: Invalid assignment '${STEP_NAME} ${ASGMT_NAME}'!"
}

_gtb_assignment_submission() {
    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_assignment_sub() {
    _gtb_assignment_submission "$@"
}

_gtb_assignment_submission_field() {
    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_assignment_submission_f() {
    _gtb_assignment_submission_field "$@"
}

_gtb_assignment_submission_field_list() {
    head -n1 $GTB_ASGMT_SUB_FILE \
        | tr ' ' '\n' \
        | _gtb_table_format "$@"
}

_gtb_assignment_submission_list() {
    local -r ORG_NAMES="$(_gtb_filter_students "$@" | _gtb_cuts 2 | paste -sd' ' -)"
    _gtb_filter_asgmt_submissions $ORG_NAMES \
        | _gtb_sort "${GTB_SORT_ORDER:-1,1}" \
        | _gtb_cuts "${GTB_FIELDS:-1-4,7-9}" \
        | _gtb_table_format
}

_gtb_assignment_submission_add() {
    local -r STEP_NAME="${1:?step name is required!}"
    local -r REPO_NAME="${2:?repo name is required!}"
    local -r ORG_NAME="${3:?org name is required!}"
    local -r PRIMARY_KEY="$REPO_NAME $ORG_NAME"
    local CREATED_AT="$(gdate --iso-8601=seconds)"
    CREATED_AT="${4:-$CREATED_AT}"
    local -r CREATED_AT

    assert_value_exists_in_file $GTB_STUDENTS_FILE 2 "$ORG_NAME"

    if ! $GTB_GREP --silent "^$STEP_NAME $PRIMARY_KEY " "$GTB_ASGMT_SUB_FILE"; then
        echo "$STEP_NAME $PRIMARY_KEY $CREATED_AT $NULL $NULL $NULL $NULL $NULL" >>"$GTB_ASGMT_SUB_FILE"
        LC_ALL=C sort -u --output $GTB_ASGMT_SUB_FILE $GTB_ASGMT_SUB_FILE
    fi
}

_gtb_assignment_submission_delete() {
    local -r STEP_NAME=${GTB_STEP:-}
    local -r REPO_NAME=${GTB_REPO:-}
    local -r ORG_NAME=${GTB_ORG_NAME:-}

    local -r PATTERN=$(sed -E "s/^ {1,}| {1,}$//g" <(echo "$STEP_NAME $REPO_NAME $ORG_NAME"))
    assert_not_empty "error: please provide filter via options: --step, --repo, --org" "$PATTERN"

    declare CARD_ID

    for CARD_ID in $(sed -nE "/(^| )${PATTERN} /p" "$GTB_ASGMT_SUB_FILE" | _gtb_cuts 5); do
        info "Archive Trello card '${CARD_ID}' ..."
        GTB_TRELLO_CARD_ID="${CARD_ID}" _gtb_trello card archive
    done

    info "Delete related data from $GTB_ASGMT_SUB_FILE ..."
    sed -i.bak -E "/(^| )${PATTERN} /d" "$GTB_ASGMT_SUB_FILE"

    _gtb_config_diff "$GTB_ASGMT_SUB_FILE"
}

_gtb_assignment_submission_remove() {
    _gtb_assignment_submission_delete "$@"
}

_gtb_assignment_submission_has() {
    local -r PRIMARY_KEY="${GTB_PK:?primary key is required! (REPO_NAME ORG_NAME)}"

    local -r FIELD="${1:?FIELD is required!}"
    local FIELD_INDEX
    FIELD_INDEX="$(_gtb_field_index "$GTB_ASGMT_SUB_FILE" "$FIELD")"
    local -r FIELD_INDEX

    local LINE

    assert_not_empty "error: field not found!" "$FIELD_INDEX"

    gawk \
        -v KEY="$PRIMARY_KEY" -v INDEX="$FIELD_INDEX" -v NULL_VALUE="$NULL" \
        'BEGIN {err = 1} { if ($2" "$3 == KEY && $INDEX != NULL_VALUE) { err = 0; } } END { if (err == 0) { print "yes"; } else { print "no"; }  exit err}' \
        "$GTB_ASGMT_SUB_FILE"
}

_gtb_assignment_submission_set() {
    local -r PRIMARY_KEY="${GTB_PK:?primary key is required! (REPO_NAME ORG_NAME)}"

    local -r FIELD="${1:?FIELD is required!}"
    local -r VALUE="${2:?VALUE is required!}"
    local -r FIELD_INDEX="$(_gtb_field_index "$GTB_ASGMT_SUB_FILE" "$FIELD")"

    assert_not_empty "error: field not found!" "$FIELD_INDEX"

    if ! $GTB_GREP --silent " $PRIMARY_KEY " "$GTB_ASGMT_SUB_FILE"; then
        fail "error: cannot find assignment submission '$PRIMARY_KEY'!"
    fi

    gawk \
        -i inplace \
        -v KEY="$PRIMARY_KEY" -v VALUE="$VALUE" -v INDEX="$FIELD_INDEX" \
        '{ if ($2" "$3 == KEY) { $INDEX = VALUE; } print $0; }' \
        "$GTB_ASGMT_SUB_FILE"
}

_gtb_assignment_submission_update() {
    _gtb_assignment_submission_set "$@"
}

_gtb_assignment_submission_get() {
    local -r PRIMARY_KEY="${GTB_PK:?primary key is required! (REPO_NAME ORG_NAME)}"

    local -r FIELD="${1:?FIELD is required!}"
    local -r FIELD_INDEX="$(_gtb_field_index "$GTB_ASGMT_SUB_FILE" "$FIELD")"

    if ! $GTB_GREP --silent " $PRIMARY_KEY " "$GTB_ASGMT_SUB_FILE"; then
        fail "error: cannot find assignment submission '$PRIMARY_KEY'!"
    fi

    gawk -v KEY="$PRIMARY_KEY" -v FIELD="$FIELD" -v INDEX="$FIELD_INDEX" -v NULL_VALUE="$NULL" \
        '$2" "$3 == KEY && $INDEX != NULL_VALUE {print $INDEX}' \
        "$GTB_ASGMT_SUB_FILE"
}

_gtb_feedback_list() {
    cat "$GTB_EOT_FEEDBACK_SUBMISSIONS_FILE" \
        | _gtb_table_format
}

gtb_feedback_remove_submission() {
    local -r ORG=${1:?organization is required! (e.g. gtb-2022-zhang-san, etc.)}
    local -r BUDDY_EMAIL=${2:?buddy email is required! (e.g. hqu@thoughtworks.com, etc.)}

    if [[ "false" == "$GTB_YES" ]]
    then
        read -p "about to DELETE $(red "$ORG") $(red "$BUDDY_EMAIL") from $(red "$GTB_EOT_FEEDBACK_SUBMISSIONS_FILE")? (y|n) " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]
        then
            return 1
        fi
    fi

    gawk \
        -i inplace \
        -v org="$ORG" \
        -v email="$BUDDY_EMAIL" \
        '$1==org && $2==email {next} {print}' \
        "$GTB_EOT_FEEDBACK_SUBMISSIONS_FILE"

    _gtb_config_diff "$GTB_EOT_FEEDBACK_SUBMISSIONS_FILE"
}

gtb_feedback_delete_file() {
    local -r ORG=${1:?organization is required! (e.g. gtb-2022-zhang-san, etc.)}
    local -r BUDDY_EMAIL=${2:?buddy email is required! (e.g. hqu@thoughtworks.com, etc.)}

    if [[ "false" == "$GTB_YES" ]]
    then
        read -p "about to DELETE $(red "$ORG") $(red "$BUDDY_EMAIL") from $(red "$GTB_EOT_FEEDBACK_SUBMISSIONS_FILE")? (y|n) " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]
        then
            return 1
        fi
    fi

    local -r FEEDBACK_FILE="$GTB_CONFIG_DIR/$GTB_FEEDBACKS_DIR/$ORG-$BUDDY_EMAIL.txt"

    [[ -f $FEEDBACK_FILE ]] && rm -rf "$FEEDBACK_FILE"
}

_gtb_report_feedback() {
    local -r TMP_STUDENTS_EOT_INIT_FILE="/tmp/gtb-report-feedback-init-$$"
    local -r TMP_STUDENTS_EOT_FILE="/tmp/gtb-report-feedback-$$"
    local -r TMP_STUDENTS_EOT_CSV_FILE="/tmp/gtb-report-feedback-$$.csv"

    _gtb_filter_students "$@" | _gtb_cuts '1,2,7,8,10,12' > "$TMP_STUDENTS_EOT_INIT_FILE"

    {
        echo "Org ID Name Background Unit JoinOn" "BuddyEmail BuddyName BuddyUnit SubmittedAt Feedback"
        {
          paste -d ',' \
          <( \
            LC_ALL=C join -1 2 -2 1 -a 2 <(cat "$TMP_STUDENTS_EOT_INIT_FILE" | _gtb_sort "2") \
            <( \
                LC_ALL=C join -1 2 -2 3 -o "1.1,1.2,2.2,2.4,1.3" \
                  <($GTB_GREP "^gtb-" "$GTB_EOT_FEEDBACK_SUBMISSIONS_FILE" | _gtb_sort "2") \
                  <(cat "$GTB_BUDDIES_FILE" | _gtb_sort "3") \
                | _gtb_sort "1" \
            )
          )
        }
    } > $TMP_STUDENTS_EOT_FILE

    while read -r Org ID Name Background Unit JoinOn BuddyEmail BuddyName BuddyUnit SubmittedAt Feedback
    do
        local FEEDBACK_FILE=$GTB_CONFIG_DIR/$GTB_FEEDBACKS_DIR/$Org-$BuddyEmail.txt
        if [[ ! -f "$FEEDBACK_FILE" ]]
        then
            echo "$Org,$ID,$Name,$Background,$Unit,$JoinOn,$BuddyEmail,$BuddyName,$BuddyUnit,$SubmittedAt,$Feedback" >> "$TMP_STUDENTS_EOT_CSV_FILE"
        else
            local FEEDBACK_CONTENT="\"$(cat "$FEEDBACK_FILE" | sed 's/"/""/g')\""
            echo "$Org,$ID,$Name,$Background,$Unit,$JoinOn,$BuddyEmail,$BuddyName,$BuddyUnit,$SubmittedAt,$FEEDBACK_CONTENT" >> "$TMP_STUDENTS_EOT_CSV_FILE"
        fi
    done < $TMP_STUDENTS_EOT_FILE

    cat $TMP_STUDENTS_EOT_CSV_FILE
}

_gtb_feedback_remove() {
    local -r ORG=${1:?organization is required! (e.g. gtb-2022-zhang-san, etc.)}
    local -r BUDDY_EMAIL=${2:?buddy email is required! (e.g. hqu@thoughtworks.com, etc.)}

    assert_value_exists_in_file "$GTB_STUDENTS_FILE" 2 "$ORG"
    assert_value_exists_in_file "$GTB_BUDDIES_FILE" 3 "$BUDDY_EMAIL"

    gtb_feedback_remove_submission "$ORG" "$BUDDY_EMAIL"
    gtb_feedback_delete_file "$ORG" "$BUDDY_EMAIL"
}

_gtb_feedback_show() {
    local -r ORG=${1:?organization is required! (e.g. gtb-2022-zhang-san, etc.)}
    local -r BUDDY_EMAIL=${2:?buddy email is required! (e.g. hqu@thoughtworks.com, etc.)}
    local -r QUERY_FILTER="$ORG$BUDDY_EMAIL"
    local -r COUNT=$(_gtb_count_lines "$GTB_EOT_FEEDBACK_SUBMISSIONS_FILE")

    gawk '{print $1$2}' "$GTB_EOT_FEEDBACK_SUBMISSIONS_FILE" | $GTB_GREP --silent "$QUERY_FILTER"

    RESULT=$?

    [[ 0 -lt $RESULT ]] && fail "error: $COUNT lines filtered with filter: '$QUERY_FILTER', should match exactly one line!"

    return $RESULT
}

_gtb_feedback_add() {
    local -r ORG="${1:?org name is required!}"
    local -r BUDDY_EMAIL="${2:?buddy email is required!}"
    local -r FEEDBACK_FILE="${3:?feedback is required!}"
    local CREATED_AT="$(gdate --iso-8601=seconds)"
    CREATED_AT="${4:-$CREATED_AT}"

    assert_value_exists_in_file "$GTB_STUDENTS_FILE" 2 "$ORG"
    assert_value_exists_in_file "$GTB_BUDDIES_FILE" 3 "$BUDDY_EMAIL"

    # add feedback submission
    echo "$ORG" "$BUDDY_EMAIL" "$CREATED_AT" >> "$GTB_EOT_FEEDBACK_SUBMISSIONS_FILE"
    LC_ALL=C sort -u --output "$GTB_EOT_FEEDBACK_SUBMISSIONS_FILE" "$GTB_EOT_FEEDBACK_SUBMISSIONS_FILE"

    # mv temp file to feedback dir
    mv "$FEEDBACK_FILE" "$GTB_CONFIG_DIR/$GTB_FEEDBACKS_DIR/$ORG-$BUDDY_EMAIL.txt"
  }

_gtb_buddy() {
    assert_trainers_file_exists

    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_feedback() {
    assert_students_file_exists
    assert_eot_feedback_submission_file_exists

    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_bu() {
    _gtb_buddy "$@"
}

_gtb_b() {
    _gtb_buddy "$@"
}

_gtb_fd() {
    _gtb_feedback "$@"
}

_gtb_buddy_field() {
    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_buddy_f() {
    _gtb_buddy_field "$@"
}

_gtb_buddy_field_list() {
    head -n1 $GTB_BUDDIES_FILE \
        | tr ' ' '\n' \
        | _gtb_table_format "$@"
}

_gtb_buddy_show() {
    local BUDDY_FILTER=${1:?Fullname is required! (e.g. zhang.san, li.si, etc.)}

    local buddy_lines=$(_gtb_filter_buddies "${BUDDY_FILTER}")
    local buddies_count=$(_gtb_count_lines "$buddy_lines")
    [[ 1 -ne $buddies_count ]] && fail "error: $COUNT lines filtered with filter: '${BUDDY_FILTER}', should match exactly one line!"

    paste -d ' ' \
        <(_gtb_buddy_field_list -N) \
        <(echo "$buddy_lines" | tr ' ' '\n') \
        | _gtb_table_format
}

_gtb_buddy_list() {
    _gtb_filter_buddies "$@" \
        | _gtb_sort "${GTB_SORT_ORDER:-1,1}" \
        | _gtb_cuts "${GTB_FIELDS:-1-}" \
        | _gtb_table_format
}

_gtb_buddy_add() {
    local -r FULLNAME="${1:?FULLNAME is required!}"
    local -r CN_NAME="${2:?CN_NAME is required!}"
    local -r TW_EMAIL="${3:?TW_EMAIL is required!}"
    local -r UNIT="${4:?UNIT is required!}"
    local -r GITHUB_USERNAME="${5:?GITHUB_USERNAME is required!}"
    local -r MOBILE="${6:?MOBILE is required!}"
    local -r WECHAT="${7:?WECHAT is required!}"
    shift 7
    local -r TAGS="$GTB_TERM $*"

    assert_value_is_uniq_in_file "$GTB_BUDDIES_FILE" 1 "$FULLNAME"
    assert_value_is_uniq_in_file "$GTB_BUDDIES_FILE" 2 "$CN_NAME"
    assert_value_is_uniq_in_file "$GTB_BUDDIES_FILE" 3 "$TW_EMAIL"
    assert_value_is_uniq_in_file "$GTB_BUDDIES_FILE" 5 "$GITHUB_USERNAME"
    assert_value_is_uniq_in_file "$GTB_BUDDIES_FILE" 6 "$MOBILE"
    assert_value_is_uniq_in_file "$GTB_BUDDIES_FILE" 7 "$WECHAT"

    local LINE="$FULLNAME $CN_NAME $TW_EMAIL $UNIT $GITHUB_USERNAME $MOBILE $WECHAT"
    [[ -n "$TAGS" ]] && LINE="$LINE $TAGS"

    echo "$LINE" >>"$GTB_BUDDIES_FILE"

    LC_ALL=C sort -u --output "$GTB_BUDDIES_FILE" "$GTB_BUDDIES_FILE"
}

_gtb_buddy_remove() {
    readonly keyword=${1:?Fullname or TW email is required!}

    cat $GTB_BUDDIES_FILE | _gtb_cuts 1,3 | grep --silent "\<$keyword\>" \
        || fail "error: cannot find buddy, run \`gtb buddy show $keyword\` to learn more."

    if [[ "false" == "$GTB_YES" ]]
    then
        read -p "about to DELETE $(red ${keyword}) from $(red $GTB_BUDDIES_FILE)? (y|n) " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]
        then
            return 1
        fi
    fi

    gawk \
        -i inplace \
        -v keyword="$keyword" \
        '$1==keyword || $3==keyword {next} {print}' \
        "$GTB_BUDDIES_FILE"

    _gtb_config_diff "$GTB_BUDDIES_FILE"
}

_gtb_buddy_username() {
    readonly BUDDY_FULLNAME=${1:?Fullname is required! (e.g. zhang.san, li.si, etc.)}
    readonly FLAG_RAW="$GTB_RAW"
    readonly FLAG_LINE_NUMBERS="$GTB_LINE_NUMBERS"

    GTB_RAW="true"
    GTB_LINE_NUMBERS="false"
    _gtb_buddy_list $BUDDY_FULLNAME | _gtb_cuts 5
    GTB_RAW="$FLAG_RAW"
    GTB_LINE_NUMBERS="$FLAG_LINE_NUMBERS"
}

_gtb_buddy_mapping() {
    assert_trainers_file_exists

    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_buddy_map() {
    _gtb_buddy_mapping "$@"
}

_gtb_buddy_mapping_list() {
    local A=1
    local B=2
    if [[ "true" == "$GTB_LIST_BY_BUDDEE" ]]; then
        A=2
        B=1
    fi
    _gtb_filter_buddies_mapping "${A}" "$@" \
        | awk -v A=$A -v B=$B '{map[$A]=map[$A]" "$B;count[$A]+=1} END{for (name in map) print name, count[name], map[name]}' \
        | tr -s ' ' \
        | _gtb_sort "${GTB_SORT_ORDER:-1,1}" \
        | _gtb_cuts "${GTB_FIELDS:-1-}" \
        | _gtb_table_format
}

_gtb_buddy_mapping_add() {
    local -r BUDDY_FULLNAME="$(gtb buddy show --raw "$GTB_BUDDY_FILTER" | $GTB_GREP 'FULLNAME' | _gtb_cuts 2)"
    assert_not_empty "error: cannot find buddy with filter '$GTB_BUDDY_FILTER' specified via --buddy." "${BUDDY_FULLNAME}"

    gtb student list --raw --fields 2 $(echo $@ | tr ',' ' ' | tr -s ' ') \
        | grep -v '~PINYIN_NAME~' \
        | sed "s/^/$BUDDY_FULLNAME /" \
        >>"$GTB_BUDDIES_MAPPING_FILE"

    LC_ALL=C sort -u --output "$GTB_BUDDIES_MAPPING_FILE" "$GTB_BUDDIES_MAPPING_FILE"
}

_gtb_buddy_mapping_remove() {
    local -r BUDDY_FULLNAME="$GTB_BUDDY_FILTER"

    cat $GTB_BUDDIES_FILE | _gtb_cuts 1 | grep --silent "^\<$BUDDY_FULLNAME\>" \
        || fail "error: cannot find buddy with fullname '$BUDDY_FULLNAME' specified via --buddy."

    gtb student list --raw --fields 2 "$@" \
        | sed "s/^/$BUDDY_FULLNAME /" \
        | while read -r line; do
        sed -i.bak "/^${line}$/d" $GTB_BUDDIES_MAPPING_FILE
    done
}

_git_list_all_branches_of_remote() {
    local REMOTE_NAME=${1:?Remote name is required!}
    local BRANCH_NAMES=$(run "git branch -r --no-color --list '${REMOTE_NAME}/*' $(_gtb_mute_stderr) | grep -wv 'HEAD' | tr -d '\t ' | cut -d'/' -f2")
    # ensure master/main branch is the first branch in list
    echo "$BRANCH_NAMES" | grep --color=never -wE 'master|main' | sort -r
    echo "$BRANCH_NAMES" | grep --color=never -vwE 'master|main' | sort
}

_gtb_git_verify_refs() {
    local REPO_NAME=${1:?Repo name is required!}
    local GTB_REFS=${2:-}

    if [[ -z "$GTB_REFS" ]]; then
        return
    fi

    _gtb_clone_default_repo $REPO_NAME

    run "cd $(_gtb_default_repo_dir $REPO_NAME)"

    local REFS=$(echo "$GTB_REFS" | tr ',' ' ' | tr -s ' ')
    local commits_to_pick=''

    for ref in $REFS; do
        if _gtb_is_valid_git_ref $ref; then
            commits_to_pick="$commits_to_pick $ref"
        fi
    done

    if [[ -z "$commits_to_pick" ]]; then
        return
    fi

    echo "$commits_to_pick" | sed -E 's/^ +//g'
}

_gtb_is_valid_git_ref() {
    local REF=${1:?Ref is required!}

    run "git cat-file -t $REF 1>/dev/null 2>&1"
}

_gtb_student_random_clear() {
    _gtb_student_random_reset
}

_gtb_student_random_reset() {
    echo -n > $GTB_RANDOM_LIST_FILE
}

_gtb_student_random_show() {
    cat $GTB_RANDOM_LIST_FILE
}

_gtb_student_random_next() {
    if [[ ! -s $GTB_RANDOM_LIST_FILE ]]
    then
        fail 'error: Please run `gtb student random` to generate random list first.'
    fi

    local next=$(head -n1 $GTB_RANDOM_LIST_FILE)
    local rest=$(tail -n +2 $GTB_RANDOM_LIST_FILE)

    echo "$rest" > $GTB_RANDOM_LIST_FILE
    echo "$next" >> $GTB_RANDOM_LIST_FILE

    echo $next
}

_gtb_student_random_generate() {
    _gtb_filter_students "$@" | \
        shuf | \
        cut -d' ' -f2 | \
        cat -n > $GTB_RANDOM_LIST_FILE
}

_gtb_student_random() {
    if ! echo $1 | grep --silent '^\(next\|show\|reset\|generate\|clear\)$'; then
        set -- generate "$@"
    fi

    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_student_org_invite_cancel() {
    local student_lines=$(_gtb_filter_students "$@")
    local students_count=$(_gtb_count_lines "$student_lines")

    echo "$student_lines" | while read -r FULLNAME ORG TERM_NAME USERNAME TAGS
    do
        echo $(gh_cancel_org_invitations $ORG | tr '\n' '|')
    done | _gtb_pv $students_count \
        | _gtb_tee1 \
        | sed 's/|$//' \
        | tr '|' '\n' \
        | tr ' ' '|' \
        | sort \
        | _gtb_tabularize 'List of All Pending Student Org Invitations'
}

_gtb_student_org_invite_create() {
    local student_lines=$(_gtb_filter_students "$@")
    local students_count=$(_gtb_count_lines "$student_lines")
    assert_not_empty "error: cannot find any students with filters: '$@'!" "$student_lines"

    local invitee_username

    if [[ -n "$GTB_TRAINER_FILTER" ]]; then
        assert_trainers_file_exists
        invitee_username=$(_gtb_trainer_username $GTB_TRAINER_FILTER | head -n1)
        assert_not_empty "Cannot find '$GTB_TRAINER_FILTER' in ${GTB_TRAINERS_FILE}!" "$invitee_username"
    elif [[ -n "$GTB_BUDDY_FILTER" ]]; then
        assert_buddies_file_exists
        invitee_username=$(_gtb_buddy_username $GTB_BUDDY_FILTER | head -n1)
        assert_not_empty "Cannot find '$GTB_BUDDY_FILTER' in ${GTB_BUDDIES_FILE}!" "$invitee_username"
    elif [[ -n "$GTB_USERNAME" ]]; then
        invitee_username="$GTB_USERNAME"
    fi

    echo "$student_lines" \
        | env_parallel \
            --linebuffer \
            --jobs $JOBS \
            --colsep ' ' \
            $GTB_PARALLEL_OPT_PROGRESS_BAR \
            gh_invite_user_to_org "{2}" "$invitee_username" 'admin' "{7}" \
        | _gtb_sort '1,1r;2,2' \
        | _gtb_table_format \
        | _gtb_tr_symbols
}

_gtb_student_org_invite_list() {
    local student_lines=$(_gtb_filter_students "$@")
    local students_count=$(_gtb_count_lines "$student_lines")
    assert_not_empty "error: cannot find any students with filters: '$@'!" "$student_lines"

    local result=$(echo "$student_lines" \
        | _gtb_cuts 2 \
        | env_parallel \
            --linebuffer \
            --jobs $JOBS \
            --colsep ' ' \
            $GTB_PARALLEL_OPT_PROGRESS_BAR \
            gh_list_org_invitations "{}")
    local trainers=$(echo "$result" | _gtb_cuts 1 | sort -ur)

    for trainer in $trainers
    do
        echo "$result" \
            | grep -w -E --color=never "$trainer" \
            | _gtb_sort '1,1;2,2' \
            | _gtb_nl
    done | _gtb_table_format
}

_gtb_student_org_invite() {
    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_student_org_membership_role() {
    assert_trainers_file_exists

    local ROLE=${1:?Role is required!(admin|member)}
    shift 1
    local TRAINER_FULLNAME=${1:?Trainer fullname is required! (e.g. qu.hang wang.xiaofeng)}
    shift 1

    local TRAINER_USERNAME=$(_gtb_trainer_username $TRAINER_FULLNAME)
    assert_not_empty "Cannot find '$TRAINER_FULLNAME' in ${GTB_TRAINERS_FILE}!" "$TRAINER_USERNAME"

    local student_lines=$(_gtb_filter_students "$@")
    local students_count=$(_gtb_count_lines "$student_lines")
    assert_not_empty "error: cannot find any students with filters: '$@'!" "$student_lines"

    echo "$student_lines" \
        | _gtb_cuts 2 \
        | env_parallel \
            --linebuffer \
            --jobs $JOBS \
            --colsep ' ' \
            $GTB_PARALLEL_OPT_PROGRESS_BAR \
            gh_set_org_membership {} $TRAINER_USERNAME $ROLE \
        | _gtb_sort '3,3;4,4;2,2' \
        | _gtb_table_format
}

_gtb_student_org_membership() {
    if ! echo $1 | grep --silent '^\(role\)$'; then
        set -- role "$@"
    fi

    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_student_org_join() {
    local TRAINER_FULLNAME=${1:?Trainer fullname is required! (e.g. zhang.zhe, wang.ke)}
    shift

    local trainer_username=$(_gtb_trainer_username $TRAINER_FULLNAME)
    assert_not_empty "Cannot find '$TRAINER_FULLNAME' in ${GTB_TRAINERS_FILE}!" "$trainer_username"

    local student_lines=$(_gtb_filter_students "$@")
    local students_count=$(_gtb_count_lines "$student_lines")
    assert_not_empty "error: cannot find any students with filters: '$@'!" "$student_lines"

    local orgs_to_join=$(echo "$student_lines" \
        | _gtb_cuts 2,7 \
        | env_parallel --jobs $JOBS $GTB_PARALLEL_OPT_PROGRESS_BAR --linebuffer --colsep ' ' gh_membership "{1}" "{2}" "$trainer_username" \
        | grep --color=never 'admin pending')
    assert_not_empty "no pending admin invitations to join!" "$orgs_to_join"

    echo "$orgs_to_join" | _gtb_sort 1 | _gtb_table_format

    if [[ "false" == "$GTB_YES" ]]
    then
        read -p "about to JOIN above student orgs? (y|n) " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]
        then
            return 1
        fi
    fi

    for ORG in $(echo "$orgs_to_join" | _gtb_cuts 2)
    do
        run "open -g https://github.com/orgs/${ORG}/invitation"
        sleep .5
    done
}

_gtb_check_student_org_for_presence() {
    _gtb_filter_students "$@" \
        | cut -d' ' -f'2,7' \
        | env_parallel --jobs $JOBS $GTB_PARALLEL_OPT_PROGRESS_BAR --linebuffer --colsep ' ' gh_find_org {1} {2}
}

_gtb_check_student_org_for_trainer_role() {
    assert_trainers_file_exists

    local TRAINER_FULLNAME=${1:?Trainer fullname is required! (e.g. zhang.zhe, wang.ke)}
    shift

    local trainer_username=$(_gtb_trainer_username $TRAINER_FULLNAME)
    assert_not_empty "Cannot find '$TRAINER_FULLNAME' in ${GTB_TRAINERS_FILE}!" "$trainer_username"

    _gtb_filter_students "$@" \
        | _gtb_cuts 2,7 \
        | env_parallel \
            $GTB_PARALLEL_OPT_PROGRESS_BAR \
            --jobs $JOBS \
            --colsep ' ' \
            --linebuffer \
            gh_membership "{1}" "{2}" "$trainer_username" \
        | sed "s/^/$TRAINER_FULLNAME /"
}

_gtb_student_org_remove() {
    local student_lines=$(_gtb_filter_students "$@")
    local students_count=$(_gtb_count_lines "$student_lines")

    echo "$student_lines" \
        | _gtb_cuts 2,4,7 \
        | sort \
        | column -t \
        | cat -n

    if [[ "false" == "$GTB_YES" ]]
    then
        read -p "about to DELETE ${students_count} students from their orgs? (y|n) " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]
        then
            return 1
        fi
    fi

    echo "$student_lines" \
        | _gtb_cuts 2,4 \
        | env_parallel \
            $GTB_PARALLEL_OPT_PROGRESS_BAR \
            --colsep ' ' \
            --linebuffer \
            --jobs $JOBS \
            gh_remove_user_from_org {1} {2}
}

_gtb_student_org_delete() {
    local student_lines=$(_gtb_filter_students "$@")
    assert_not_empty "error: cannot find any students with filters: '$@'!" "$student_lines"

    echo "$student_lines" \
        | _gtb_cuts 2 \
        | env_parallel \
            --linebuffer \
            --jobs 1 \
            $GTB_PARALLEL_OPT_PROGRESS_BAR \
            _gtb_open "https://github.com/organizations/{}/settings/profile#rename-org-dialog"
}

_gtb_student_org_check() {
    local TRAINER_FULLNAME
    local ORG_CHECK_RESULT
    local MEMBER_CHECK_RESULT

    if _gtb_trainer_show "$1" 1>/dev/null 2>&1; then
        TRAINER_FULLNAME="$1"
        shift
    fi

    if [[ "$CHECK_ROLE_ONLY" == "false" ]]; then
        header "Checking presence of student org..."
        ORG_CHECK_RESULT="$(_gtb_check_student_org_for_presence "$@")"
    else
        ORG_CHECK_RESULT="$(_gtb_filter_students "$@" \
            | cut -d' ' -f'2,7' \
            | sed 's/^/no_check /')"
    fi

    ORG_CHECK_RESULT="$(echo "$ORG_CHECK_RESULT" | sort -k'3,3')"

    if [[ -z "$TRAINER_FULLNAME" ]]; then
        MEMBER_CHECK_RESULT=""
    else
        header "Checking trainer's role in student org..."
        MEMBER_CHECK_RESULT="$(_gtb_check_student_org_for_trainer_role "$TRAINER_FULLNAME" "$@")"
    fi

    MEMBER_CHECK_RESULT="$(echo "$MEMBER_CHECK_RESULT" | sort -k'4,4')"

    join -1 3 -2 4 -a 1 -o '2.1,2.2,1.3,1.2,1.1,2.5,2.6' -e 'ERROR' \
        <(echo "$ORG_CHECK_RESULT") \
        <(echo "$MEMBER_CHECK_RESULT") \
        | sort -k5,7 -k4,4 -k3,3 \
        | _gtb_table_format \
        | _gtb_highlight \
            'created' green \
            'not_found' red \
            'no_check' yellow \
            'admin' green \
            'active' green \
            'pending' blue \
            'member' yellow \
            'not_a_member' red \
            '404' red \
            'ERROR' red
}

_gtb_student_org_open() {
    local student_lines=$(_gtb_filter_students "$@")
    assert_not_empty "error: cannot find any students with filters: '$@'!" "$student_lines"

    echo "$student_lines" \
        | _gtb_cuts 2 \
        | env_parallel \
            --linebuffer \
            --jobs 1 \
            $GTB_PARALLEL_OPT_PROGRESS_BAR \
            _gtb_open "https://github.com/{}"
}

_gtb_student_org() {
    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_student_user_check() {
    local student_lines=$(_gtb_filter_students "$@")
    assert_not_empty "error: cannot find any students with filters: '$@'!" "$student_lines"

    echo "$student_lines" \
        | env_parallel \
            --linebuffer \
            --jobs $JOBS \
            --colsep ' ' \
            $GTB_PARALLEL_OPT_PROGRESS_BAR \
            gh_check_user "{4}" "{2}" "{7}" \
        | _gtb_sort '1,1r;3;3' \
        | _gtb_table_format \
        | _gtb_tr_symbols
}

_gtb_student_user() {
    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_student_repo_update() {
    AUTO_UPDATE="true"
    REPO_NAME=${1:?Repo name is required! (e.g. B-spring-config-homework, F-jest-homework, etc.)}
    shift

    clone_or_update_repos "$@"
}

_gtb_student_repo_clone() {
    REPO_NAME=${1:?Repo name is required! (e.g. homework-xxx-xxx, assignment-xxx-xxx, etc.)}
    shift

    clone_or_update_repos "$@"
}

_gtb_student_repo_delete() {
    local REPO_NAME=${1:?Repo name is required!}
    shift

    local student_lines=$(_gtb_filter_students "$@")
    local students_count=$(_gtb_count_lines "$student_lines")
    assert_not_empty "error: cannot find any students with filters: '$@'!" "$student_lines"


    echo "$student_lines" | _gtb_table_format
    read -p "Are you SURE to delete repo '$(red $REPO_NAME)' from above $(red $students_count) students? (y|n) " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]
    then
        return 1
    fi

    echo "$student_lines" | cut -d' ' -f2 \
        | _gtb_remove_remote_student_repo $REPO_NAME \
        | env_parallel --jobs $JOBS --colsep ' ' $GTB_PARALLEL_OPT_PROGRESS_BAR --linebuffer gh_delete_repo {1} {2} \
        | _gtb_table_format
}

_gtb_student_repo_remove() {
    _gtb_student_repo_delete "$@"
}

_gtb_student_repo_create() {
    local REPO_NAMES=${GTB_REPO:?repo names should be provided using --repo option. (e.g. --repo 'bronze-java-level-1', --repo 'bronze-java-level-1,bronze-java-level-2'}

    local student_lines=$(_gtb_filter_students "$@")
    assert_not_empty "error: cannot find any students with filters: '$@'!" "$student_lines"

    env_parallel \
        $GTB_PARALLEL_OPT_PROGRESS_BAR \
        --linebuffer \
        --jobs $JOBS \
        gh_create_org_repo \
        :::: <(echo "$student_lines" | _gtb_cuts 2) \
        :::: <(echo "$REPO_NAMES" | tr ',; ' '\n')
}

_format_repo_time_fields() {
    if [[ "$GTB_LOCAL" != "true" ]]
    then
        cat
        return
    fi

    while read -r f1 f2 f3 created_at rest
    do
        echo "$f1 $f2 $f3 $(_gtb_time_format_convert_time_zone $created_at)"
    done
}

_gtb_student_repo_stat() {
    local student_lines=$(_gtb_filter_students "$@")

    assert_not_empty "error: cannot find any students with filters: '$@'!" "$student_lines"

    local result=$(echo "$student_lines" \
        | cut -d' ' -f2 \
        | env_parallel \
            --jobs $JOBS \
            --colsep ' ' \
            $GTB_PARALLEL_OPT_PROGRESS_BAR --linebuffer \
            gh_list_org_repos {1})

    pr -m -t \
        <(echo "$result" | cut -d' ' -f1 | sort | uniq -c | sort -nr) \
        <(echo "$result" | cut -d' ' -f2 | sort | uniq -c | sort -nr) \
        | nl
}

_gtb_sort() {
    local DEFAULT_SORT_ORDER="${1:?default sort keys are required! (e.g. '9,9nr;2,2')}"
    local FIELD_SEPARATOR="${2}"

    GTB_SORT_ORDER=${GTB_SORT_ORDER:-$DEFAULT_SORT_ORDER}

    local SORT_KEYS=""
    for KEY in $(echo $GTB_SORT_ORDER | tr ';%' ' ')
    do
        SORT_KEYS="$SORT_KEYS -k${KEY}"
    done

    if [[ -z "$FIELD_SEPARATOR" ]]
    then
        cat | LC_ALL=C sort $SORT_KEYS
    else
        cat | LC_ALL=C sort -t"$FIELD_SEPARATOR" $SORT_KEYS
    fi
}

_gtb_student_repo_list() {
    local student_orgs=$(_gtb_filter_students "$@" | cut -d' ' -f2)
    assert_not_empty "error: cannot find any students with filters: '$@'!" "$student_orgs"

    echo "$student_orgs" \
        | env_parallel \
            --jobs $JOBS \
            --colsep ' ' \
            $GTB_PARALLEL_OPT_PROGRESS_BAR --linebuffer \
            gh_list_org_repos {1} \
        | _format_repo_time_fields \
        | _gtb_sort "4,4;2,2" \
        | _gtb_cuts "${GTB_FIELDS:-1-}" \
        | _gtb_table_format \
        | sed "s/ public / $(red public) /"
}

_gtb_student_repo_check() {
    local -r REPO_NAME=${1:?Repo name is required!}
    shift 1

    local -r REPO_DIR=$(_gtb_default_repo_dir $REPO_NAME)
    if [[ -d $REPO_DIR ]]; then
        _gtb_update_default_repo "${REPO_NAME}"
    else
        _gtb_clone_default_repo "${REPO_NAME}"
    fi

    local COMMIT_REF=$(_gtb_last_commit_of_branch $REPO_NAME origin/master)
    local student_lines=$(_gtb_filter_students "$@")

    join -1 1 -2 2 -a 1 -o '2.1,1.1' -e 'NotFound' \
        <(echo "$student_lines" | cut -d' ' -f2 | sort) \
        <(echo "$student_lines" | cut -d' ' -f2 \
            | env_parallel --jobs $JOBS $GTB_PARALLEL_OPT_PROGRESS_BAR --linebuffer gh_show_org_repo_commit {1} $REPO_NAME $COMMIT_REF \
            | sort -k2) \
        | _gtb_sort "1,1r;2,2" \
        | _gtb_table_format \
        | _gtb_highlight \
            'OK' green \
            'ERROR' red
}

_gtb_student_repo_show() {
    local REPO_NAME=${GTB_REPO:?repo name should be provided using --repo option.}

    local student_lines="$(_gtb_filter_students "$@")"

    echo "$student_lines" \
        | cut -d' ' -f2 \
        | env_parallel --jobs $JOBS $GTB_PARALLEL_OPT_PROGRESS_BAR --linebuffer gh_show_org_repo {1} $REPO_NAME \
        | _gtb_sort "${GTB_SORT_ORDER:-3,3;1,1}" \
        | _gtb_cuts "${GTB_FIELDS:-1-}" \
        | _gtb_table_format \
        | _gtb_highlight \
            "$STATUS_FOUND" green \
            "$STATUS_NOT_FOUND" red
}

_gtb_student_repo_open() {
    local REPO_NAME=${1:?Repo name is required!}
    shift

    if [[ $# -eq 0 ]]; then
        fail 'At least one filter is required to match student with name, term, or tags, etc. (e.g. gtb student repo open bronze-java-level-1 zhang.san)'
    fi

    _gtb_filter_students "$@" \
        | _gtb_cuts 2 \
        | env_parallel \
            --linebuffer \
            --jobs 1 \
            $GTB_PARALLEL_OPT_PROGRESS_BAR \
            _gtb_open "https://github.com/{}/$REPO_NAME"
}

_gtb_student_repo() {
    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_student_group() {
    local GROUPS_COUNT=${1:?error: <GROUPS_COUNT> is required!}
    shift

    _gtb_filter_students "$@" | \
        shuf | \
        cut -d' ' -f2 | \
        xargs -n$GROUPS_COUNT echo | \
        datamash transpose --no-strict -t' ' | \
        sed 's: N/A::' | \
        _gtb_table_format
}

_gtb_count_lines() {
    if [[ -z "$*" ]]; then
        echo 0
        return
    fi
    echo "$*" | wc -l | tr -d ' '
}

_gtb_student_quit() {
    local student_lines=$(_gtb_filter_students "$@")
    assert_not_empty "error: cannot find any students with filters: '$@'!" "$student_lines"

    local students_count=$(_gtb_count_lines "$student_lines")
    [[ 1 -ne "$students_count" ]] && fail "error: $students_count lines filtered with filter: '$@', should match exactly one line!"

    echo "$student_lines" \
        | sort \
        | _gtb_table_format

    if [[ "false" == "$GTB_YES" ]]
    then
        read -p "about to QUIT above $(red ${students_count}) students? (y|n) " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]
        then
            return 1
        fi
    fi

    local students_name=$(echo "$student_lines" | _gtb_cuts 1)
    if [[ $students_name != "$GTB_PY_NAME_DEFAULT" ]]
    then
        info "Remove from coachee GitHub org..."
        _gtb_student_org_remove "$@"

        echo "Check whether coachee removed from GitHub org..."
        gh_check_user_not_in_org "$@"

        while read -r STUDENT_FULLNAME ORG_NAME OTHER; do
            while read -r BUDDY_NAME BUDDEE_NAME; do
                info "Delete mapping to buddy '${BUDDY_NAME}' ..."
                GTB_BUDDY_FILTER="${BUDDY_NAME}" _gtb_buddy_mapping_remove "${BUDDEE_NAME}"
            done < <(_gtb_filter_buddies_mapping "2" "${STUDENT_FULLNAME}")

            info "Show existing assignment submissions..."
            GTB_FIELDS="1-4,6-8" _gtb_assignment_submission_list "${STUDENT_FULLNAME}"

            info "Delete assignment submissions..."
            GTB_ORG_NAME="${ORG_NAME}" _gtb_assignment_submission_delete
        done < <(echo "${student_lines}")

        for BOARD_NAME in $(_gtb_trello boards); do
            info "Remove from Trello board '$BOARD_NAME' ..."
            GTB_TRELLO_BOARD_NAME="${BOARD_NAME}"
            _gtb_trello board remove "$@"
        done
    fi

    _gtb_student_quit_remove_from_config "$@"
}

_gtb_student_quit_remove_from_config() {
    info "Delete from student file ..."
    _gtb_student_delete "$@"

    info "Commit changes and push ..."
    _gtb_config_diff
    _gtb_config_commit "chore: $GTB_TERM quit students $@"
    _gtb_config_push
}

_gtb_student_delete() {
    local student_lines=$(_gtb_filter_students "$@")
    assert_not_empty "error: cannot find any students with filters: '$@'!" "$student_lines"

    local students_count=$(_gtb_count_lines "$student_lines")

    echo "$student_lines" \
        | sort \
        | _gtb_table_format

    if [[ "false" == "$GTB_YES" ]]
    then
        read -p "about to DELETE $(red ${students_count}) students from $(red $GTB_STUDENTS_FILE)? (y|n) " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]
        then
            return 1
        fi
    fi

    echo "$student_lines" \
        | _gtb_cuts 7 \
        | env_parallel \
            $GTB_PARALLEL_OPT_PROGRESS_BAR \
            --linebuffer \
            --jobs 1 \
            "sed -i.bak -E '/ {} /d' '$GTB_STUDENTS_FILE'"
}

_gtb_student_remove() {
    _gtb_student_delete "$@"
}

_gtb_student_register() {
    local -r PY_NAME="${1:?PinYin name is PinYin is required!}"
    local -r CN_NAME="${2:?chinese name is required!}"
    local -r GITHUB_USERNAME="${3:?GitHub username is required!}"
    local -r TRELLO_EMAIL="${4:?Trello email is required!}"
    local -r UPDATED_AT="$(gdate --iso-8601=seconds)"

    assert_value_exists_in_file $GTB_STUDENTS_FILE 7 "$CN_NAME"

    assert_value_is_uniq_in_file <(grep -v " $CN_NAME " $GTB_STUDENTS_FILE) 1 $PY_NAME
    assert_value_is_uniq_in_file <(grep -v " $CN_NAME " $GTB_STUDENTS_FILE) 4 $GITHUB_USERNAME
    assert_value_is_uniq_in_file <(grep -v " $CN_NAME " $GTB_STUDENTS_FILE) 5 $TRELLO_EMAIL

    gawk -i inplace \
        -v CN_NAME="$CN_NAME" \
        -v PY_NAME="$PY_NAME" \
        -v GITHUB_USERNAME="$GITHUB_USERNAME" \
        -v GITHUB_ORG_NAME="${GTB_TERM}-${PY_NAME//./-}" \
        -v TRELLO_EMAIL="$TRELLO_EMAIL" \
        -v UPDATED_AT="$UPDATED_AT" \
        '{ if ($7 == CN_NAME) { $1=PY_NAME; $2=GITHUB_ORG_NAME; $4=GITHUB_USERNAME; $5=TRELLO_EMAIL; $1=$1; $0=$0; print $0, UPDATED_AT; } else { print $0; } }' \
        "$GTB_STUDENTS_FILE"

    LC_ALL=C sort -u --output $GTB_STUDENTS_FILE $GTB_STUDENTS_FILE
}

_gtb_student_add() {
    local -r CN_NAME="${1:?chinese name is required!}"
    local -r BACKGROUND="${2:?background is required!}"
    local -r OFFICE="${3:?office is required!}"
    local -r UNIT="${4:?unit is required!}"
    local -r JOIN_ON="${5:?join date is required!}"
    local -r WEEK_NUM="$(gdate --date=${JOIN_ON} +%V)"
    local -r TYPE="${6:-formal}" # default to formal, but can be informal

    local -r ENTRY_DATE="9999-12-31"
    local -r TWU_TERM="twu"
    local -r PY_NAME="~PINYIN_NAME~"
    local -r GITHUB_USERNAME="_GITHUB_USERNAME_"
    local -r TRELLO_EMAIL="_TRELLO_EMAIL_"

    assert_value_is_uniq_in_file $GTB_STUDENTS_FILE 7 $CN_NAME

    echo "$PY_NAME ${GTB_TERM}-${PY_NAME//./-} $GTB_TERM $GITHUB_USERNAME $TRELLO_EMAIL $TWU_TERM $CN_NAME $BACKGROUND $OFFICE $UNIT $WEEK_NUM $JOIN_ON $TYPE $ENTRY_DATE" >> $GTB_STUDENTS_FILE
    LC_ALL=C sort -u --output $GTB_STUDENTS_FILE $GTB_STUDENTS_FILE
}

_gtb_student_list_format() {
    if [[ "$GTB_RAW" == "true" ]]
    then
        cat
        return 0
    fi

    cat | tr ' ' '|' | sort | _gtb_tabularize | cat -n
}

_gtb_student_list() {
    _gtb_filter_students "$@" \
        | _gtb_student_reorder_columns \
        | _gtb_sort "${GTB_SORT_ORDER:-13,13;12,12;2,2}" \
        | _gtb_cuts "${GTB_FIELDS:-1-10,12-14}" \
        | _gtb_table_format
}

_gtb_student_show_format() {
    cat | tr ' ' '\n' | cat -n
}

_gtb_student_show() {
    local -r FULLNAME=${1:?fullname is required! (e.g. zhang.san, li.si, etc.)}

    local -r FILTERED_LINES=$(_gtb_filter_students "${FULLNAME}")
    local -r COUNT=$(_gtb_count_lines "$FILTERED_LINES")
    [[ 1 -ne $COUNT ]] && fail "error: $COUNT lines filtered with filter: '${FULLNAME}', should match exactly one line!"

    echo "$FILTERED_LINES" \
        | _gtb_student_reorder_columns \
        | tr ' ' '\n' \
        | _gtb_table_format
}

_gtb_student_reorder_columns() {
    cat | awk '{fullname=$1;owner=$2;term_name=$3;username=$4;$1=$2=$3=$4="";$0=$0;$1=$1;print term_name, fullname, owner, username, $0}'
}

_gtb_student() {
    assert_students_file_exists

    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_stu() {
    _gtb_student "$@"
}

_gtb_st() {
    _gtb_student "$@"
}

remove_repo_from_team() {
    local ORG=$1
    local TEAM=$2
    local REPO=$3
    local ENDPOINT="/orgs/$ORG/teams/$TEAM/repos/$ORG/$REPO"

    run "gh api --silent -X DELETE $ENDPOINT"

    [[ $? -eq 0 ]] && info "DONE" || error "FAILED"
}

_gtb_actions_url() {
    local ORG=${1:?Org is required!}
    local REPO_NAME=${2:?Repo name is required!}

    echo "https://github.com/$ORG/$REPO_NAME/actions"
}

_gtb_push_to_student_repo() {
    local ORG=${1:?Org is required!}
    local REPO_NAME=${2:?Repo name is required!}
    local DST_BRANCH
    local OPTION_FORCE

    cd $(_gtb_default_repo_dir $REPO_NAME)

    local BRANCHES=$(_git_list_all_branches_of_remote 'origin')
    for BRANCH in ${BRANCHES}
    do
        if [[ "$GTB_ALL_BRANCHES" == "true" ]] || [[ "${BRANCH}" == "master" ]]; then
            if [[ "$GTB_FORCE" == "true" ]]; then
                DST_BRANCH="_${BRANCH}"
                OPTION_FORCE='--force'
            else
                DST_BRANCH="${BRANCH}"
                OPTION_FORCE=''
            fi
            run "git push $OPTION_FORCE $ORG origin/${BRANCH}:refs/heads/${DST_BRANCH} $(_gtb_mute_stderr)"
        fi
    done

    echo $*
}

_gtb_last_commit_of_branch() {
    local REPO_NAME=${1:?Repo name is required!}
    local BRANCH=${2:?Branch name is required!}
    local REPO_DIR=$(_gtb_default_repo_dir $REPO_NAME)

    [[ -d $REPO_DIR ]] || fail "Cannot find local directory for repo '$REPO_NAME'!"

    cd $REPO_DIR

    if ! git remote | grep --silent "$ORG"; then
        return 0
    fi

    run "git rev-parse $BRANCH"
}

_gtb_remove_remote_student_repo() {
    local REPO_NAME=${1:?Repo name is required!}
    local REPO_DIR=$(_gtb_default_repo_dir $REPO_NAME)

    if [[ ! -d $REPO_DIR ]]
    then
        warn 'skip repo that not found in default repo dir.'
        cat | sed "s/$/ $REPO_NAME/"
        return 0
    fi

    run "cd $REPO_DIR"

    while read -r ORG
    do
        run "git remote remove $ORG 2>/dev/null"
        echo $ORG $REPO_NAME
    done
}

_gtb_add_student_repo_as_remote() {
    local ORG=${1:?org name is required!}
    local REPO_NAME=${2:?Repo name is required!}

    local REPO_DIR=$(_gtb_default_repo_dir $REPO_NAME)
    [[ -d $REPO_DIR ]] || fail "Cannot find local directory for repo '$REPO_NAME'!"

    run "cd $REPO_DIR"

    local REMOTES=$(run "git remote")

    if ! echo "$REMOTES" | grep --silent "$ORG"; then
        local repo_url="git@github.com:$ORG/${REPO_NAME}.git"
        run "git remote add $ORG $repo_url" >&2
    fi

    if [[ $? -eq 0 ]]
    then
        echo "$* $SYMBOL_OK"
    else
        echo "$* $SYMBOL_ERROR"
    fi
}

_gtb_fetch_remote() {
    local REPO_NAME=${1:?Repo name is required!}
    local ORG=${2:?org name is required!}

    local REPO_DIR=$(_gtb_default_repo_dir $REPO_NAME)
    [[ -d $REPO_DIR ]] || fail "Cannot find local directory for repo '$REPO_NAME'!"

    run "cd $REPO_DIR"
    run "git fetch $ORG" >&2

    if [[ $? -eq 0 ]]
    then
        echo "$SYMBOL_OK $ORG"
    else
        echo "$SYMBOL_ERROR $ORG"
    fi
}

_gtb_create_local_branch() {
    local REPO_NAME=${1:?Repo name is required!}
    local ORG=${2:?org name is required!}

    local REPO_DIR=$(_gtb_default_repo_dir $REPO_NAME)
    [[ -d $REPO_DIR ]] || fail "Cannot find local directory for repo '$REPO_NAME'!"

    run "cd $REPO_DIR"
    run "git checkout -b $ORG $ORG/master" >&2

    if [[ $? -eq 0 ]]
    then
        echo "$SYMBOL_OK $ORG"
    else
        echo "$SYMBOL_ERROR $ORG"
    fi
}

_gtb_pick_refs() {
    local REPO_NAME=${1:?Repo name is required!}
    local ORG=${2:?org name is required!}

    shift 2

    local REPO_DIR=$(_gtb_default_repo_dir $REPO_NAME)
    [[ -d $REPO_DIR ]] || fail "Cannot find local directory for repo '$REPO_NAME'!"

    run "cd $REPO_DIR"
    run "git cherry-pick --abort" >&2
    run "git checkout $ORG" >&2 \
        && run "git cherry-pick --ff --allow-empty --keep-redundant-commits $*" >&2

    if [[ $? -eq 0 ]]
    then
        echo "$SYMBOL_OK $ORG"
    else
        run "git cherry-pick --abort" >&2
        echo "$SYMBOL_ERROR $ORG"
    fi
}

_gtb_push_master() {
    local REPO_NAME=${1:?Repo name is required!}
    local ORG=${2:?org name is required!}

    local REPO_DIR=$(_gtb_default_repo_dir $REPO_NAME)
    [[ -d $REPO_DIR ]] || fail "Cannot find local directory for repo '$REPO_NAME'!"

    run "cd $REPO_DIR"
    run "git push $ORG $ORG:master" >&2

    if [[ -n $BRANCH_NAME ]]
    then
        run "git push --force $ORG ${ORG}:refs/heads/${BRANCH_NAME}" >&2
    fi

    if [[ $? -eq 0 ]]
    then
        echo "$SYMBOL_OK $ORG"
    else
        echo "$SYMBOL_ERROR $ORG"
    fi
}

_gtb_delete_existing_remote() {
    local REPO_NAME=${1:?Repo name is required!}
    local REPO_DIR=$(_gtb_default_repo_dir $REPO_NAME)
    [[ -d $REPO_DIR ]] || fail "Cannot find local directory for repo '$REPO_NAME'!"

    run "cd $REPO_DIR"

    while read -r FULLNAME ORG TERM_NAME
    do
        run "git remote remove $ORG 2>/dev/null"
        echo $ORG $REPO_NAME $TERM_NAME $FULLNAME
    done
}

_gtb_create_repo_in_student_org() {
    local ORG=${1:?Org is required!}
    local REPO_NAME=${2:?Repo name is required!}

    gh_create_org_repo $ORG $REPO_NAME
    local result=$?
    if [[ $result -ne 0 ]]; then
        error "Failed to create repo '$REPO_NAME' in '$ORG'."
        return $result
    fi

    echo $*
}

_gtb_clone_default_repo() {
    local REPO_NAME=${1:?Repo name is required!}
    local repo_dir=$(_gtb_default_repo_dir $REPO_NAME)

    [[ -d $repo_dir ]] && run "rm -rf '$repo_dir'"

    gh_clone_repo $GTB_ORG $REPO_NAME $repo_dir

    if [[ $? -ne 0 ]]; then
        fail "Failed to clone repo $REPO_NAME to $repo_dir"
    fi
}

_gtb_update_default_repo() {
    local REPO_NAME=${1:?Repo name is required!}
    local repo_dir=$(_gtb_default_repo_dir $REPO_NAME)

    run "cd $repo_dir"
    run "git fetch origin --prune --prune-tags"
}

_gtb_repo_pick() {
    local REPO_NAME=${GTB_REPO:?repo name should be provided using --repo option.}

    local student_lines=$(_gtb_filter_students "$@")
    local students_count=$(_gtb_count_lines "$student_lines")
    assert_not_empty "error: cannot find any students with filters: '$@'!" "$student_lines"

    header "Verifying refs '$GTB_REFS'..."
    local commits_to_pick=$(_gtb_git_verify_refs "$REPO_NAME" "$GTB_REFS")
    if [[ -z "$commits_to_pick" ]]; then
        fail 'error: no valid commits is to be picked not provided. (e.g. gtb student repo pick --refs "origin/extended-tests" ...)'
    fi

    echo "$student_lines" | _gtb_cuts 3,2,1,7,8,9 | _gtb_table_format
    echo
    echo "$commits_to_pick" | tr ' ' '\n' | _gtb_nl

    if [[ "false" == "$GTB_YES" ]]
    then
        read -p "about to pick these refs to above $(red $students_count) students? (y|n) " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]
        then
            return 1
        fi
    fi

    header "Clone repo $REPO_NAME..."
    _gtb_clone_default_repo $REPO_NAME

    header "Filter students..."
    local student_lines=$(_gtb_filter_students "$@")
    local students_count=$(_gtb_count_lines "$student_lines")

    [[ $students_count -eq 0 ]] && fail "error: no students matched by filters: '$@'"

    header "Add students' repo as remote..."
    local result_add_remote=$(echo "$student_lines" \
        | _gtb_cuts 1-2 \
        | env_parallel --jobs 1 --colsep ' ' $GTB_PARALLEL_OPT_PROGRESS_BAR --linebuffer "_gtb_add_student_repo_as_remote {2} $REPO_NAME $(_gtb_mute_stderr)" \
        | sort \
        | _gtb_cuts 3)

    header "Fetch all remotes..."
    local result_fetch_remote=$(echo "$student_lines" \
        | _gtb_cuts 1-2 \
        | env_parallel --jobs $JOBS --colsep ' ' $GTB_PARALLEL_OPT_PROGRESS_BAR --linebuffer "_gtb_fetch_remote $REPO_NAME {2} $(_gtb_mute_stderr)" \
        | sort -k2 \
        | _gtb_cuts 1)

    header "Create local branches..."
    local result_create_branch=$(echo "$student_lines" \
        | _gtb_cuts 1-2 \
        | env_parallel --jobs 1 --colsep ' ' $GTB_PARALLEL_OPT_PROGRESS_BAR --linebuffer "_gtb_create_local_branch $REPO_NAME {2} $(_gtb_mute_stderr)" \
        | sort -k2 \
        | _gtb_cuts 1)

    header "Pick refs..."
    local result_pick_ref=$(echo "$student_lines" \
        | _gtb_cuts 1-2 \
        | env_parallel --jobs 1 --colsep ' ' $GTB_PARALLEL_OPT_PROGRESS_BAR --linebuffer "_gtb_pick_refs $REPO_NAME {2} $commits_to_pick $(_gtb_mute_stderr)" \
        | sort -k2 \
        | _gtb_cuts 1)

    header "Push to remotes..."
    local result_push_to_remote=$(echo "$student_lines" \
        | _gtb_cuts 1-2 \
        | env_parallel --jobs $JOBS --colsep ' ' $GTB_PARALLEL_OPT_PROGRESS_BAR --linebuffer "_gtb_push_master $REPO_NAME {2} $(_gtb_mute_stderr)" \
        | sort -k2 \
        | _gtb_cuts 1)

    {
        echo "ID ORG ADD FETCH BRANCH PICK PUSH"
        pr -m -t -s' ' \
            <(echo "$student_lines" | _gtb_cuts 2 | sort) \
            <(echo "$result_add_remote") \
            <(echo "$result_fetch_remote") \
            <(echo "$result_create_branch") \
            <(echo "$result_pick_ref") \
            <(echo "$result_push_to_remote") \
            | _gtb_nl
    } | _gtb_table_format -N \
        | _gtb_auto_notify
}

_gtb_repo_publish() {
    local REPO_NAME=$1
    shift

    local student_lines=$(_gtb_filter_students "$@")
    local students_count=$(_gtb_count_lines "$student_lines")
    assert_not_empty "error: cannot find any students with filters: '$@'!" "$student_lines"

    echo "$student_lines" | _gtb_cuts 3,2,1,7,8,9 | _gtb_table_format

    if [[ "false" == "$GTB_YES" ]]
    then
        read -p "about to publish repo '$(red $REPO_NAME)' to above $(red $students_count) students? (y|n) " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]
        then
            return 1
        fi
    fi

    header "Clone repo $REPO_NAME..."
    _gtb_clone_default_repo $REPO_NAME

    local MAX_JOBS=$JOBS
    if [[ $MAX_JOBS -gt 20 ]]
    then
        MAX_JOBS=20
    fi

    header "Create repo $REPO_NAME in student's org..."
    echo "$student_lines" | cut -d' ' -f1-3 \
        | env_parallel --jobs $JOBS --colsep ' ' $GTB_PARALLEL_OPT_PROGRESS_BAR --linebuffer "_gtb_create_repo_in_student_org {2} $REPO_NAME $(_gtb_mute_stderr) 1>&2"

    header "Add student's repo as remote..."
    echo "$student_lines" | cut -d' ' -f1-3 \
        | env_parallel --jobs 1 --colsep ' ' $GTB_PARALLEL_OPT_PROGRESS_BAR --linebuffer "_gtb_add_student_repo_as_remote {2} $REPO_NAME $(_gtb_mute_stderr) 1>&2"

    header "Push commits to student's repo..."
    local result_push=$(echo "$student_lines" | cut -d' ' -f1-3 \
        | env_parallel --jobs $JOBS --colsep ' ' $GTB_PARALLEL_OPT_PROGRESS_BAR --linebuffer "_gtb_push_to_student_repo {2} $REPO_NAME $(_gtb_mute_stderr)")

    local RAW="$GTB_RAW"
    GTB_RAW="true"
    header "Check commits of student's repo..."
    local result_of_repo_check=$(_gtb_student_repo_check $REPO_NAME "$@" | sort -k2 | _gtb_cuts 1)
    GTB_RAW="$RAW"

    {
        echo 'No. Student LastCommit'
        pr -m -t -s' ' \
            <(echo "$student_lines" | _gtb_cuts 2 | sort) \
            <(echo "$result_of_repo_check") \
            | _gtb_sort "${GTB_SORT_ORDER:-2,2r;1,1}" \
            | _gtb_nl
    } | _gtb_table_format -N \
        | _gtb_highlight \
            'OK' green \
            'ERROR' red \
        | _gtb_auto_notify
}

_gtb_repo_remove() {
    local ORG=${1:?Organization is required!}
    shift
    local TEAM=${1:?Team is required!}
    shift

    if [[ -p /dev/stdin ]]
    then
        while read line
        do
            for repo in $line
            do
                remove_repo_from_team $ORG $TEAM $repo
            done
        done
    fi

    for repo in "$@"
    do
        remove_repo_from_team $ORG $TEAM $repo
    done
}

add_repo_to_team() {
    local ORG=$1
    local TEAM=$2
    local REPO=$3
    local ENDPOINT="/orgs/$ORG/teams/$TEAM/repos/$ORG/$REPO"

    run "gh api --silent -X PUT $ENDPOINT -F permission='pull'"

    [[ $? -eq 0 ]] && info "DONE" || error "FAILED"
}

_gtb_repo_add() {
    local TEAM=${1:?Team is required!}
    shift

    if [[ -p /dev/stdin ]]
    then
        while read line
        do
            for repo in $line
            do
                add_repo_to_team $GTB_ORG $TEAM $repo
            done
        done
    fi


    for repo in "$@"
    do
        add_repo_to_team $GTB_ORG $TEAM $repo
    done
}

_gtb_repo_list() {
    gh_list_org_repos \
        | sort -k2,2 \
        | _format_repo_time_fields \
        | _gtb_sort '3,3;1,2' \
        | _gtb_table_format \
        | _gtb_highlight \
            'public' red
}

_gtb_repo_check() {
    local REPO_NAME="${1:?Repo name is required!}"

    gh_show_org_repo "${GTB_ORG}" "${REPO_NAME}" \
        | _gtb_highlight \
            "${STATUS_NOT_FOUND}" red
}

_gtb_repo() {
    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_org_team_open() {
    run "open https://github.com/orgs/${GTB_ORG}/teams/${GTB_TERM}/members"
}

_gtb_org_team_invite() {
    GTB_ORG_TEAM=${GTB_ORG_TEAM:-$GTB_TERM}

    if [[ "true" == "$GTB_FROM_BUDDIES" ]]; then
        local buddy_lines=$(_gtb_filter_buddies "$@")
        local buddies_count=$(_gtb_count_lines "$buddy_lines")
        assert_not_empty "error: cannot find any buddies with filters: '$@'!" "$buddy_lines"

        echo "$buddy_lines" \
            | env_parallel \
            --linebuffer \
            --jobs $JOBS \
            --colsep ' ' \
            $GTB_PARALLEL_OPT_PROGRESS_BAR \
            gh_invite_user_to_team "$GTB_ORG" "$GTB_ORG_TEAM" "{5}" "{2}" \
            | _gtb_sort '1,1r;4,4' \
            | _gtb_table_format \
            | _gtb_tr_symbols
    else
        local student_lines=$(_gtb_filter_students "$@")
        local students_count=$(_gtb_count_lines "$student_lines")
        assert_not_empty "error: cannot find any students with filters: '$@'!" "$student_lines"

        echo "$student_lines" \
            | env_parallel \
            --linebuffer \
            --jobs $JOBS \
            --colsep ' ' \
            $GTB_PARALLEL_OPT_PROGRESS_BAR \
            gh_invite_user_to_team "$GTB_ORG" "$GTB_ORG_TEAM" "{4}" "{2}" "{7}" \
            | _gtb_sort '1,1r;4,4' \
            | _gtb_table_format \
            | _gtb_tr_symbols
    fi
}

_gtb_org_team_members() {
    (
    echo 'No. Config Github Student'
    join -1 5 -2 2 -a 1 -a 2 -o '1.1,2.1,0,1.3,1.2,1.6,1.7' -e 'NO' \
        <(_gtb_filter_students | sort -k4 | sed 's/^/YES /') \
        <(gh_list_org_team_members $GTB_ORG $GTB_TERM | sort | sed 's/^/YES /') \
        | sort -k1,2 -r \
        | _gtb_nl
    ) | _gtb_table_format -N
}

_gtb_org_team_list() {
    local ORG=${1:-$GTB_ORG}
    gh_list_org_teams $ORG
}

_gtb_org_team() {
    if ! echo $1 | grep --silent '^\(list\|open\|invite\|members\)$'; then
        set -- open "$@"
    fi

    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_org_user() {
    if ! echo $1 | grep --silent '^\(check\)$'; then
        set -- open "$@"
    fi

    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_org_remove() {
    local student_lines=$(_gtb_filter_students "$@")
    local students_count=$(_gtb_count_lines "$student_lines")

    echo "$student_lines" \
        | _gtb_cuts 2,4,7 \
        | sort \
        | column -t \
        | cat -n

    if [[ "false" == "$GTB_YES" ]]
    then
        read -p "about to DELETE ${students_count} students from $GTB_ORG? (y|n) " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]
        then
            return 1
        fi
    fi

    echo "$student_lines" \
        | _gtb_cuts 2,4 \
        | env_parallel \
            $GTB_PARALLEL_OPT_PROGRESS_BAR \
            --colsep ' ' \
            --linebuffer \
            --jobs $JOBS \
            gh_remove_user_from_org $GTB_ORG {2}
}

_gtb_org_invite() {
    if [[ "true" == "$GTB_FROM_BUDDIES" ]]; then
        local buddy_lines=$(_gtb_filter_buddies "$@")
        local buddies_count=$(_gtb_count_lines "$buddy_lines")
        assert_not_empty "error: cannot find any buddies with filters: '$@'!" "$buddy_lines"

        echo "$buddy_lines" \
            | env_parallel \
            --linebuffer \
            --jobs $JOBS \
            --colsep ' ' \
            $GTB_PARALLEL_OPT_PROGRESS_BAR \
            gh_invite_user_to_org "$GTB_ORG" "{5}" 'direct_member' "{1}" "{2}" \
            | _gtb_sort '1,1r;5,5' \
            | _gtb_table_format \
            | _gtb_tr_symbols
    else
        local student_lines=$(_gtb_filter_students "$@")
        local students_count=$(_gtb_count_lines "$student_lines")
        assert_not_empty "error: cannot find any students with filters: '$@'!" "$student_lines"

        echo "$student_lines" \
            | env_parallel \
            --linebuffer \
            --jobs $JOBS \
            --colsep ' ' \
            $GTB_PARALLEL_OPT_PROGRESS_BAR \
            gh_invite_user_to_org "$GTB_ORG" "{4}" 'direct_member' "{1}" "{7}" \
            | _gtb_sort '1,1r;5,5' \
            | _gtb_table_format \
            | _gtb_tr_symbols
    fi
}

_gtb_org_members() {
    (
    echo 'No. Config Github Student'
    join -1 5 -2 2 -a 1 -o '1.1,2.1,0,1.3,1.2,1.6,1.7' -e 'NO' \
        <(_gtb_filter_students | sort -k4 | sed 's/^/YES /') \
        <(gh_list_org_members $GTB_ORG | sort | sed 's/^/YES /') \
        | sort -k1,2 -r \
        | _gtb_nl
    ) | _gtb_table_format -N
}

_gtb_org_open() {
    local ORG=${1:-$GTB_ORG}
    run "open https://github.com/${ORG}"
}

_gtb_org() {
    assert_students_file_exists

    if ! echo $1 | grep --silent '^\(open\|invite\|remove\|team\|members\|user\)$'; then
        set -- open "$@"
    fi

    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_trello_board_field_list() {
    local BOARD_ID=$(_gtb_trello_find_board_id "$GTB_TRELLO_BOARD_NAME")

    _gtb_trello_api "/boards/${BOARD_ID}/customFields" \
        | jq -jr '.[] | .name, " ", .type, " ", .id, "\n"' \
        | _gtb_sort "${GTB_SORT_ORDER:-1,1}" \
        | _gtb_cuts "${GTB_FIELDS:-1-}" \
        | _gtb_table_format "$@"
}

_gtb_trello_board_field_id() {
    GTB_TRELLO_BOARD_NAME="${GTB_TRELLO_BOARD_NAME:?Trello board name is required! Specify by --board <NAME>.}"
    local -r FIELD_NAME="${1:?field name is required!}"
    _gtb_trello_api_get_field_id "$FIELD_NAME"
}

_gtb_trello_api_get_field_id() {
    local -r QUERY=${1:?search query is required!}
    local RESULT="$(_gtb_cache_get trello "custom-field-id-${QUERY}")"

    if [[ -n "$RESULT" ]]; then
        echo "$RESULT"
        return 0
    fi

    RESULT=$(_gtb_trello_board_field_list --raw | $GTB_GREP "$QUERY" | _gtb_cuts 3)
    if [[ -n "$RESULT" ]] && [[ 'null' != "$RESULT" ]]; then
        _gtb_cache_set trello "custom-field-id-${QUERY}" "$RESULT"
        echo "$RESULT"
        return 0
    fi

    return 1
}

_gtb_trello_board_field() {
    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_trello_board_label_list() {
    local BOARD_ID=$(_gtb_trello_find_board_id "$GTB_TRELLO_BOARD_NAME")

    _gtb_trello_api "/boards/${BOARD_ID}/labels" \
        | jq -jr $'.[] | .id, " ", .color, " \'", .name, "\'\n"' \
        | _gtb_sort "${GTB_SORT_ORDER:-1,1}" \
        | _gtb_cuts "${GTB_labelS:-1-}" \
        | _gtb_table_format "$@"
}

_gtb_trello_board_label_id() {
    GTB_TRELLO_BOARD_NAME="${GTB_TRELLO_BOARD_NAME:?Trello board name is required! Specify by --board <NAME>.}"
    local -r LABEL_NAME="${1:?label name is required!}"
    _gtb_trello_api_get_label_id "$LABEL_NAME"
}

_gtb_trello_api_get_label_id() {
    local -r QUERY=${1:?search query is required!}
    local RESULT="$(_gtb_cache_get trello "label-id-${QUERY}")"

    if [[ -n "$RESULT" ]]; then
        echo "$RESULT"
        return 0
    fi

    RESULT=$(_gtb_trello_board_label_list --raw | $GTB_GREP "$QUERY" | _gtb_cuts 1)
    if [[ -n "$RESULT" ]] && [[ 'null' != "$RESULT" ]]; then
        _gtb_cache_set trello "label-id-${QUERY}" "$RESULT"
        echo "$RESULT"
        return 0
    fi

    return 1
}

_gtb_trello_board_label() {
    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_trello_card_field_set() {
    GTB_TRELLO_BOARD_NAME="${GTB_TRELLO_BOARD_NAME:?Trello board name is required! Specify by --board <NAME>.}"
    GTB_TRELLO_CARD_ID="${GTB_TRELLO_CARD_ID:?Trello card ID is required! Specify by --card-id <NAME>.}"
    local -r FIELD_NAME="${1:?field name is required!}"
    local -r FIELD_VALUE="${@:2}"

    local -r FIELD_ID="$(_gtb_trello_board_field_id $FIELD_NAME)"
    assert_not_empty "Cannot find custom field '$FIELD_NAME' on board '$GTB_TRELLO_BOARD_NAME'!" "FIELD_ID"

    echo "{\"value\": { \"text\": \"$FIELD_VALUE\" }}" \
        | _gtb_trello_api --stdin --method 'PUT' "/cards/${GTB_TRELLO_CARD_ID}/customField/${FIELD_ID}/item" \
        | jq -jr '"card:", .idModel, " idCustomField:", .idCustomField, " value:", .value.text, "\n"'
}

_gtb_trello_card_field_get() {
    GTB_TRELLO_BOARD_NAME="${GTB_TRELLO_BOARD_NAME:?Trello board name is required! Specify by --board <NAME>.}"
    GTB_TRELLO_CARD_ID="${GTB_TRELLO_CARD_ID:?Trello card ID is required! Specify by --card-id <NAME>.}"
    local -r FIELD_NAME="${1:?field name is required!}"
    local -r FIELD_VALUE="${@:2}"

    local -r FIELD_ID="$(_gtb_trello_board_field_id $FIELD_NAME)"
    assert_not_empty "Cannot find custom field '$FIELD_NAME' on board '$GTB_TRELLO_BOARD_NAME'!" "FIELD_ID"

    _gtb_trello_api "/cards/${GTB_TRELLO_CARD_ID}?customFieldItems=true" \
        | jq -r ".customFieldItems[] | select (.idCustomField == \"${FIELD_ID}\") | .value.text"
}

_gtb_trello_card_field() {
    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_trello_card_label_remove() {
    GTB_TRELLO_BOARD_NAME="${GTB_TRELLO_BOARD_NAME:?Trello board name is required! Specify by --board <NAME>.}"
    GTB_TRELLO_CARD_ID="${GTB_TRELLO_CARD_ID:?Trello card ID is required! Specify by --card-id <NAME>.}"
    local -r LABEL_NAME="${1:?label name is required!}"
    local -r LABEL_VALUE="${@:2}"

    local -r LABEL_ID="$(_gtb_trello_board_label_id $LABEL_NAME)"
    assert_not_empty "Cannot find custom label '$LABEL_NAME' on board '$GTB_TRELLO_BOARD_NAME'!" "LABEL_ID"

    local -r RESULT="$(_gtb_trello_api --method 'DELETE' "/cards/${GTB_TRELLO_CARD_ID}/idLabels/${LABEL_ID}")"

    $GTB_GREP --silent '{"_value":null}' <(echo "$RESULT") && return 0

    fail "Error: failed to remove label '$LABEL_NAME' to card '$GTB_TRELLO_CARD_ID' on board '$GTB_TRELLO_BOARD_NAME'!"
}

_gtb_trello_card_label_add() {
    GTB_TRELLO_BOARD_NAME="${GTB_TRELLO_BOARD_NAME:?Trello board name is required! Specify by --board <NAME>.}"
    GTB_TRELLO_CARD_ID="${GTB_TRELLO_CARD_ID:?Trello card ID is required! Specify by --card-id <NAME>.}"
    local -r LABEL_NAME="${1:?label name is required!}"

    local -r LABEL_ID="$(_gtb_trello_board_label_id $LABEL_NAME)"
    assert_not_empty "Cannot find custom label '$LABEL_NAME' on board '$GTB_TRELLO_BOARD_NAME'!" "LABEL_ID"

    local -r RESULT="$(_gtb_trello_api --method 'POST' "/cards/${GTB_TRELLO_CARD_ID}/idLabels?value=${LABEL_ID}")"

    $GTB_GREP --silent "$LABEL_ID" <(echo "$RESULT") && return 0
    $GTB_GREP --silent "that label is already on the card" <(echo "$RESULT") && return 0

    fail "Error: failed to add label '$LABEL_NAME' to card '$GTB_TRELLO_CARD_ID' on board '$GTB_TRELLO_BOARD_NAME'!"
}

_gtb_trello_card_label_list() {
    GTB_TRELLO_BOARD_NAME="${GTB_TRELLO_BOARD_NAME:?Trello board name is required! Specify by --board <NAME>.}"
    GTB_TRELLO_CARD_ID="${GTB_TRELLO_CARD_ID:?Trello card ID is required! Specify by --card-id <NAME>.}"

    _gtb_trello_api "/cards/${GTB_TRELLO_CARD_ID}" \
        | jq -jr '.labels[] | .color, " ", .name, "\n"'
}

_gtb_trello_card_label() {
    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_trello_card_member_add() {
    GTB_TRELLO_CARD_ID="${GTB_TRELLO_CARD_ID:?Trello card ID is required! Specify by --card-id <ID>.}"

    trello_member_id "$@" \
        | env_parallel \
            --linebuffer \
            --jobs 1 \
            $GTB_PARALLEL_OPT_PROGRESS_BAR \
            "_gtb_trello_api --method 'POST' '/cards/${GTB_TRELLO_CARD_ID}/idMembers?value={1}' 1>/dev/null 2>&1"

    local -r MEMBER_LIST="$(_gtb_trello_card_member_list)"
    echo "${MEMBER_LIST}"

    while read -r MEMBER_ID HINT; do
        if ! $GTB_GREP --silent "${MEMBER_ID}" <(echo "${MEMBER_LIST}"); then
            fail "failed to add '${HINT}' to card!"
        fi
    done < <(trello_member_id "$@")
}

_gtb_trello_card_member_list() {
    GTB_TRELLO_CARD_ID="${GTB_TRELLO_CARD_ID:?Trello card ID is required! Specify by --card-id <NAME>.}"

    _gtb_trello_api "/cards/${GTB_TRELLO_CARD_ID}/members" \
        | jq -jr '.[] | .username, "|", .initials, "|", .fullName, "|", .id, "\n"' \
        | _gtb_sort "${GTB_SORT_ORDER:-1,1}" '|' \
        | _gtb_cuts "${GTB_FIELDS:-1-}" '|' \
        | _gtb_table_format -s '|'
}

_gtb_trello_card_member() {
    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_trello_card_archive() {
    GTB_TRELLO_CARD_ID="${GTB_TRELLO_CARD_ID:?Trello card ID is required! Specify by --card-id <ID>.}"

    local URL="/cards/${GTB_TRELLO_CARD_ID}?closed=true"

    _gtb_trello_api --method 'PUT' "$URL" >/dev/null

    _gtb_trello_check_card_closed "$GTB_TRELLO_CARD_ID"
}

_gtb_trello_card_create() {
    GTB_TRELLO_BOARD_NAME="${GTB_TRELLO_BOARD_NAME:?Trello board name is required! Specify by --board <NAME>.}"
    GTB_TRELLO_LIST_NAME="${GTB_TRELLO_LIST_NAME:?Trello list name is required! Specify by --list <NAME>.}"

    # must read all input from stdin before running any httpie commands
    if [[ -p /dev/stdin ]]; then
        GTB_TRELLO_CARD_DESC=$(echo $GTB_TRELLO_CARD_DESC; cat)
    fi

    local LIST_ID=$(_gtb_trello_find_list_id "$GTB_TRELLO_BOARD_NAME" "$GTB_TRELLO_LIST_NAME")

    local MEMBER_IDS=''
    if [[ -n "$GTB_TRELLO_CARD_MEMBERS" ]]; then
        MEMBER_IDS=$(trello_member_id $GTB_TRELLO_CARD_MEMBERS | _gtb_cuts 1 | paste -sd',' -)
    fi

    local PARAMS="idList=${LIST_ID}&pos=top"

    [[ -n "$GTB_TRELLO_CARD_NAME" ]] && PARAMS="$PARAMS&name=$(_gtb_urlencode "$GTB_TRELLO_CARD_NAME")"
    [[ -n "$GTB_TRELLO_CARD_DESC" ]] && PARAMS="$PARAMS&desc=$(_gtb_urlencode "$GTB_TRELLO_CARD_DESC")"
    [[ -n "$MEMBER_IDS" ]] && PARAMS="$PARAMS&idMembers=${MEMBER_IDS}"
    PARAMS="$PARAMS&due=$(gdate --date="$GTB_TRELLO_CARD_DUE_IN_DAYS days" --iso-8601=seconds)"

    _gtb_trello_api --method 'POST' "/cards?${PARAMS}" \
        | jq -jr '.id, " ", .shortUrl, " ", .name, "\n"'
}

_gtb_trello_card_check() {
    GTB_TRELLO_BOARD_NAME="${GTB_TRELLO_BOARD_NAME:?Trello board name is required! Specify by --board <NAME>.}"
    GTB_TRELLO_LIST_NAME="${GTB_TRELLO_LIST_NAME:?Trello list name is required! Specify by --list <NAME>.}"

    local LIST_ID=$(_gtb_trello_find_list_id "$GTB_TRELLO_BOARD_NAME" "$GTB_TRELLO_LIST_NAME")
    assert_not_empty "Cannot find list with name '$GTB_TRELLO_LIST_NAME'!" "$LIST_ID"

    local cards_info=$(_gtb_trello_api "/lists/${LIST_ID}/cards" \
        | jq -jr '.[] | .pos, " ", .name, " ", .badges.checkItemsChecked, " ", .badges.checkItems, " ", .id, " ", .shortUrl, "\n"')

    local student_lines=$(_gtb_filter_students "$@")
    echo "$student_lines" | cut -d' ' -f2,7 | while read -r ORG CHINESE_NAME REST
    do
        local card_info=$(echo "$cards_info" | grep --color=never "$CHINESE_NAME")
        [[ -n "$card_info" ]] && status='OK' || status="ER"
        echo $status $ORG $card_info
    done \
        | _gtb_sort '1,1r;5,5n;6,6n;7,7' \
        | _gtb_table_format \
        | _gtb_tr_symbols
}

_gtb_trello_card_list() {
    GTB_TRELLO_BOARD_NAME="${GTB_TRELLO_BOARD_NAME:?Trello board name is required! Specify by --board <NAME>.}"

    local BOARD_ID=$(_gtb_trello_find_board_id "$GTB_TRELLO_BOARD_NAME")
    assert_not_empty "Cannot find board with name '$GTB_TRELLO_BOARD_NAME'!" "$BOARD_ID"

    local URL="/boards/${BOARD_ID}/cards"

    if [[ -n "$GTB_TRELLO_LIST_NAME" ]]; then
        local LIST_ID=$(_gtb_trello_find_list_id "$GTB_TRELLO_BOARD_NAME" "$GTB_TRELLO_LIST_NAME")
        assert_not_empty "Cannot find list with name '$GTB_TRELLO_LIST_NAME'!" "$LIST_ID"
        URL="/lists/${LIST_ID}/cards"
    fi

    _gtb_trello_api "$URL" \
        | jq -jr '.[] | .pos, "^", .id, "^", .shortUrl, "^", .name, "\n"' \
        | _gtb_sort "${GTB_SORT_ORDER:-1,1n}" \
        | _gtb_table_format -s '^'
}

_gtb_trello_card_id() {
    GTB_TRELLO_BOARD_NAME="${GTB_TRELLO_BOARD_NAME:?Trello board name is required! Specify by --board <NAME>.}"
    GTB_TRELLO_CARD_NAME="${GTB_TRELLO_CARD_NAME:?Trello card name is required! Specify by --card-name <NAME>.}"

    _gtb_trello_find_card_id "${GTB_TRELLO_BOARD_NAME}" "${GTB_TRELLO_CARD_NAME}"
}

_gtb_trello_card() {
    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_trello_list_list() {
    GTB_TRELLO_BOARD_NAME="${GTB_TRELLO_BOARD_NAME:?Trello board name is required! Specify by --board <NAME>.}"
    local BOARD_ID=$(_gtb_trello_find_board_id "$GTB_TRELLO_BOARD_NAME")

    _gtb_trello_api "/boards/${BOARD_ID}/lists" \
        | jq -jr '.[] | .id, "^", .name, "\n"' \
        | _gtb_table_format -s '^'
}

_gtb_trello_list() {
    if ! echo $1 | grep --silent '^\(list\)$'; then
        set -- list "$@"
    fi

    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_trello_board_member() {
    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_trello_board_member_list() {
    trello_board_member_list \
        | _gtb_sort "${GTB_SORT_ORDER:-1,1}" '|' \
        | _gtb_cuts "${GTB_FIELDS:-1-}" '|' \
        | _gtb_table_format -s '|'
}

trello_board_member_list() {
    GTB_TRELLO_BOARD_NAME="${GTB_TRELLO_BOARD_NAME:?Trello board name is required! Specify by --board <NAME>.}"

    local -r BOARD_ID=$(_gtb_trello_find_board_id "$GTB_TRELLO_BOARD_NAME")
    assert_not_empty "Cannot find board with name '$GTB_TRELLO_BOARD_NAME'!" "$BOARD_ID"

    _gtb_trello_api "/boards/${BOARD_ID}/members" \
        | jq -jr '.[] | .id, "|", .username, "|", .fullName, "\n"'
}

_gtb_trello_board_member_check() {
    local KEEP_FILE='1'

    [[ $# -ne 0 ]] && KEEP_FILE='2'

    join -1 1 -2 1 -a "${KEEP_FILE}" -o '1.1,1.2,1.3,2.2,2.3,2.4,2.5' -e "${STATUS_NOT_FOUND}" -t '|' \
        <(trello_board_member_list | _gtb_sort '1,1' '|') \
        <(
            {
                GTB_FROM_TRAINERS=true trello_member_id "$@" | sed 's/ / 3 Coach /2'
                GTB_FROM_BUDDIES=true trello_member_id "$@" | sed 's/ / 2 Buddy /2'
                GTB_FROM_STUDENTS=true trello_member_id "$@" | sed 's/ / 1 Student /2'
            } | _gtb_cuts '1-5' | _gtb_sort '1,1;5,5' | tr ' ' '|'
        ) \
        | _gtb_sort "5,5nr;7,7" '|' \
        | _gtb_cuts '1-4,6-7' '|' \
        | _gtb_cuts "${GTB_FIELDS:-1-}" '|' \
        | _gtb_table_format -s '|' \
        | _gtb_highlight \
            "${STATUS_NOT_FOUND}" red
}

_gtb_trello_board_remove() {
    GTB_TRELLO_BOARD_NAME="${GTB_TRELLO_BOARD_NAME:?Trello board name is required! Specify by --board <NAME>.}"

    local student_lines=$(_gtb_filter_students "$@")
    local students_count=$(_gtb_count_lines "$student_lines")

    assert_not_empty "error: cannot find any students with filters: '$@'!" "$student_lines"

    echo "$student_lines" \
        | _gtb_cuts 2,4,7 \
        | sort \
        | column -t \
        | cat -n

    if [[ "false" == "$GTB_YES" ]]; then
        read -p "about to REMOVE ${students_count} students from Trello board $GTB_TRELLO_BOARD_NAME? (y|n) " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]
        then
            return 1
        fi
    fi

    echo "$student_lines" \
        | _gtb_cuts '2,5' \
        | env_parallel --jobs 1 --colsep ' ' $GTB_PARALLEL_OPT_PROGRESS_BAR --linebuffer \
            _gtb_trello_remove_member_from_board {1} {2} \
        | _gtb_sort 1r \
        | _gtb_table_format \
        | _gtb_tr_symbols
}

_gtb_trello_board_invite() {
    GTB_TRELLO_BOARD_NAME="${GTB_TRELLO_BOARD_NAME:?Trello board name is required! Specify by --board <NAME>.}"
    GTB_TRELLO_MEMBER_TYPE="${GTB_TRELLO_MEMBER_TYPE:?Trello member type is required! Specify by --type <admin|normal|observer>.}"

    local -r BOARD_ID=$(_gtb_trello_find_board_id "$GTB_TRELLO_BOARD_NAME")
    assert_not_empty "Cannot find board with name '$GTB_TRELLO_BOARD_NAME'!" "$BOARD_ID"

    # input should have two fields: name, email
    local input

    if [[ -p /dev/stdin ]]; then
        input=$(cat)
    elif [[ "true" == "$GTB_FROM_BUDDIES" ]]; then
        input=$(_gtb_filter_buddies "$@" | _gtb_cuts '1,3')
    else
        input=$(_gtb_filter_students "$@" | _gtb_cuts '1,5')
    fi

    echo "$input" \
        | env_parallel --jobs $JOBS --colsep ' ' $GTB_PARALLEL_OPT_PROGRESS_BAR --linebuffer \
            _gtb_trello_invite_member_to_board {1} {2} \
        | _gtb_sort 1r \
        | _gtb_table_format \
        | _gtb_tr_symbols
}

_gtb_trello_board_list() {
    _gtb_trello_api "/members/${GTB_TRELLO_USERNAME}/boards" \
        | jq -jr '.[] | .id, "^", .shortUrl, "^", .name, "\n"' \
        | _gtb_table_format -s '^'
}

_gtb_trello_board_id() {
    GTB_TRELLO_BOARD_NAME="${GTB_TRELLO_BOARD_NAME:?Trello board name is required! Specify by --board <NAME>.}"
    _gtb_trello_find_board_id "${GTB_TRELLO_BOARD_NAME}"
}

_gtb_trello_board() {
    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_trello_boards() {
    echo $GTB_TERM | sed -e 's/gtb/GTB/' -e 's/-/-Dev-/'
    echo $GTB_TERM | sed -e 's/gtb/GTB/' -e 's/-/-Dev-/' -e 's/$/-Forum/'
    echo $GTB_TERM | sed -e 's/gtb/GTB/' -e 's/$/-Buddy/'
    echo "Image-Host"
}

_gtb_trello_member() {
    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_trello_member_username() {
    local input
    if [[ "true" == "$GTB_FROM_BUDDIES" ]]; then
        input=$(_gtb_filter_buddies "$@" | _gtb_cuts '1,3')
    elif [[ "true" == "$GTB_FROM_TRAINERS" ]]; then
        input=$(_gtb_filter_trainers "$@" | _gtb_cuts '1,3')
    else
        input=$(_gtb_filter_students "$@" | _gtb_cuts '1,5')
    fi

    [[ -z "$input" ]] && return 0

    # TODO support input from pipe
    echo "$input" | while read -r fullname email; do
        _gtb_trello_api_get_member_username "$email" "$fullname"
    done | _gtb_sort '2,2'
}

_gtb_trello_member_id() {
    trello_member_id "$@" \
        | _gtb_sort "${GTB_SORT_ORDER:-1,1;3,3}" \
        | _gtb_cuts "${GTB_FIELDS:-1-}" \
        | _gtb_table_format
}

trello_member_id() {
    if [[ "true" == "$GTB_FROM_STDIN" && -p /dev/stdin ]]; then
        cat
    elif [[ "true" == "$GTB_FROM_BUDDIES" ]]; then
        _gtb_filter_buddies "$@" | awk '{print $3, $1, $2, $4}'
    elif [[ "true" == "$GTB_FROM_TRAINERS" ]]; then
        _gtb_filter_trainers "$@" | awk '{print $3, $1, $4}'
    else
        _gtb_filter_students "$@" | awk '{print $5, $1, $2, $7}'
    fi \
        | while read -r email hint; do
            _gtb_trello_api_get_member_id "$email" "$hint"
        done
}

_gtb_trello_api_get_member_username() {
    local -r QUERY=${1:?search query is required!}
    shift
    local RESULT="$(_gtb_cache_get trello "member-username-${QUERY}")"

    if [[ -n "$RESULT" ]]; then
        echo "$RESULT $*"
        return 0
    fi

    RESULT=$(_gtb_trello_api "/search/members?query=${QUERY}&limit=1" | jq -r '.[0].username')
    if [[ -n "$RESULT" ]] && [[ 'null' != "$RESULT" ]]; then
        _gtb_cache_set trello "member-username-${QUERY}" "$RESULT"
        echo "$RESULT $*"
        return 0
    fi

    return 1
}

_gtb_trello_api_get_member_id() {
    local -r QUERY=${1:?search query is required!}
    local RESULT="$(_gtb_cache_get trello "member-id-${QUERY}")"

    if [[ -n "$RESULT" ]]; then
        echo "$RESULT $*"
        return 0
    fi

    RESULT=$(_gtb_trello_api "/search/members?query=${QUERY}&limit=1" | jq -r '.[0].id')
    if [[ -n "$RESULT" ]] && [[ 'null' != "$RESULT" ]]; then
        _gtb_cache_set trello "member-id-${QUERY}" "$RESULT"
        echo "$RESULT $*"
        return 0
    fi

    echo "${STATUS_NOT_FOUND} $*"
    return 1
}

_gtb_trello_limits() {
    _gtb_trello_api "/resource/limits"
}

_gtb_trello_api() {
    local HTTP_METHOD
    local HTTP_PRINT
    local OPTION_IGNORE_STDIN='--ignore-stdin'

    while (( "$#" )); do
        case "$1" in
            --method)
                if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
                    HTTP_METHOD="$2"
                    shift 2
                else
                    fail "Error: HTTP method specified by '$1' is missing"
                fi
                ;;
            --print)
                if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
                    HTTP_PRINT="$2"
                    shift 2
                else
                    fail "Error: httpie --print WHAT specified by '$1' is missing, e.g. HBhb"
                fi
                ;;
            --stdin)
                OPTION_IGNORE_STDIN=''
                shift
                ;;
            *)
                break
                ;;
        esac
    done

    HTTP_METHOD=${HTTP_METHOD:-$GTB_HTTP_METHOD}
    HTTP_PRINT=${HTTP_PRINT:-$GTB_HTTP_PRINT}

    local -r API_PATH="${1:?path is required! (e.g. /cards/\{id\})}"
    local OPTION_PRINT=''
    [[ -n "$HTTP_PRINT" ]] && OPTION_PRINT="--print $HTTP_PRINT"

    local URL="${GTB_TRELLO_API}${API_PATH}"
    if [[ "$API_PATH" =~ '?' ]]; then
        URL="${URL}${GTB_TRELLO_AUTH}"
    else
        URL="${URL}${GTB_TRELLO_AUTH/&/?}"
    fi

    run "http $OPTION_IGNORE_STDIN $OPTION_PRINT $HTTP_METHOD '${URL}'"
}

_gtb_trello() {
    GTB_TRELLO_API='https://api.trello.com/1'
    GTB_TRELLO_API_KEY="${GTB_TRELLO_API_KEY:?Trello API Key should be set! 'https://trello.com/app-key'}"
    GTB_TRELLO_TOKEN="${GTB_TRELLO_TOKEN:?Trello token should be set! 'https://trello.com/app-key'}"
    GTB_TRELLO_AUTH="&key=$GTB_TRELLO_API_KEY&token=$GTB_TRELLO_TOKEN"
    GTB_TRELLO_USERNAME="${GTB_TRELLO_USERNAME:?Trello username should be set! 'Avatar -> Profile and visibility -> About -> Username'}"

    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_tr() {
    _gtb_trello "$@"
}

_gtb_github() {
    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_gh() {
    _gtb_github "$@"
}

_gtb_github_limits() {
    gh api --include /users/octocat \
        | grep --color=never X-Ratelimit \
        | awk '{if ($1 == "X-Ratelimit-Reset:") { print $1, "^", strftime("%c", $2); } else { print $1, "^", $2; } }' \
        | _gtb_table_format -N -s '^'
}

_gtb_cache() {
    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_cache_list() {
    local -r FILENAME=${1:?cache filename is required!}
    local -r CACHE_FILE="$GTB_USER_CACHE_DIR/$FILENAME"

    cat "$CACHE_FILE" \
        | _gtb_cuts "${GTB_FIELDS:-1-}" \
        | _gtb_table_format
}

_gtb_cache_get() {
    local -r FILENAME=${1:?cache filename is required!}
    local -r KEY=${2:?cache KEY is required!}

    local -r CACHE_FILE="$GTB_USER_CACHE_DIR/$FILENAME"
    local -r CACHE_KEY="${KEY// /-}"

    [[ ! -f $CACHE_FILE ]] && return

    awk -v KEY="$CACHE_KEY" '$1 == KEY' "$CACHE_FILE" | cut -d' ' -f2-
}

_gtb_cache_set() {
    local -r FILENAME=${1:?cache filename is required!}
    local -r KEY=${2:?cache KEY is required!}
    local -r VALUE=${3:?cache VALUE is required!}

    local -r CACHE_FILE="$GTB_USER_CACHE_DIR/$FILENAME"
    local -r CACHE_KEY="${KEY// /-}"

    echo "${CACHE_KEY} ${VALUE}" >> "$CACHE_FILE"
}

_gtb_cache_file() {
    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_cache_file_list() {
    $GTB_FIND "$GTB_USER_CACHE_DIR" -type f -printf "%f\n"
}

_gtb_tag_stat() {
    local POSITION=${1:?Tag position, starts from 1, is required!}
    shift

    local total_fields=$(head -n1 $GTB_STUDENTS_FILE | wc -w)

    if [[ "$POSITION" -lt 1 ]] || [[ "$POSITION" -gt $total_fields ]]
    then
        fail "error: position '$POSITION' is out of range."
    fi

    GTB_RAW="true"

    _gtb_student_list "$@" | _gtb_count "$POSITION"
}

_gtb_tag_remove() {
    local POSITION=${1:?Tag position, starts from 1, is required!}

    local total_fields=$(head -n1 $GTB_STUDENTS_FILE | wc -w)

    if [[ "$POSITION" -lt 1 ]] || [[ "$POSITION" -gt $total_fields ]]
    then
        fail "error: position '$POSITION' is out of range."
    fi

    local BACKUP_FILE="/tmp/${GTB_STUDENTS_FILE##*/}"
    run "cp $GTB_STUDENTS_FILE $BACKUP_FILE"

    [[ -f "$BACKUP_FILE" ]] || fail "error: cannot backup students file to '$BACKUP_FILE'."

    local fields=$(seq 1 $total_fields | tr '\n' ',' | sed "s/${POSITION},//" | sed 's/,$//')
    run "cat $BACKUP_FILE | cut -d' ' -f${fields} > $GTB_STUDENTS_FILE"

    _gtb_config_diff "$GTB_STUDENTS_FILE"
}

_gtb_tag_replace() {
    local FROM_TAG=${1:?Source tag is required!}
    local TO_TAG=${2:?Target tag is required!}
    shift 2

    local student_lines=$(_gtb_filter_students "$@")

    if ! grep -w --color --silent "$FROM_TAG" <(echo "$student_lines") 1>&2
    then
        fail 'error: source tag not found, please make sure you are using the correct value.'
    fi

    if grep -w --color "$TO_TAG" <(echo "$student_lines") 1>&2
    then
        fail 'error: new tag conficts with existing entires shown as above, please change a new one.'
    fi

    echo "$student_lines" \
        | _gtb_cuts 1 \
        | env_parallel --linebuffer --jobs 1 $GTB_PARALLEL_OPT_PROGRESS_BAR "sed -i.bak -E '/{}/s/[[:<:]]$FROM_TAG[[:>:]]/$TO_TAG/g' $GTB_STUDENTS_FILE"

    _gtb_config_diff "$GTB_STUDENTS_FILE"
}

_gtb_tag_add() {
    local TAG=${1:?Tag is required!}

    if grep -w --color "$TAG" "$GTB_STUDENTS_FILE" 1>&2
    then
        fail 'error: new tag conficts with existing entires shown as above, please change a new one.'
    fi

    local total_fields=$(head -n1 $GTB_STUDENTS_FILE | wc -w)
    local POSITION=${GTB_POSITION:-$((total_fields + 1))}

    if [[ "$POSITION" -le 1 ]]
    then
        run "sed -i.bak 's/^/$TAG /g' $GTB_STUDENTS_FILE"
    elif [[ "$POSITION" -gt $total_fields ]]
    then
        run "sed -i.bak 's/$/ $TAG/g' $GTB_STUDENTS_FILE"
    else
        local BACKUP_FILE="/tmp/${GTB_STUDENTS_FILE##*/}"
        run "cp $GTB_STUDENTS_FILE $BACKUP_FILE"

        [[ -f "$BACKUP_FILE" ]] || fail "error: cannot backup students file to '$BACKUP_FILE'."

        paste -d ' ' \
            <(cat $BACKUP_FILE | _gtb_cuts "1-$((POSITION - 1))") \
            <(jot -n -b "$TAG" $(wc -l $BACKUP_FILE)) \
            <(cat $BACKUP_FILE | _gtb_cuts "$((POSITION))-") \
            > $GTB_STUDENTS_FILE
    fi

    _gtb_config_diff "$GTB_STUDENTS_FILE"
}

_gtb_tag_index() {
    head -n1 $GTB_STUDENTS_FILE | _gtb_student_show_format
}

_gtb_tag() {
    assert_students_file_exists

    if ! echo $1 | grep --silent '^\(index\|add\|replace\|remove\|stat\)$'; then
        set -- index "$@"
    fi

    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_config_pull() {
    run "git -C '$GTB_CONFIG_DIR' pull --rebase --autostash"
}

_gtb_config_push() {
    run "cd '$GTB_CONFIG_DIR'"
    run "git pull --rebase --autostash"
    run "git push"
}

_gtb_config_commit() {
    run "git -C ${GTB_CONFIG_DIR} add students-*.txt trainers.txt buddies-*.txt assignment-*.txt eot-*.txt feedbacks"
    run "git -C ${GTB_CONFIG_DIR} commit --allow-empty -m '$*'"
}

_gtb_config_show() {
    local TERM_NAME=${1:-$GTB_TERM}
    less -N "$GTB_CONFIG_DIR/students-${TERM_NAME}.txt"
}

_gtb_config_edit() {
    local TERM_NAME=${1:-$GTB_TERM}
    vim "$GTB_CONFIG_DIR/students-${TERM_NAME}.txt"
}

_gtb_config_checkout() {
    run "git -C ${GTB_CONFIG_DIR} checkout ."
}

_gtb_config_status() {
    run "git -C ${GTB_CONFIG_DIR} status"
}

_gtb_config_diff() {
    local FILES="${1:-.}"
    run "cd '$GTB_CONFIG_DIR'"
    run "git --no-pager diff --stat $FILES"
    run "git --no-pager diff --color-words $FILES"
}

_gtb_config_list() {
    run "cd '$GTB_CONFIG_DIR'"
    run 'ls -l students*.txt'
}

_gtb_config_dir() {
    echo "$GTB_CONFIG_DIR"
}

_gtb_config() {
    [[ -d $GTB_CONFIG_DIR ]] || fail 'Cannot find config directory `$GTB_CONFIG_DIR`. Please run `gtb init`.'

    _gtb_run_subcommand ${FUNCNAME[0]#_gtb_} "$@"
}

_gtb_colors() {
  # for bg_color in {0..$(tput colors)}; do
  for bg_color in $(seq 0 $(tput colors)); do
    tput setaf 231
    tput setab $bg_color
    printf "  %3d  " $bg_color
    if [[ $(( $bg_color % 8 )) -eq 0 ]]; then
        tput sgr0
        printf "\n"
    fi;
  done;
}

_gtb_upgrade() {
    if [[ "false" == "$GTB_YES" ]]; then
        read -p "Are you SURE to upgrade to lastest version? (y|n) " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]
        then
            return 1
        fi
    fi

    run "brew install --ignore-dependencies GTB-training/gtb/util"
}

_gtb_update() {
    _gtb_config_pull "$@"
}

_gtb_init() {
    mkdir -p $GTB_ROOT/$GTB_REPOS_DIR
    mkdir -p $GTB_ROOT/$GTB_TERMS_DIR
    mkdir -p $GTB_USER_CACHE_DIR

    if [[ -d $GTB_CONFIG_DIR ]]
    then
        warn "warn: '$GTB_CONFIG_DIR' already exists!"
        return
    fi

    gh_clone_repo $GTB_ORG $GTB_CONFIG_REPO $GTB_CONFIG_DIR
}

_gtb_term() {
    echo $GTB_TERM
}

_gtb_version() {
    echo "gtb $VERSION"
    exit 0
}

_gtb_help() {
    echo "Please refer to the README doc:"
    info "https://github.com/GTB-training/util/blob/master/README.md"
    exit 0
}

OPTIND=1

JOBS=${GTB_DEFAULT_JOBS:-30}
AUTO_UPDATE="false"
AUTO_BUILD="false"
AUTO_ACCEPT="true"
AUTO_TEST="false"
CHECK_ROLE_ONLY="false"

shopt -s extglob

declare -a PARAMS

while (( "$#" )); do
    case "$1" in
        --jobs)
            if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
                JOBS=$2
                shift 2
            else
                fail "Error: Argument for $1 is missing"
            fi
            ;;
        --branch)
            if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
                BRANCH_NAME=$2
                shift 2
            else
                fail "Error: branch name specified by '$1' is missing"
            fi
            ;;
        --username)
            if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
                GTB_TRELLO_USERNAME=$2
                GTB_USERNAME=$2
                shift 2
            else
                fail "Error: Username specified by '$1' is missing"
            fi
            ;;
        --board)
            if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
                GTB_TRELLO_BOARD_NAME=$2
                shift 2
            else
                fail "Error: Trello board name specified by '$1' is missing"
            fi
            ;;
        --list)
            if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
                GTB_TRELLO_LIST_NAME=$2
                shift 2
            else
                fail "Error: Trello list name specified by '$1' is missing"
            fi
            ;;
        --card-id)
            if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
                GTB_TRELLO_CARD_ID=$2
                shift 2
            else
                fail "Error: Trello card ID specified by '$1' is missing"
            fi
            ;;
        --card-name)
            if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
                GTB_TRELLO_CARD_NAME=$2
                shift 2
            else
                fail "Error: Trello card name specified by '$1' is missing"
            fi
            ;;
        --name)
            if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
                GTB_TRELLO_CARD_NAME=$2
                shift 2
            else
                fail "Error: Trello card name specified by '$1' is missing"
            fi
            ;;
        --desc)
            if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
                GTB_TRELLO_CARD_DESC=$2
                shift 2
            else
                fail "Error: Trello card description specified by '$1' is missing"
            fi
            ;;
        --members)
            if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
                GTB_TRELLO_CARD_MEMBERS=$2
                shift 2
            else
                fail "Error: Trello card members specified by '$1' is missing"
            fi
            ;;
        --due-in-days)
            if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
                GTB_TRELLO_CARD_DUE_IN_DAYS=$2
                shift 2
            else
                fail "Error: Trello card due in days specified by '$1' is missing"
            fi
            ;;
        --type)
            if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
                GTB_TRELLO_MEMBER_TYPE=$2
                shift 2
            else
                fail "Error: Trello member type specified by '$1' is missing"
            fi
            ;;
        -f|--fields)
            if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
                GTB_FIELDS=$2
                shift 2
            else
                fail "Error: Fields to display specified by '$1' is missing"
            fi
            ;;
        --position)
            if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
                GTB_POSITION=$2
                shift 2
            else
                fail "Error: Position of new tag specified by '$1' is missing"
            fi
            ;;
        --pk)
            if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
                GTB_PK=$2
                shift 2
            else
                fail "Error: primary key specified by '$1' is missing"
            fi
            ;;
        --step)
            if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
                GTB_STEP=$2
                shift 2
            else
                fail "Error: step name specified by '$1' is missing"
            fi
            ;;
        --org)
            if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
                GTB_ORG_NAME=$2
                shift 2
            else
                fail "Error: GitHub org name specified by '$1' is missing"
            fi
            ;;
        --repo)
            if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
                GTB_REPO=$2
                shift 2
            else
                fail "Error: repository name specified by '$1' is missing"
            fi
            ;;
        --refs)
            if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
                GTB_REFS=$2
                shift 2
            else
                fail "Error: refs to pick specified by '$1' is missing, comma separated, e.g. origin/extended-tests,origin/fix"
            fi
            ;;
        --start)
            if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
                GTB_START_AT=$2
                shift 2
            else
                fail "Error: evaluation start_at time specified by '$1' is missing, e.g. 2021041609"
            fi
            ;;
        --basic)
            if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
                GTB_DURATION_BASIC=$2
                shift 2
            else
                fail "Error: evaluation basic part duration specified by '$1' is missing, e.g. 8h, 10h, 7d, 14d"
            fi
            ;;
        --refactor)
            if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
                GTB_DURATION_REFACTOR=$2
                shift 2
            else
                fail "Error: evaluation refactor part duration specified by '$1' is missing, e.g. 14d, 21d, 8h, 10h"
            fi
            ;;
        --sort)
            if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
                GTB_SORT_ORDER=$2
                shift 2
            else
                fail "Error: column to sort with specified by '$1' is missing, e.g. total, evaluation, homework, performance, '1,1nr;2,2'"
            fi
            ;;
        --team)
            if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
                GTB_ORG_TEAM="$2"
                shift 2
            else
                fail "Error: GitHub org's team name specified by '$1' is missing"
            fi
            ;;
        --trainer)
            if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
                GTB_TRAINER_FILTER="$2"
                shift 2
            else
                fail "Error: trainer filter specified by '$1' is missing"
            fi
            ;;
        --buddy)
            if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
                GTB_BUDDY_FILTER="$2"
                shift 2
            else
                fail "Error: buddy filter specified by '$1' is missing"
            fi
            ;;
        -s)
            if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
                GTB_TABLE_FORMAT_SEPARATOR="$2"
                shift 2
            else
                fail "Error: separator specified by '$1' is missing"
            fi
            ;;
        --print)
            if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
                GTB_HTTP_PRINT="$2"
                shift 2
            else
                fail "Error: httpie --print WHAT specified by '$1' is missing, e.g. HBhb"
            fi
            ;;
        --method)
            if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
                GTB_HTTP_METHOD="$2"
                shift 2
            else
                fail "Error: HTTP method specified by '$1' is missing"
            fi
            ;;
        --start-num)
            if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
                GTB_START_NUM="$2"
                shift 2
            else
                fail "Error: index start number specified by '$1' is missing"
            fi
            ;;
        --chunk)
            if [[ -n "$2" ]] && [[ ${2:0:1} != "-" ]]; then
                GTB_CHUNK="$2"
                shift 2
            else
                fail "Error: CHUNK specified by '$1' is missing, e.g. 1/10, 3/24"
            fi
            ;;
        --from-stdin)
            GTB_FROM_STDIN="true"
            shift
            ;;
        --from-students)
            GTB_FROM_STUDENTS="true"
            shift
            ;;
        --from-buddies)
            GTB_FROM_BUDDIES="true"
            shift
            ;;
        --from-trainers)
            GTB_FROM_TRAINERS="true"
            shift
            ;;
        --by-buddy)
            GTB_LIST_BY_BUDDY="true"
            shift
            ;;
        --by-buddee)
            GTB_LIST_BY_BUDDEE="true"
            shift
            ;;
        --all)
            GTB_ALL_BRANCHES="true"
            shift
            ;;
        --local)
            GTB_LOCAL="true"
            shift
            ;;
        --notify)
            GTB_NOTIFY="true"
            shift
            ;;
        --yes)
            GTB_YES="true"
            shift
            ;;
        --raw)
            GTB_RAW="true"
            shift
            ;;
        --force)
            GTB_FORCE="true"
            shift
            ;;
        -N|--no-line-numbers)
            GTB_LINE_NUMBERS="false"
            shift
            ;;
        -D|--debug)
            GTB_DEBUG="true"
            shift
            ;;
        -u|--update)
            AUTO_UPDATE="true"
            shift
            ;;
        -b|--build)
            AUTO_BUILD="true"
            shift
            ;;
        -l|--list)
            AUTO_ACCEPT="false"
            shift
            ;;
        -t|--test)
            AUTO_TEST="true"
            shift
            ;;
        --role)
            CHECK_ROLE_ONLY="true"
            shift
            ;;
        -+([0-9])[dHMS])
            PARAMS+=("$1")
            shift
            ;;
        -*|--*=)
            fail "Unsupported flag $1"
            shift
            ;;
        *)
            PARAMS+=("$1")
            shift
            ;;
    esac
done

set -- "${PARAMS[@]}"

source `which env_parallel.bash`

SUBCOMMAND=${1:?Subcommand is required! (e.g. init, clone, build, update, join, test, up, down, check, show, help.)}
shift

# main method starts from here...
if [[ "$(type -t ${SUBCMD_PREFIX}_$SUBCOMMAND)" != 'function' ]]; then
    error "Subcommand \`$SUBCOMMAND\` is INVALID!"
    exit 2
fi

${SUBCMD_PREFIX}_${SUBCOMMAND} "$@"

